[{"content":"Trong lập trình mạng, trước khi kết nối, ta phải biết \u0026ldquo;địa chỉ nhà\u0026rdquo; (IP) của mình và đối phương. Java cung cấp class InetAddress để làm việc này.\nCode lấy IP của máy (Localhost) 1 2 3 4 5 6 7 8 9 10 11 12 13 import java.net.InetAddress; public class MyIP { public static void main(String[] args) { try { InetAddress myIP = InetAddress.getLocalHost(); System.out.println(\u0026#34;Tên máy: \u0026#34; + myIP.getHostName()); System.out.println(\u0026#34;Địa chỉ IP: \u0026#34; + myIP.getHostAddress()); } catch (Exception e) { e.printStackTrace(); } } } Địa chỉ IP là gì trong lập trình mạng? IP (Internet Protocol Address) là địa chỉ định danh của một thiết bị khi tham gia vào mạng máy tính.\nTrong lập trình mạng, IP đóng vai trò quan trọng trong việc:\nXác định máy gửi và máy nhận Định tuyến dữ liệu trong quá trình truyền thông Thiết lập kết nối giữa các tiến trình chạy trên những máy khác nhau Nếu không có địa chỉ IP, các máy tính sẽ không thể nhận biết và giao tiếp với nhau.\nVai trò của lớp InetAddress trong Java Lớp InetAddress đại diện cho một địa chỉ IP trong Java.\nThông qua lớp này, lập trình viên có thể:\nLấy địa chỉ IP của máy đang chạy chương trình Lấy tên máy (hostname) Phân giải tên miền sang địa chỉ IP Chuẩn bị thông tin để tạo Socket hoặc ServerSocket Hầu hết các chương trình lập trình mạng trong Java đều sử dụng InetAddress ở bước khởi tạo.\nPhân tích ý nghĩa các lệnh trong chương trình InetAddress.getLocalHost()\n→ Trả về đối tượng đại diện cho máy cục bộ (localhost).\ngetHostName()\n→ Lấy tên máy do hệ điều hành hoặc mạng gán.\ngetHostAddress()\n→ Lấy địa chỉ IP của máy dưới dạng chuỗi.\nViệc in ra hostname và IP giúp:\nKiểm tra cấu hình mạng Xác định đúng máy khi kết nối Client – Server Debug lỗi mạng Một số lưu ý khi lấy IP trong Java Khi máy không kết nối mạng, IP có thể là 127.0.0.1 Khi máy có nhiều card mạng (WiFi, LAN, VPN), IP trả về có thể không phải IP Internet Trên Server, hostname và IP thường khác máy cá nhân Ứng dụng thực tế Việc xác định IP của máy thường được sử dụng trong:\nChương trình Client – Server Thông báo IP Server cho Client kết nối Kiểm tra kết nối mạng LAN Ghi log và giám sát hệ thống Kết luận Qua bài học này, ta đã:\nHiểu vai trò của địa chỉ IP trong lập trình mạng Biết cách lấy IP bằng lớp InetAddress Chuẩn bị nền tảng cho các kỹ thuật TCP, UDP và RMI Liên hệ với học phần Lập trình Mạng máy tính Bài học này nằm trong nội dung mở đầu của học phần Lập trình Mạng máy tính (CMP180) tại Trường Đại học Công nghệ TP.HCM (HUTECH).\nTrong lộ trình môn học, sinh viên sẽ lần lượt tiếp cận các nội dung:\nKiến thức nền tảng về mạng và lập trình mạng Quản lý luồng nhập xuất (I/O) Quản lý địa chỉ và kết nối mạng Lập trình Socket TCP và UDP Xử lý đa tuyến, đa luồng Multicast UDP và Java RMI Thực hiện đồ án học phần cá nhân Mục tiêu của bài học Thông qua Bài 1, sinh viên sẽ:\nLàm quen với môi trường lập trình mạng bằng Java Hiểu được vai trò của địa chỉ IP trong giao tiếp mạng Biết cách sử dụng lớp InetAddress để lấy IP và hostname Chuẩn bị nền tảng cho các bài học tiếp theo về Socket và Server – Client ","permalink":"http://localhost:1313/blog/bai-viet-1/","summary":"Sử dụng class InetAddress để định danh máy tính.","title":"Bài 1: Làm sao biết máy mình đang dùng IP gì trong Java?"},{"content":"Trong lập trình mạng, nếu IP được xem như địa chỉ nhà của một máy tính trong mạng,\nthì Port (cổng) chính là số hiệu dùng để xác định chương trình hoặc dịch vụ cụ thể đang chạy trên máy đó.\nMột máy tính có thể chạy đồng thời nhiều ứng dụng mạng như Web Server, Database Server, Game Server hoặc Chat Server.\nMỗi ứng dụng bắt buộc phải gắn với một Port riêng để hệ điều hành có thể phân biệt và định tuyến dữ liệu chính xác.\nPort nằm ở đâu trong mô hình TCP/IP? Trong bộ giao thức TCP/IP, Port thuộc về Transport Layer (Tầng giao vận) và được sử dụng bởi hai giao thức chính là TCP và UDP.\nĐịa chỉ IP xác định máy nào sẽ nhận dữ liệu Port xác định ứng dụng nào trên máy đó sẽ xử lý dữ liệu Sự kết hợp giữa IP + Port tạo thành một Socket, là điểm cuối (endpoint) của quá trình giao tiếp mạng.\nCác loại Port phổ biến Port được đánh số từ 0 đến 65535 và được chia thành ba nhóm chính:\nInternet và các End Devices Trước khi tìm hiểu về Port, cần hiểu Internet được cấu thành từ hàng tỷ thiết bị đầu cuối (End Devices) như máy tính, điện thoại, máy chủ và các thiết bị IoT.\nCác thiết bị này kết nối với nhau thông qua nhiều lớp mạng khác nhau, và mỗi thiết bị khi tham gia giao tiếp mạng đều cần có địa chỉ IP và Port để định danh. Hình 2.1: Sơ đồ minh họa Internet và các thiết bị đầu cuối (End Devices) kết nối thông qua các mạng truy cập và mạng lõi.\nTrong quá trình giao tiếp mạng, một thiết bị không chỉ cần địa chỉ IP để xác định vị trí trong mạng, mà còn cần Port để xác định chính xác ứng dụng hoặc dịch vụ đang lắng nghe trên thiết bị đó.\nDo đó, Port đóng vai trò như “điểm tiếp nhận” (endpoint) cho các tiến trình mạng chạy trên cùng một máy.\nMô hình các tầng giao thức TCP/IP Để hiểu rõ Port hoạt động ở đâu và vì sao Server cần Port, ta cần nắm được mô hình giao thức TCP/IP – nền tảng của mọi ứng dụng mạng hiện nay.\nHình 2.2: Mô hình các tầng giao thức TCP/IP và các giao thức tiêu biểu tương ứng với từng tầng.\nTrong mô hình TCP/IP, địa chỉ IP hoạt động ở tầng Internet, giúp xác định thiết bị trong mạng.\nTrong khi đó, Port hoạt động ở tầng Transport (TCP/UDP), giúp xác định chính xác ứng dụng hoặc dịch vụ đang giao tiếp trên thiết bị đó.\nWell-known Ports (0 – 1023) Được dùng cho các dịch vụ chuẩn:\nPort 80: HTTP Port 443: HTTPS Port 21: FTP Port 25: SMTP Registered Ports (1024 – 49151) Thường dùng cho các ứng dụng phổ biến:\nPort 3306: MySQL Port 8080: Web Server thay thế port 80 Dynamic / Private Ports (49152 – 65535) Do hệ điều hành cấp phát tạm thời cho Client khi giao tiếp mạng.\nVì sao Server thường dùng cổng 8080? Cổng 8080 rất phổ biến trong quá trình phát triển và học tập vì:\nTránh xung đột với cổng 80 đang được hệ điều hành chiếm dụng Không cần quyền Administrator khi mở Server Phù hợp cho các Web Server thử nghiệm như: Apache Tomcat Spring Boot Node.js Lỗi thường gặp: “Address already in use” Lỗi này xảy ra khi Server cố gắng mở một Port đã bị chương trình khác chiếm dụng.\nNguyên nhân phổ biến:\nServer cũ chưa được tắt Port đang được dùng bởi dịch vụ khác Chạy nhiều Server cùng lúc Cách khắc phục:\nĐổi sang Port khác (ví dụ: 8080 → 9090) Kiểm tra Port đang sử dụng trong hệ điều hành Đảm bảo chỉ có một Server chạy tại một thời điểm Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), khái niệm Port sẽ được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Xây dựng mô hình Client – Server Java RMI và Multicast Việc hiểu rõ Port là nền tảng bắt buộc trước khi triển khai các ứng dụng mạng thực tế.\nKết luận Qua bài học này, ta đã:\nHiểu được Port là gì và vai trò của Port trong lập trình mạng Nắm được mối quan hệ giữa IP, Port và Socket Giải thích được lý do Server thường sử dụng cổng 8080 Chuẩn bị kiến thức nền cho các bài học tiếp theo về TCP và UDP ","permalink":"http://localhost:1313/blog/bai-viet-2/","summary":"Hiểu vai trò của Port trong lập trình mạng và lý do cổng 8080 thường được sử dụng.","title":"Bài 2: Port là gì? Tại sao Server hay dùng cổng 8080?"},{"content":"Khi xử lý các tác vụ mạng (như gọi API), người mới học JS hay viết code lồng nhau kiểu này:\n1 2 3 4 5 6 7 8 9 10 // Cực hình Callback Hell getData(function(a) { getMoreData(a, function(b) { getMoreData(b, function(c) { getMoreData(c, function(d) { console.log(d); }); }); }); }); ","permalink":"http://localhost:1313/blog/bai-viet-3/","summary":"Viết code JS lồng nhau quá nhiều sẽ tạo ra thảm họa.","title":"Bài 3: Callback Hell trong JavaScript và cách né tránh"},{"content":"Để gửi một file ảnh từ Client lên Server, chúng ta không dùng BufferedReader được (vì nó đọc text), mà phải dùng dòng byte.\nCode phía Client (Gửi) 1 2 3 4 5 6 7 8 9 10 11 12 // Đọc file từ ổ cứng FileInputStream fis = new FileInputStream(\u0026#34;anh-meo.jpg\u0026#34;); // Lấy luồng gửi ra mạng OutputStream os = socket.getOutputStream(); byte[] buffer = new byte[4096]; int bytesRead; // Vừa đọc file vừa đẩy ra mạng while ((bytesRead = fis.read(buffer)) != -1) { os.write(buffer, 0, bytesRead); } ","permalink":"http://localhost:1313/blog/bai-viet-4/","summary":"Gửi text thì dễ, gửi file nhị phân (ảnh, nhạc) thì phải dùng FileInputStream.","title":"Bài 4: Hướng dẫn gửi File ảnh qua Socket trong Java"},{"content":"Vấn đề của HTTP HTTP hoạt động kiểu \u0026ldquo;Hỏi - Đáp\u0026rdquo;. Client hỏi thì Server mới trả lời. Nếu Client im lặng, Server cũng im. Điều này không làm Chat được vì tin nhắn phải đến ngay lập tức.\nGiải pháp: WebSocket WebSocket tạo ra một \u0026ldquo;đường ống\u0026rdquo; kết nối liên tục 2 chiều.\nServer có tin nhắn mới -\u0026gt; Bắn ngay về Client. Client không cần hỏi (Request) liên tục. Trong JS, khởi tạo rất dễ:\n1 2 3 4 5 6 7 8 9 10 11 12 // Kết nối đến Server const socket = new WebSocket(\u0026#39;ws://localhost:8080\u0026#39;); // Lắng nghe sự kiện khi có tin nhắn đến socket.onmessage = function(event) { console.log(\u0026#34;Có tin nhắn mới: \u0026#34; + event.data); }; // Gửi tin nhắn đi socket.onopen = function() { socket.send(\u0026#34;Hello Server, I am Trọng!\u0026#34;); }; ","permalink":"http://localhost:1313/blog/bai-viet-5/","summary":"Tại sao Facebook, Zalo lại dùng WebSocket thay vì HTTP thông thường?","title":"Bài 5: WebSocket - Công nghệ sau các ứng dụng Chat Realtime"},{"content":"Blocking IO (Java IO cổ điển) Khi chương trình chạy lệnh socket.accept() hoặc in.read(), nó sẽ DỪNG LẠI (Block) và chờ đợi.\nNếu mạng lag hoặc Client chưa gửi gì, chương trình sẽ đứng hình ở đó luôn. Hậu quả: Server chỉ phục vụ được 1 người tại 1 thời điểm (nếu không dùng đa luồng). Non-Blocking IO (Java NIO) Chương trình không bao giờ bị dừng. Nó sẽ kiểm tra liên tục:\n\u0026ldquo;Có dữ liệu không?\u0026rdquo; -\u0026gt; Nếu có: Xử lý ngay. -\u0026gt; Nếu không: Đi làm việc khác, lát quay lại kiểm tra tiếp. Kết luận: Muốn Server chịu tải cao (hàng ngàn user) như Zalo/Facebook thì bắt buộc phải dùng Non-Blocking.\n","permalink":"http://localhost:1313/blog/bai-viet-6/","summary":"Khái niệm quan trọng để tối ưu hiệu năng Server.","title":"Bài 6: Phân biệt Blocking IO và Non-Blocking IO"},{"content":"Khi nhận dữ liệu từ Java Server trả về (thường là dạng chuỗi String), JS cần biến nó thành Object để dùng.\n1. JSON.parse() Biến chuỗi thành Object.\n1 2 3 let dataString = \u0026#39;{\u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;Trọng\u0026#34;}\u0026#39;; let user = JSON.parse(dataString); console.log(user.name); // Kết quả: Trọng ","permalink":"http://localhost:1313/blog/bai-viet-7/","summary":"Hai hàm quan trọng nhất khi làm việc với API.","title":"Bài 7: Xử lý dữ liệu JSON trong JavaScript"},{"content":"Lập trình mạng rất rủi ro (dây cáp lỏng, wifi yếu\u0026hellip;). Nếu không bắt lỗi, chương trình sẽ tắt cái rụp ngay lập tức.\nLuôn luôn dùng khối try-catch-finally khi đụng tới Socket:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Socket socket = null; try { // Cố gắng kết nối socket = new Socket(\u0026#34;localhost\u0026#34;, 8080); System.out.println(\u0026#34;Kết nối thành công!\u0026#34;); } catch (IOException e) { // Nếu lỗi thì chạy vào đây System.out.println(\u0026#34;Lỗi kết nối: \u0026#34; + e.getMessage()); } finally { // Luôn luôn chạy vào đây để dọn dẹp try { if (socket != null) socket.close(); } catch (Exception ex) {} } ","permalink":"http://localhost:1313/blog/bai-viet-8/","summary":"Mạng rớt, Server sập\u0026hellip; làm sao để chương trình không bị Crash?","title":"Bài 8: Xử lý ngoại lệ (Exception) khi lập trình mạng"},{"content":"Nếu bạn chạy code Server cơ bản, khi Client A kết nối, Server sẽ bận nói chuyện với A. Lúc này Client B kết nối tới sẽ bị \u0026ldquo;quay đều\u0026rdquo; (treo) cho đến khi A thoát ra. =\u0026gt; Để khắc phục, ta phải dùng Thread (Luồng).\nMô hình Server Đa luồng Tưởng tượng Server là một ông chủ quán (Main Thread):\nÔng chủ đứng ở cửa (socket.accept()). Khách A tới =\u0026gt; Ông chủ thuê nhân viên 1 ra tiếp A. Ông chủ quay lại cửa đứng chờ tiếp. Khách B tới =\u0026gt; Ông chủ thuê nhân viên 2 ra tiếp B. Code minh họa (Java) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 while (true) { // 1. Chờ khách tới (Main Thread bị block ở đây) Socket clientSocket = serverSocket.accept(); // 2. Có khách! Tạo một luồng riêng (Nhân viên) để xử lý Thread t = new Thread(new Runnable() { @Override public void run() { xuLyCongViec(clientSocket); // Nhân viên làm việc ở đây } }); // 3. Đẩy nhân viên ra làm việc, ông chủ quay lại vòng lặp chờ khách mới t.start(); } ","permalink":"http://localhost:1313/blog/bai-viet-9/","summary":"Nếu không có Đa luồng, Server của bạn chỉ phục vụ được đúng 1 người, người thứ 2 sẽ bị treo. Tại sao?","title":"Bài 9: Đa luồng (Multithreading) - Cách để Server tiếp 100 khách cùng lúc"},{"content":" Đồ án môn Lập trình mạng là cơ hội để sinh viên vận dụng các kiến thức lý thuyết vào thực tế, cụ thể là việc xây dựng và quản lý một hệ thống website tĩnh kết hợp với việc nghiên cứu sâu về các giao thức mạng. Bài viết này nhằm tổng kết lại toàn bộ quá trình thực hiện đồ án.\n1. Kết quả đạt được Sau thời gian nghiên cứu và thực hiện, đồ án đã hoàn thành các mục tiêu đề ra ban đầu:\nXây dựng thành công Website cá nhân: Sử dụng Hugo (Static Site Generator) và triển khai ổn định trên nền tảng Github Pages. Hệ thống bài viết chuyên môn: Hoàn thành 09 bài viết đi sâu vào các kỹ thuật cốt lõi của môn học như Java Socket, Multithreading (Đa luồng), và xử lý bất đồng bộ trong JavaScript. Làm chủ công cụ quản lý mã nguồn: Áp dụng quy trình Git Flow cơ bản để quản lý phiên bản (Version Control) và cập nhật nội dung. 2. Kiến thức và Kinh nghiệm thực tiễn Quá trình thực hiện đồ án đã giúp củng cố nhiều kiến thức quan trọng:\nSự khác biệt giữa Lý thuyết và Thực tế: Việc triển khai Socket trong môi trường thực tế phát sinh nhiều vấn đề không có trong lý thuyết như độ trễ mạng (latency), quản lý tài nguyên bộ nhớ và xử lý ngắt kết nối đột ngột. Kỹ năng Debugging và Troubleshooting: Nâng cao khả năng đọc hiểu Log lỗi, sử dụng Stack Trace để truy vết nguyên nhân sự cố trong cả môi trường Java và JavaScript. Tối ưu hóa Code: Hiểu rõ tầm quan trọng của việc viết code sạch (Clean Code) và tuân thủ các quy tắc định dạng để thuận tiện cho việc bảo trì sau này. 3. Lời cảm ơn Em xin gửi lời cảm ơn chân thành đến Giảng viên hướng dẫn bộ môn Lập trình mạng - Trường Đại học Công nghệ TP.HCM (HUTECH) đã tận tình giảng dạy và định hướng đề tài, giúp sinh viên tiếp cận với các công nghệ hiện đại.\nĐồng thời, xin cảm ơn các bạn trong lớp đã cùng trao đổi, hỗ trợ nhau giải quyết các vấn đề kỹ thuật trong suốt quá trình làm bài. Sinh viên thực hiện: Lê Quốc Trọng Khoa: Công nghệ thông tin - HUTECH\n","permalink":"http://localhost:1313/blog/bai-viet-10/","summary":"Báo cáo tổng kết quá trình thực hiện, các kết quả đạt được và kiến thức tích lũy từ đồ án xây dựng Blog cá nhân.","title":"Bài 10: Tổng kết và Đánh giá kết quả Đồ án môn Lập trình mạng"},{"content":"Lời mở đầu Có những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\nMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\nHọc tập Những năm đại học trôi qua nhanh hơn mình từng nghĩ. Ngày mới bước chân vào giảng đường, mình vẫn còn khá mơ hồ về ngành học, về tương lai, về chính bản thân mình sẽ trở thành ai sau bốn năm. Nhưng rồi từng môn học, từng bài tập nhóm, từng đồ án kéo mình lại gần hơn với cách một hệ thống được hình thành và vận hành.\nHệ thống thông tin không chỉ là lập trình, cũng không đơn thuần là công nghệ. Đó là câu chuyện về con người, quy trình và dữ liệu. Mình học cách đặt câu hỏi, học cách lắng nghe yêu cầu, học cách vẽ ra những sơ đồ tưởng chừng khô khan nhưng lại chứa rất nhiều suy nghĩ phía sau. Dần dần, mình nhận ra mình thích phần “hiểu vấn đề” hơn là chỉ chăm chăm vào lời giải.\nĐịnh hướng Ở thời điểm hiện tại, mình đang định hướng theo con đường Business Analyst (BA). Mình hứng thú với vai trò đứng giữa – không quá xa kỹ thuật, cũng không tách rời nghiệp vụ. Đó là nơi cần sự rõ ràng trong tư duy, sự kiên nhẫn trong giao tiếp và khả năng chuyển hóa những điều mơ hồ thành thứ có thể triển khai được.\nMình không nghĩ BA là một vị trí “nhẹ nhàng” hay “an toàn”. Ngược lại, đó là công việc đòi hỏi phải học rất nhiều, sai rất nhiều và sửa rất nhiều. Nhưng chính điều đó khiến mình thấy phù hợp. Mình muốn hiểu hệ thống trước khi xây dựng nó, muốn biết vì sao người ta see cần một chức năng, chứ không chỉ là nó được viết như thế nào.\nBlog Blog này ra đời khá tự nhiên, giống như một cuốn sổ mở rộng hơn là một trang thể hiện điều gì đó to tát. Mình viết để nhớ, để hệ thống lại những gì đã học, và đôi khi là để sắp xếp lại suy nghĩ của chính mình.\nỞ đây có thể là kiến thức về Hệ thống thông tin, về phân tích nghiệp vụ, về lập trình, hoặc đơn giản là những trải nghiệm học tập và va chạm trong quá trình làm đồ án, làm việc nhóm, và chuẩn bị bước ra môi trường thực tế. Mình không mong mọi thứ phải hoàn hảo, chỉ mong nó thật và có ích cho ai đó đang đi trên con đường tương tự.\nLời kết Mình đang ở một giai đoạn chưa thể gọi là trưởng thành, nhưng cũng không còn quá non nớt. Vẫn đang học, vẫn đang thử, vẫn đang sai và sửa mỗi ngày. Nếu có một điều mình mong giữ được lâu nhất, thì đó là sự tò mò và tinh thần học hỏi – những thứ giúp mình không đứng yên giữa rất nhiều lựa chọn ngoài kia.\nCảm ơn bạn đã ghé qua và đọc những dòng này. Hy vọng ở một thời điểm nào đó, những chia sẻ nhỏ ở đây sẽ chạm đến bạn – dù chỉ là một chút. \u0026ldquo;Học để chia sẻ, chia sẻ để học nhiều hơn.\u0026rdquo;\nLiên hệ Nếu bạn muốn gửi cho mình vài dòng trao đổi,\nbạn có thể liên hệ với mình qua Email hoặc GitHub ,Facebook dưới đây.\nCảm ơn bạn đã ghé thăm blog! ","permalink":"http://localhost:1313/about/","summary":"\u003ch2 id=\"lời-mở-đầu\"\u003eLời mở đầu\u003c/h2\u003e\n\u003cp\u003eCó những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\u003c/p\u003e\n\u003cp\u003eMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\u003c/p\u003e","title":"Giới thiệu"}]