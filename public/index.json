[{"content":"Trong lập trình mạng, trước khi kết nối, ta phải biết \u0026ldquo;địa chỉ nhà\u0026rdquo; (IP) của mình và đối phương. Java cung cấp class InetAddress để làm việc này.\nCode lấy IP của máy (Localhost) 1 2 3 4 5 6 7 8 9 10 11 12 13 import java.net.InetAddress; public class MyIP { public static void main(String[] args) { try { InetAddress myIP = InetAddress.getLocalHost(); System.out.println(\u0026#34;Tên máy: \u0026#34; + myIP.getHostName()); System.out.println(\u0026#34;Địa chỉ IP: \u0026#34; + myIP.getHostAddress()); } catch (Exception e) { e.printStackTrace(); } } } ","permalink":"http://localhost:1313/blog/bai-viet-1/","summary":"Sử dụng class InetAddress để định danh máy tính.","title":"Bài 1: Làm sao biết máy mình đang dùng IP gì trong Java?"},{"content":"Nếu IP là địa chỉ nhà, thì Port chính là số phòng. Một máy tính có thể chạy nhiều chương trình mạng (Web, Game, Chat\u0026hellip;), mỗi chương trình phải có một Port riêng.\nCác loại Port phổ biến Port 80: Dành cho Web (HTTP). Port 443: Dành cho Web bảo mật (HTTPS). Port 3306: Dành cho MySQL Database. Lỗi thường gặp: \u0026ldquo;Address already in use\u0026rdquo; Lỗi này xảy ra khi bạn cố mở Server ở một Port đang bị thằng khác chiếm dụng. =\u0026gt; Cách sửa: Đổi sang số khác, ví dụ đổi từ 8080 sang 9999.\n","permalink":"http://localhost:1313/blog/bai-viet-2/","summary":"Hiểu về khái niệm Port (Cổng) để tránh xung đột khi chạy phần mềm.","title":"Bài 2: Port là gì? Tại sao Server hay dùng cổng 8080?"},{"content":"Khi xử lý các tác vụ mạng (như gọi API), người mới học JS hay viết code lồng nhau kiểu này:\n1 2 3 4 5 6 7 8 9 10 // Cực hình Callback Hell getData(function(a) { getMoreData(a, function(b) { getMoreData(b, function(c) { getMoreData(c, function(d) { console.log(d); }); }); }); }); ","permalink":"http://localhost:1313/blog/bai-viet-3/","summary":"Viết code JS lồng nhau quá nhiều sẽ tạo ra thảm họa.","title":"Bài 3: Callback Hell trong JavaScript và cách né tránh"},{"content":"Để gửi một file ảnh từ Client lên Server, chúng ta không dùng BufferedReader được (vì nó đọc text), mà phải dùng dòng byte.\nCode phía Client (Gửi) 1 2 3 4 5 6 7 8 9 10 11 12 // Đọc file từ ổ cứng FileInputStream fis = new FileInputStream(\u0026#34;anh-meo.jpg\u0026#34;); // Lấy luồng gửi ra mạng OutputStream os = socket.getOutputStream(); byte[] buffer = new byte[4096]; int bytesRead; // Vừa đọc file vừa đẩy ra mạng while ((bytesRead = fis.read(buffer)) != -1) { os.write(buffer, 0, bytesRead); } ","permalink":"http://localhost:1313/blog/bai-viet-4/","summary":"Gửi text thì dễ, gửi file nhị phân (ảnh, nhạc) thì phải dùng FileInputStream.","title":"Bài 4: Hướng dẫn gửi File ảnh qua Socket trong Java"},{"content":"Vấn đề của HTTP HTTP hoạt động kiểu \u0026ldquo;Hỏi - Đáp\u0026rdquo;. Client hỏi thì Server mới trả lời. Nếu Client im lặng, Server cũng im. Điều này không làm Chat được vì tin nhắn phải đến ngay lập tức.\nGiải pháp: WebSocket WebSocket tạo ra một \u0026ldquo;đường ống\u0026rdquo; kết nối liên tục 2 chiều.\nServer có tin nhắn mới -\u0026gt; Bắn ngay về Client. Client không cần hỏi (Request) liên tục. Trong JS, khởi tạo rất dễ:\n1 2 3 4 5 6 7 8 9 10 11 12 // Kết nối đến Server const socket = new WebSocket(\u0026#39;ws://localhost:8080\u0026#39;); // Lắng nghe sự kiện khi có tin nhắn đến socket.onmessage = function(event) { console.log(\u0026#34;Có tin nhắn mới: \u0026#34; + event.data); }; // Gửi tin nhắn đi socket.onopen = function() { socket.send(\u0026#34;Hello Server, I am Trọng!\u0026#34;); }; ","permalink":"http://localhost:1313/blog/bai-viet-5/","summary":"Tại sao Facebook, Zalo lại dùng WebSocket thay vì HTTP thông thường?","title":"Bài 5: WebSocket - Công nghệ sau các ứng dụng Chat Realtime"},{"content":"Blocking IO (Java IO cổ điển) Khi chương trình chạy lệnh socket.accept() hoặc in.read(), nó sẽ DỪNG LẠI (Block) và chờ đợi.\nNếu mạng lag hoặc Client chưa gửi gì, chương trình sẽ đứng hình ở đó luôn. Hậu quả: Server chỉ phục vụ được 1 người tại 1 thời điểm (nếu không dùng đa luồng). Non-Blocking IO (Java NIO) Chương trình không bao giờ bị dừng. Nó sẽ kiểm tra liên tục:\n\u0026ldquo;Có dữ liệu không?\u0026rdquo; -\u0026gt; Nếu có: Xử lý ngay. -\u0026gt; Nếu không: Đi làm việc khác, lát quay lại kiểm tra tiếp. Kết luận: Muốn Server chịu tải cao (hàng ngàn user) như Zalo/Facebook thì bắt buộc phải dùng Non-Blocking.\n","permalink":"http://localhost:1313/blog/bai-viet-6/","summary":"Khái niệm quan trọng để tối ưu hiệu năng Server.","title":"Bài 6: Phân biệt Blocking IO và Non-Blocking IO"},{"content":"Khi nhận dữ liệu từ Java Server trả về (thường là dạng chuỗi String), JS cần biến nó thành Object để dùng.\n1. JSON.parse() Biến chuỗi thành Object.\n1 2 3 let dataString = \u0026#39;{\u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;Trọng\u0026#34;}\u0026#39;; let user = JSON.parse(dataString); console.log(user.name); // Kết quả: Trọng ","permalink":"http://localhost:1313/blog/bai-viet-7/","summary":"Hai hàm quan trọng nhất khi làm việc với API.","title":"Bài 7: Xử lý dữ liệu JSON trong JavaScript"},{"content":"Lập trình mạng rất rủi ro (dây cáp lỏng, wifi yếu\u0026hellip;). Nếu không bắt lỗi, chương trình sẽ tắt cái rụp ngay lập tức.\nLuôn luôn dùng khối try-catch-finally khi đụng tới Socket:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Socket socket = null; try { // Cố gắng kết nối socket = new Socket(\u0026#34;localhost\u0026#34;, 8080); System.out.println(\u0026#34;Kết nối thành công!\u0026#34;); } catch (IOException e) { // Nếu lỗi thì chạy vào đây System.out.println(\u0026#34;Lỗi kết nối: \u0026#34; + e.getMessage()); } finally { // Luôn luôn chạy vào đây để dọn dẹp try { if (socket != null) socket.close(); } catch (Exception ex) {} } ","permalink":"http://localhost:1313/blog/bai-viet-8/","summary":"Mạng rớt, Server sập\u0026hellip; làm sao để chương trình không bị Crash?","title":"Bài 8: Xử lý ngoại lệ (Exception) khi lập trình mạng"},{"content":"Nếu bạn chạy code Server cơ bản, khi Client A kết nối, Server sẽ bận nói chuyện với A. Lúc này Client B kết nối tới sẽ bị \u0026ldquo;quay đều\u0026rdquo; (treo) cho đến khi A thoát ra. =\u0026gt; Để khắc phục, ta phải dùng Thread (Luồng).\nMô hình Server Đa luồng Tưởng tượng Server là một ông chủ quán (Main Thread):\nÔng chủ đứng ở cửa (socket.accept()). Khách A tới =\u0026gt; Ông chủ thuê nhân viên 1 ra tiếp A. Ông chủ quay lại cửa đứng chờ tiếp. Khách B tới =\u0026gt; Ông chủ thuê nhân viên 2 ra tiếp B. Code minh họa (Java) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 while (true) { // 1. Chờ khách tới (Main Thread bị block ở đây) Socket clientSocket = serverSocket.accept(); // 2. Có khách! Tạo một luồng riêng (Nhân viên) để xử lý Thread t = new Thread(new Runnable() { @Override public void run() { xuLyCongViec(clientSocket); // Nhân viên làm việc ở đây } }); // 3. Đẩy nhân viên ra làm việc, ông chủ quay lại vòng lặp chờ khách mới t.start(); } ","permalink":"http://localhost:1313/blog/bai-viet-9/","summary":"Nếu không có Đa luồng, Server của bạn chỉ phục vụ được đúng 1 người, người thứ 2 sẽ bị treo. Tại sao?","title":"Bài 9: Đa luồng (Multithreading) - Cách để Server tiếp 100 khách cùng lúc"},{"content":" Đồ án môn Lập trình mạng là cơ hội để sinh viên vận dụng các kiến thức lý thuyết vào thực tế, cụ thể là việc xây dựng và quản lý một hệ thống website tĩnh kết hợp với việc nghiên cứu sâu về các giao thức mạng. Bài viết này nhằm tổng kết lại toàn bộ quá trình thực hiện đồ án.\n1. Kết quả đạt được Sau thời gian nghiên cứu và thực hiện, đồ án đã hoàn thành các mục tiêu đề ra ban đầu:\nXây dựng thành công Website cá nhân: Sử dụng Hugo (Static Site Generator) và triển khai ổn định trên nền tảng Github Pages. Hệ thống bài viết chuyên môn: Hoàn thành 09 bài viết đi sâu vào các kỹ thuật cốt lõi của môn học như Java Socket, Multithreading (Đa luồng), và xử lý bất đồng bộ trong JavaScript. Làm chủ công cụ quản lý mã nguồn: Áp dụng quy trình Git Flow cơ bản để quản lý phiên bản (Version Control) và cập nhật nội dung. 2. Kiến thức và Kinh nghiệm thực tiễn Quá trình thực hiện đồ án đã giúp củng cố nhiều kiến thức quan trọng:\nSự khác biệt giữa Lý thuyết và Thực tế: Việc triển khai Socket trong môi trường thực tế phát sinh nhiều vấn đề không có trong lý thuyết như độ trễ mạng (latency), quản lý tài nguyên bộ nhớ và xử lý ngắt kết nối đột ngột. Kỹ năng Debugging và Troubleshooting: Nâng cao khả năng đọc hiểu Log lỗi, sử dụng Stack Trace để truy vết nguyên nhân sự cố trong cả môi trường Java và JavaScript. Tối ưu hóa Code: Hiểu rõ tầm quan trọng của việc viết code sạch (Clean Code) và tuân thủ các quy tắc định dạng để thuận tiện cho việc bảo trì sau này. 3. Lời cảm ơn Em xin gửi lời cảm ơn chân thành đến Giảng viên hướng dẫn bộ môn Lập trình mạng - Trường Đại học Công nghệ TP.HCM (HUTECH) đã tận tình giảng dạy và định hướng đề tài, giúp sinh viên tiếp cận với các công nghệ hiện đại.\nĐồng thời, xin cảm ơn các bạn trong lớp đã cùng trao đổi, hỗ trợ nhau giải quyết các vấn đề kỹ thuật trong suốt quá trình làm bài. Sinh viên thực hiện: Lê Quốc Trọng Khoa: Công nghệ thông tin - HUTECH\n","permalink":"http://localhost:1313/blog/bai-viet-10/","summary":"Báo cáo tổng kết quá trình thực hiện, các kết quả đạt được và kiến thức tích lũy từ đồ án xây dựng Blog cá nhân.","title":"Bài 10: Tổng kết và Đánh giá kết quả Đồ án môn Lập trình mạng"},{"content":"Mình là Nhật Duy, sinh viên HUTECH. Blog này chia sẻ các bài học về lập trình mạng (TCP/UDP/Socket/RMI/HTTP) và các khóa học Java \u0026amp; JavaScript bằng tiếng Việt.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eMình là Nhật Duy, sinh viên HUTECH. Blog này chia sẻ các bài học về \u003cstrong\u003elập trình mạng\u003c/strong\u003e\n(TCP/UDP/Socket/RMI/HTTP) và các khóa học \u003cstrong\u003eJava \u0026amp; JavaScript\u003c/strong\u003e bằng tiếng Việt.\u003c/p\u003e","title":"Giới thiệu"}]