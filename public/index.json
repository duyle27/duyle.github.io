[{"content":"Trong lập trình mạng, trước khi kết nối, ta phải biết \u0026ldquo;địa chỉ nhà\u0026rdquo; (IP) của mình và đối phương. Java cung cấp class\nHình 1.1: Hiệu ứng Dunning–Kruger – mức độ tự tin thay đổi theo kinh nghiệm học tập\nGóc nhìn học tập: Hiệu ứng Dunning–Kruger InetAddress để làm việc này.\nĐịa chỉ IP là gì trong lập trình mạng? IP (Internet Protocol Address) là địa chỉ định danh của một thiết bị khi tham gia vào mạng máy tính.\nTrong lập trình mạng, IP đóng vai trò quan trọng trong việc:\nXác định máy gửi và máy nhận Định tuyến dữ liệu trong quá trình truyền thông Thiết lập kết nối giữa các tiến trình chạy trên những máy khác nhau Nếu không có địa chỉ IP, các máy tính sẽ không thể nhận biết và giao tiếp với nhau.\nVai trò của lớp InetAddress trong Java Lớp InetAddress đại diện cho một địa chỉ IP trong Java.\nThông qua lớp này, lập trình viên có thể:\nLấy địa chỉ IP của máy đang chạy chương trình Lấy tên máy (hostname) Phân giải tên miền sang địa chỉ IP Chuẩn bị thông tin để tạo Socket hoặc ServerSocket Hầu hết các chương trình lập trình mạng trong Java đều sử dụng InetAddress ở bước khởi tạo.\nPhân tích ý nghĩa các lệnh trong chương trình InetAddress.getLocalHost()\n→ Trả về đối tượng đại diện cho máy cục bộ (localhost).\ngetHostName()\n→ Lấy tên máy do hệ điều hành hoặc mạng gán.\ngetHostAddress()\n→ Lấy địa chỉ IP của máy dưới dạng chuỗi.\nViệc in ra hostname và IP giúp:\nKiểm tra cấu hình mạng Xác định đúng máy khi kết nối Client – Server Debug lỗi mạng Một số lưu ý khi lấy IP trong Java Khi máy không kết nối mạng, IP có thể là 127.0.0.1 Khi máy có nhiều card mạng (WiFi, LAN, VPN), IP trả về có thể không phải IP Internet Trên Server, hostname và IP thường khác máy cá nhân Ứng dụng thực tế Việc xác định IP của máy thường được sử dụng trong:\nChương trình Client – Server Thông báo IP Server cho Client kết nối Kiểm tra kết nối mạng LAN Ghi log và giám sát hệ thống Kết luận Qua bài học này, ta đã:\nHiểu vai trò của địa chỉ IP trong lập trình mạng Biết cách lấy IP bằng lớp InetAddress Chuẩn bị nền tảng cho các kỹ thuật TCP, UDP và RMI Liên hệ với học phần Lập trình Mạng máy tính Bài học này nằm trong nội dung mở đầu của học phần Lập trình Mạng máy tính (CMP180) tại Trường Đại học Công nghệ TP.HCM (HUTECH).\nTrong lộ trình môn học, sinh viên sẽ lần lượt tiếp cận các nội dung:\nKiến thức nền tảng về mạng và lập trình mạng Quản lý luồng nhập xuất (I/O) Quản lý địa chỉ và kết nối mạng Lập trình Socket TCP và UDP Xử lý đa tuyến, đa luồng Multicast UDP và Java RMI Thực hiện đồ án học phần cá nhân Mục tiêu của bài học Thông qua Bài 1, sinh viên sẽ:\nLàm quen với môi trường lập trình mạng bằng Java Hiểu được vai trò của địa chỉ IP trong giao tiếp mạng Biết cách sử dụng lớp InetAddress để lấy IP và hostname Chuẩn bị nền tảng cho các bài học tiếp theo về Socket và Server – Client ","permalink":"http://localhost:1313/blog/bai-viet-1/","summary":"GIỚI THIỆU HỌC PHẦN.","title":"Bài 1: Tổng quan khoá học"},{"content":"Trong lập trình mạng, nếu IP được xem như địa chỉ nhà của một máy tính trong mạng,\nthì Port (cổng) chính là số hiệu dùng để xác định chương trình hoặc dịch vụ cụ thể đang chạy trên máy đó.\nMột máy tính có thể chạy đồng thời nhiều ứng dụng mạng như Web Server, Database Server, Game Server hoặc Chat Server.\nMỗi ứng dụng bắt buộc phải gắn với một Port riêng để hệ điều hành có thể phân biệt và định tuyến dữ liệu chính xác.\nPort nằm ở đâu trong mô hình TCP/IP? Trong bộ giao thức TCP/IP, Port thuộc về Transport Layer (Tầng giao vận) và được sử dụng bởi hai giao thức chính là TCP và UDP.\nĐịa chỉ IP xác định máy nào sẽ nhận dữ liệu Port xác định ứng dụng nào trên máy đó sẽ xử lý dữ liệu Sự kết hợp giữa IP + Port tạo thành một Socket, là điểm cuối (endpoint) của quá trình giao tiếp mạng.\nCác loại Port phổ biến Port được đánh số từ 0 đến 65535 và được chia thành ba nhóm chính:\nInternet và các End Devices Trước khi tìm hiểu về Port, cần hiểu Internet được cấu thành từ hàng tỷ thiết bị đầu cuối (End Devices) như máy tính, điện thoại, máy chủ và các thiết bị IoT.\nCác thiết bị này kết nối với nhau thông qua nhiều lớp mạng khác nhau, và mỗi thiết bị khi tham gia giao tiếp mạng đều cần có địa chỉ IP và Port để định danh. Hình 2.1: Sơ đồ minh họa Internet và các thiết bị đầu cuối (End Devices) kết nối thông qua các mạng truy cập và mạng lõi.\nTrong quá trình giao tiếp mạng, một thiết bị không chỉ cần địa chỉ IP để xác định vị trí trong mạng, mà còn cần Port để xác định chính xác ứng dụng hoặc dịch vụ đang lắng nghe trên thiết bị đó.\nDo đó, Port đóng vai trò như “điểm tiếp nhận” (endpoint) cho các tiến trình mạng chạy trên cùng một máy.\nMô hình các tầng giao thức TCP/IP Để hiểu rõ Port hoạt động ở đâu và vì sao Server cần Port, ta cần nắm được mô hình giao thức TCP/IP – nền tảng của mọi ứng dụng mạng hiện nay.\nHình 2.2: Mô hình các tầng giao thức TCP/IP và các giao thức tiêu biểu tương ứng với từng tầng.\nTrong mô hình TCP/IP, địa chỉ IP hoạt động ở tầng Internet, giúp xác định thiết bị trong mạng.\nTrong khi đó, Port hoạt động ở tầng Transport (TCP/UDP), giúp xác định chính xác ứng dụng hoặc dịch vụ đang giao tiếp trên thiết bị đó.\nWell-known Ports (0 – 1023) Được dùng cho các dịch vụ chuẩn:\nPort 80: HTTP Port 443: HTTPS Port 21: FTP Port 25: SMTP Registered Ports (1024 – 49151) Thường dùng cho các ứng dụng phổ biến:\nPort 3306: MySQL Port 8080: Web Server thay thế port 80 Dynamic / Private Ports (49152 – 65535) Do hệ điều hành cấp phát tạm thời cho Client khi giao tiếp mạng.\nVì sao Server thường dùng cổng 8080? Cổng 8080 rất phổ biến trong quá trình phát triển và học tập vì:\nTránh xung đột với cổng 80 đang được hệ điều hành chiếm dụng Không cần quyền Administrator khi mở Server Phù hợp cho các Web Server thử nghiệm như: Apache Tomcat Spring Boot Node.js Lỗi thường gặp: “Address already in use” Lỗi này xảy ra khi Server cố gắng mở một Port đã bị chương trình khác chiếm dụng.\nNguyên nhân phổ biến:\nServer cũ chưa được tắt Port đang được dùng bởi dịch vụ khác Chạy nhiều Server cùng lúc Cách khắc phục:\nĐổi sang Port khác (ví dụ: 8080 → 9090) Kiểm tra Port đang sử dụng trong hệ điều hành Đảm bảo chỉ có một Server chạy tại một thời điểm Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), khái niệm Port sẽ được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Xây dựng mô hình Client – Server Java RMI và Multicast Việc hiểu rõ Port là nền tảng bắt buộc trước khi triển khai các ứng dụng mạng thực tế.\nKết luận Qua bài học này, ta đã:\nHiểu được Port là gì và vai trò của Port trong lập trình mạng Nắm được mối quan hệ giữa IP, Port và Socket Giải thích được lý do Server thường sử dụng cổng 8080 Chuẩn bị kiến thức nền cho các bài học tiếp theo về TCP và UDP ","permalink":"http://localhost:1313/blog/bai-viet-2/","summary":"MẠNG MÁY TÍNH \u0026amp; INTERNET.","title":"Bài 2: Kiến thức nền tảng?"},{"content":"Trong lập trình Java, luồng nhập xuất (Input / Output Streams) đóng vai trò trung gian giúp chương trình đọc và ghi dữ liệu từ nhiều nguồn khác nhau như bàn phím, file, console, bộ nhớ và sau này là socket mạng.\nHiểu rõ cơ chế luồng nhập xuất là bước nền bắt buộc trước khi đi vào lập trình Socket TCP, UDP hay Java RMI.\nLuồng (Stream) là gì? Luồng (Stream) là dòng dữ liệu di chuyển\ntừ nguồn → chương trình hoặc từ chương trình → đích.\nKhi Java đọc hoặc ghi dữ liệu, dữ liệu không đi trực tiếp mà luôn được đóng gói và truyền qua luồng.\nLuồng nhập xuất là gì? Luồng nhập xuất là cơ chế cho phép chương trình:\nNhận dữ liệu từ bên ngoài (Input) Ghi dữ liệu ra bên ngoài (Output) Luồng có thể kết nối với nhiều nguồn và đích khác nhau:\nFile Bàn phím Màn hình (console) Bộ nhớ Kết nối mạng (TCP / UDP) Dữ liệu trong luồng tồn tại dưới những dạng nào? Trong Java, dữ liệu trong luồng tồn tại dưới hai dạng chính:\nLuồng byte Luồng ký tự Việc chọn đúng loại luồng ảnh hưởng trực tiếp đến hiệu năng và tính chính xác của chương trình.\nLuồng byte trong Java Đặc điểm Dữ liệu được xử lý dưới dạng nhị phân Phù hợp với: File nhị phân Ảnh, video Socket mạng Dữ liệu phức tạp Các lớp gốc InputStream – luồng đọc byte OutputStream – luồng ghi byte Cả hai đều là lớp trừu tượng (abstract).\nCác luồng byte đọc phổ biến FileInputStream – đọc byte từ file ByteArrayInputStream – đọc từ mảng byte PipedInputStream – đọc từ luồng pipe Các luồng byte ghi phổ biến FileOutputStream – ghi byte vào file ByteArrayOutputStream – ghi vào mảng byte PipedOutputStream – ghi vào luồng pipe Mô hình đọc/ghi dữ liệu với Stream Quy trình chung khi làm việc với luồng:\nTạo đối tượng Stream Gắn Stream với nguồn hoặc đích Đọc/ghi dữ liệu trong vòng lặp Đóng Stream sau khi hoàn tất Luồng ký tự trong Java Đặc điểm Xử lý dữ liệu dạng Unicode Phù hợp với: File văn bản Chuỗi Dữ liệu hiển thị cho người dùng Các lớp gốc Reader – luồng đọc ký tự Writer – luồng ghi ký tự Các luồng ký tự đọc phổ biến FileReader – đọc file văn bản BufferedReader – đọc có bộ đệm StringReader – đọc chuỗi CharArrayReader – đọc mảng ký tự Các luồng ký tự ghi phổ biến FileWriter – ghi vào file văn bản BufferedWriter – ghi có bộ đệm PrintWriter – ghi dữ liệu dạng dễ đọc StringWriter – ghi chuỗi Luồng lọc dữ liệu (Filtered Streams) Luồng lọc dùng để chuyển đổi dữ liệu từ dạng byte/ký tự sang các kiểu dữ liệu khác.\nCác luồng lọc phổ biến DataInputStream DataOutputStream Cho phép đọc/ghi các kiểu dữ liệu nguyên thủy:\nint float double boolean char Đây là cầu nối giữa luồng thô và dữ liệu có kiểu trong Java.\nLưu trạng thái đối tượng – Serialization Serialization là gì? Serialization (chuỗi hóa) là quá trình chuyển đối tượng Java thành luồng byte để:\nLưu vào file Truyền qua mạng Phục hồi lại sau này Deserialization Ngược lại, Deserialization (giải chuỗi) là quá trình:\nĐọc byte Tái tạo lại đối tượng ban đầu Đây là nền tảng cho:\nLưu dữ liệu chương trình Java RMI Truyền object qua mạng Try-with-resources (TWR) Java hỗ trợ Try-with-resources để:\nTự động đóng stream Tránh rò rỉ tài nguyên Code gọn và an toàn hơn So với try-catch truyền thống, TWR:\nÍt lỗi hơn Dễ bảo trì hơn Được khuyến khích sử dụng Các lỗi I/O thường gặp Khi làm việc với luồng, một số exception phổ biến là:\nFileNotFoundException IOException EOFException UnsupportedEncodingException FileAlreadyExistsException AccessDeniedException SocketException MalformedURLException SerializationException InvalidPathException Việc bắt và xử lý exception đúng cách là yêu cầu bắt buộc trong lập trình Java.\nLiên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), luồng nhập xuất được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Truyền dữ liệu Client – Server Java RMI Multicast UDP Không hiểu I/O Stream → không thể làm mạng đúng cách.\nKết luận Qua bài học này, ta đã:\nHiểu khái niệm luồng nhập xuất trong Java Phân biệt luồng byte và luồng ký tự Nắm được cách đọc/ghi dữ liệu với Stream Biết vai trò của Serialization và Filtered Streams Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo Khi xử lý các tác vụ mạng (như gọi API), người mới học JS hay viết code lồng nhau kiểu này:\n1 2 3 4 5 6 7 8 9 10 // Cực hình Callback Hell getData(function(a) { getMoreData(a, function(b) { getMoreData(b, function(c) { getMoreData(c, function(d) { console.log(d); }); }); }); }); ","permalink":"http://localhost:1313/blog/bai-viet-3/","summary":"Tổng quan về Input/Output Streams trong Java – nền tảng cho xử lý file, console và lập trình mạng.","title":"Bài 3: Quản lý luồng nhập xuất trong Java"},{"content":"Trong lập trình mạng, trước khi chương trình có thể gửi hoặc nhận dữ liệu, điều quan trọng nhất là xác định đúng địa chỉ kết nối mạng. Nếu xác định sai địa chỉ, chương trình sẽ không thể giao tiếp, dù phần xử lý dữ liệu có đúng đến đâu.\nBài học này giúp bạn hiểu cách Java làm việc với địa chỉ IP, tên miền (DNS) và URL. Đây là nền tảng bắt buộc trước khi đi vào Socket TCP, UDP, Web Crawler và Java RMI.\nĐịa chỉ kết nối mạng là gì? Địa chỉ kết nối mạng là thông tin dùng để xác định máy nào trong mạng cần giao tiếp và dịch vụ nào trên máy đó sẽ xử lý dữ liệu.\nTrong Internet, địa chỉ kết nối thường bao gồm:\nĐịa chỉ IP Tên miền (Domain Name) Cổng (Port) Giao thức (Protocol) DNS – Domain Name System Con người dễ nhớ tên miền hơn các dãy số IP.\nDNS (Domain Name System) có nhiệm vụ ánh xạ tên miền sang địa chỉ IP, giúp client tìm đúng server cần kết nối.\nVí dụ:\ngoogle.com tương ứng với nhiều địa chỉ IP khác nhau www.cs.yale.edu tương ứng với 128.36.229.30 Nhờ DNS, người dùng không cần ghi nhớ địa chỉ IP khi truy cập Internet.\nĐịa chỉ IPv4 IPv4 là dạng địa chỉ phổ biến, gồm 32 bit, thường được viết thành bốn nhóm số.\nVí dụ:\n192.168.1.1 8.8.8.8 Một số dải địa chỉ đặc biệt:\n127.x.x.x là loopback (localhost) 224.0.0.0 – 239.255.255.255 là multicast Lớp InetAddress trong Java Java cung cấp lớp InetAddress để làm việc với địa chỉ IP và DNS.\nLớp này thường được dùng để:\nPhân giải tên miền sang IP Kiểm tra loại địa chỉ Kiểm tra khả năng kết nối mạng Ví dụ minh họa:\n1 InetAddress address = InetAddress.getByName(\u0026#34;google.com\u0026#34;); URL – Uniform Resource Locator URL được dùng để xác định tài nguyên trên Internet như trang web, file hoặc dịch vụ.\nMột URL đầy đủ thường bao gồm các thành phần sau:\nGiao thức (Protocol) Tên miền (Host) Cổng (Port) Đường dẫn (Path) Chuỗi truy vấn (Query) Ví dụ một URL đầy đủ: https://www.hutech.edu.vn/admission?id=123\nURL cho biết lấy dữ liệu ở đâu và bằng cách nào.\nLớp URL trong Java Lớp URL cho phép chương trình Java:\nPhân tích các thành phần của URL Kết nối tới server Đọc dữ liệu từ Internet Ví dụ minh họa:\n1 URL url = new URL(\u0026#34;https://www.example.com\u0026#34;); Ý nghĩa của việc quản lý địa chỉ kết nối mạng Hiểu rõ cách quản lý địa chỉ mạng giúp:\nTránh kết nối sai server Chuẩn bị đúng địa chỉ cho Socket TCP/UDP Hiểu cách Web Crawler hoạt động Nắm vững mô hình Client – Server Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm địa chỉ kết nối mạng Biết vai trò của DNS và IPv4 Nắm được cách Java làm việc với InetAddress Hiểu cấu trúc và vai trò của URL Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-4/","summary":"Tìm hiểu cách Java quản lý địa chỉ mạng thông qua InetAddress, URL, URLConnection và DNS.","title":"Bài 4: Quản lý địa chỉ kết nối mạng trong Java"},{"content":"Trong lập trình mạng, TCP Socket là cơ chế quan trọng nhất để xây dựng các ứng dụng Client – Server có độ tin cậy cao.\nBài học này giúp bạn hiểu TCP là gì, vì sao cần TCP, và cách Java triển khai TCP thông qua Socket và ServerSocket.\nĐây là bước chuyển tiếp trực tiếp từ kiến thức địa chỉ mạng (IP, DNS, URL) sang giao tiếp dữ liệu thực tế giữa các chương trình.\nTCP là gì? TCP (Transmission Control Protocol) là giao thức truyền thông hướng kết nối, đảm bảo dữ liệu được truyền:\nĐúng thứ tự Đầy đủ Không bị mất mát Không bị trùng lặp Trước khi truyền dữ liệu, TCP yêu cầu thiết lập kết nối giữa hai bên, và chỉ khi kết nối thành công thì dữ liệu mới được trao đổi.\nVì sao sử dụng TCP? TCP được sử dụng khi ứng dụng yêu cầu độ tin cậy cao, ví dụ:\nỨng dụng chat Ứng dụng client–server Truyền file Game online theo lượt Hệ thống ngân hàng, thương mại điện tử TCP cung cấp các cơ chế quan trọng:\nĐảm bảo dữ liệu: gói tin bị mất sẽ được gửi lại Kiểm soát lỗi: phát hiện và sửa lỗi trong quá trình truyền Kiểm soát luồng: tránh làm quá tải phía nhận Giao tiếp hai chiều: cho phép gửi và nhận dữ liệu đồng thời Cơ chế hoạt động của TCP Quá trình giao tiếp TCP gồm ba giai đoạn chính:\nThiết lập kết nối (Bắt tay 3 bước – Three-way Handshake) Truyền dữ liệu Giải phóng kết nối Nhờ cơ chế này, TCP đảm bảo rằng hai bên luôn sẵn sàng trước khi truyền và kết thúc an toàn sau khi hoàn tất.\nMô hình Client – Server Các ứng dụng TCP thường hoạt động theo mô hình Client – Server.\nServer:\nChạy trước Lắng nghe yêu cầu kết nối Cung cấp dịch vụ Trả kết quả cho client Client:\nChạy sau Chủ động kết nối tới server Gửi yêu cầu Nhận phản hồi từ server Quá trình giao tiếp gồm:\nClient gửi yêu cầu Server xử lý Server trả kết quả cho client Socket trong Java Trong Java, Socket đại diện cho điểm cuối giao tiếp giữa client và server khi sử dụng TCP.\nSocket cho phép:\nGửi dữ liệu tới server Nhận dữ liệu từ server Giao tiếp hai chiều thông qua luồng nhập/xuất Ví dụ minh họa tạo Socket phía client:\n1 Socket socket = new Socket(\u0026#34;localhost\u0026#34;, 8080); ServerSocket trong Java ServerSocket được sử dụng ở phía server để:\nMở một cổng lắng nghe Chờ client kết nối Chấp nhận kết nối và tạo Socket giao tiếp ServerSocket đóng vai trò như cửa ngõ, cho phép các client kết nối vào server.\nVí dụ minh họa:\n1 ServerSocket server = new ServerSocket(8080); Luồng dữ liệu trong TCP Socket Sau khi kết nối TCP được thiết lập, client và server trao đổi dữ liệu thông qua các luồng:\nInputStream: dùng để đọc dữ liệu từ socket OutputStream: dùng để ghi dữ liệu vào socket Luồng dữ liệu này hoạt động tương tự như I/O Stream đã học ở bài trước,\nnhưng nguồn và đích là mạng thay vì file hay bàn phím.\nVí dụ ứng dụng: Trò chơi Oẳn Tù Tì Một bài tập tiêu biểu sử dụng TCP Socket là trò chơi Oẳn Tù Tì theo mô hình Client – Server.\nĐặc điểm Server quản lý luật chơi và điểm số Hai client gửi lựa chọn (kéo – búa – bao) Server xác định kết quả và gửi lại cho client Dữ liệu được truyền qua TCP để đảm bảo chính xác Thông qua bài tập này, sinh viên hiểu rõ:\nCách thiết lập kết nối TCP Cách trao đổi dữ liệu giữa nhiều client Cách xử lý lỗi mạng và ngoại lệ Ý nghĩa của lập trình TCP Socket Việc nắm vững TCP Socket giúp bạn:\nHiểu bản chất giao tiếp mạng Xây dựng hệ thống Client – Server thực tế Chuẩn bị cho các bài nâng cao như: Đa tuyến (Multi-thread) Socket UDP Java RMI Ứng dụng mạng phân tán Kết luận Qua bài học này, bạn đã:\nHiểu TCP là gì và vì sao cần TCP Nắm được mô hình Client – Server Biết vai trò của Socket và ServerSocket trong Java Hiểu cách dữ liệu được truyền qua TCP Chuẩn bị nền tảng cho các bài học UDP và xử lý đồng thời tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-5/","summary":"Giải thích mô hình Client–Server và cách lập trình Socket TCP trong Java – nền tảng cho giao tiếp mạng tin cậy.","title":"Bài 5: Lập trình Socket TCP trong Java"},{"content":"#Trong lập trình mạng, không phải lúc nào ứng dụng cũng cần độ tin cậy tuyệt đối như TCP.\nTrong nhiều trường hợp, điều quan trọng hơn là tốc độ truyền nhanh và độ trễ thấp.\nBài học này giới thiệu UDP Socket – cơ chế truyền dữ liệu không kết nối, được sử dụng rộng rãi trong các ứng dụng thời gian thực.\nUDP là gì? UDP (User Datagram Protocol) là giao thức truyền thông không hướng kết nối.\nĐiều này có nghĩa là:\nKhông thiết lập kết nối trước khi truyền Không đảm bảo dữ liệu đến nơi Không đảm bảo thứ tự gói tin Không tự động gửi lại gói tin bị mất UDP gửi dữ liệu theo từng datagram (gói tin độc lập).\nSo sánh TCP và UDP TCP UDP Có kết nối Không kết nối Đảm bảo dữ liệu Không đảm bảo Truyền theo luồng Truyền theo gói Độ trễ cao hơn Độ trễ thấp Phù hợp dữ liệu quan trọng Phù hợp dữ liệu thời gian thực Khi nào sử dụng UDP? UDP được sử dụng khi:\nCần truyền nhanh Có thể chấp nhận mất gói tin Dữ liệu được gửi liên tục Ví dụ ứng dụng UDP:\nTruyền video, audio trực tuyến Game online thời gian thực Chat broadcast DNS Multicast, streaming UDP Socket trong Java Java hỗ trợ UDP thông qua hai lớp chính:\nDatagramSocket: quản lý socket UDP DatagramPacket: đại diện cho gói dữ liệu UDP UDP không phân biệt client hay server rõ ràng như TCP.\nMỗi chương trình chỉ cần một DatagramSocket để gửi và nhận dữ liệu.\nDatagramPacket là gì? DatagramPacket là gói dữ liệu UDP, bao gồm:\nDữ liệu cần gửi Địa chỉ IP đích Số hiệu cổng Mỗi lần gửi hoặc nhận dữ liệu, UDP làm việc với một DatagramPacket riêng biệt.\nLuồng dữ liệu trong UDP UDP không có luồng InputStream / OutputStream như TCP.\nQuy trình truyền dữ liệu UDP:\nTạo DatagramSocket Tạo DatagramPacket chứa dữ liệu Gửi packet đi Nhận packet về Đọc dữ liệu từ packet Mỗi gói tin là độc lập, không liên quan đến các gói khác.\nĐặc điểm quan trọng của UDP Không kiểm soát lỗi Không kiểm soát luồng Không bắt tay kết nối Gửi nhanh, xử lý đơn giản Phù hợp truyền broadcast và multicast Chính vì vậy, UDP thường được dùng khi tốc độ quan trọng hơn độ chính xác tuyệt đối.\nÝ nghĩa của lập trình Socket UDP Nắm vững UDP giúp bạn:\nHiểu bản chất truyền dữ liệu không kết nối Xây dựng ứng dụng thời gian thực Phân biệt rõ TCP và UDP trong thiết kế hệ thống Chuẩn bị cho các chủ đề nâng cao như: Multicast UDP Java RMI Hệ thống phân tán Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính, UDP được sử dụng trong:\nSocket UDP Multicast Ứng dụng truyền tin nhanh Game, streaming, broadcast Hiểu UDP giúp bạn chọn đúng giao thức cho từng bài toán thực tế.\nKết luận Qua bài học này, bạn đã:\nHiểu UDP là gì và cơ chế hoạt động Phân biệt được TCP và UDP Biết vai trò của DatagramSocket và DatagramPacket Hiểu cách truyền dữ liệu không kết nối Chuẩn bị nền tảng cho bài Multicast UDP \u0026amp; Java RMI tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-6/","summary":"Giải thích giao thức UDP và cách Java lập trình Socket UDP – nền tảng cho truyền dữ liệu nhanh, không kết nối.","title":"Bài 6: Lập trình Socket UDP trong Java"},{"content":"Trong các ứng dụng mạng thực tế, đặc biệt là Server, chương trình thường phải xử lý nhiều yêu cầu cùng lúc.\nNếu chỉ sử dụng một luồng thực thi, server sẽ bị tắc nghẽn, các client phải chờ đợi và hiệu năng giảm nghiêm trọng.\nVì vậy, lập trình đa tuyến (Multithreading) và xử lý đồng thời (Concurrency) là kỹ thuật bắt buộc trong lập trình mạng.\nTuyến (Thread) là gì? Thread là một dòng điều khiển tuần tự bên trong một chương trình.\nMột chương trình (process) có thể chứa nhiều thread Các thread có thể chạy đồng thời Mỗi thread thực hiện một nhiệm vụ riêng Thread không phải là một chương trình độc lập,\nnó luôn thuộc về một process.\nProcess và Thread Process:\nCó không gian bộ nhớ riêng Chạy độc lập với process khác Tạo và chuyển đổi tốn nhiều tài nguyên Thread:\nChia sẻ bộ nhớ với các thread khác trong cùng process Tạo nhanh hơn process Chuyển đổi nhanh hơn Nhờ thread, chương trình có thể thực hiện nhiều công việc cùng lúc trong cùng một ứng dụng.\nVì sao cần lập trình đa tuyến? Lập trình đa tuyến giúp:\nTăng hiệu suất và khả năng đáp ứng Tận dụng thời gian chờ đợi (I/O, mạng, tải file) Chia nhỏ tác vụ và xử lý đồng thời Cải thiện trải nghiệm người dùng Trong lập trình mạng, đa tuyến cho phép server phục vụ nhiều client cùng lúc.\nThực thi Thread trong Java Trong Java, một thread bắt đầu chạy khi gọi phương thức start().\nKhi thread chạy, JVM thực thi mã trong phương thức run() Khi run() kết thúc, thread cũng kết thúc Một thread không thể start lại, muốn chạy lại phải tạo thread mới Thread cần có điều kiện dừng rõ ràng để tránh chạy vô hạn.\nỨng dụng đa tuyến trong lập trình mạng Ứng dụng Chat đa tuyến Một ví dụ tiêu biểu của đa tuyến trong mạng là ứng dụng chat nhiều client – một server.\nĐặc điểm:\nServer chấp nhận nhiều client kết nối cùng lúc Mỗi client được xử lý bởi một thread riêng Tin nhắn từ một client được gửi tới tất cả client khác Server ghi lại nội dung chat vào file log Thông qua ví dụ này, sinh viên hiểu rõ:\nCách server xử lý nhiều kết nối đồng thời Cách phối hợp giữa socket và thread Vai trò của đa tuyến trong ứng dụng mạng Xử lý đồng thời (Concurrency) Xử lý đồng thời xảy ra khi nhiều thread:\nChạy cùng lúc Truy cập tài nguyên chung (biến, file, bộ nhớ) Nếu không kiểm soát tốt, chương trình có thể gặp các vấn đề nghiêm trọng.\nRace Condition Race Condition xảy ra khi:\nNhiều thread cùng truy cập và thay đổi dữ liệu chung Kết quả phụ thuộc vào thứ tự thực thi không xác định Điều này có thể dẫn đến:\nDữ liệu sai lệch Kết quả không nhất quán Lỗi khó phát hiện Đồng bộ hóa (Synchronization) Để tránh race condition, Java cung cấp cơ chế đồng bộ hóa:\nĐảm bảo chỉ một thread được truy cập tài nguyên tại một thời điểm Giữ cho dữ liệu luôn nhất quán Đồng bộ hóa là nền tảng để xây dựng các ứng dụng an toàn và ổn định khi chạy đa tuyến.\nCác vấn đề thường gặp trong xử lý đồng thời Một số vấn đề phổ biến:\nRace condition: tranh chấp dữ liệu Deadlock: các thread chờ nhau vô hạn Livelock: các thread liên tục phản ứng nhưng không tiến triển Starvation: thread không bao giờ được cấp tài nguyên Những vấn đề này khiến lập trình đa tuyến trở nên phức tạp và khó debug.\nLập lịch Thread trong Java Java sử dụng cơ chế lập lịch theo độ ưu tiên:\nMỗi thread có độ ưu tiên từ MIN_PRIORITY đến MAX_PRIORITY JVM chọn thread runnable có độ ưu tiên cao hơn để chạy Thread có thể nhường CPU cho thread khác bằng cách gọi yield() Việc hiểu cơ chế lập lịch giúp lập trình viên thiết kế thread hợp lý hơn.\nÝ nghĩa của lập trình đa tuyến và xử lý đồng thời Nắm vững kiến thức bài này giúp bạn:\nXây dựng server xử lý nhiều client Viết ứng dụng mạng hiệu năng cao Tránh lỗi tranh chấp dữ liệu Chuẩn bị cho các chủ đề nâng cao như: Server đa tuyến Pooling Threads Multicast UDP Java RMI Hệ thống phân tán Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm thread và multithreading Phân biệt process và thread Biết vai trò của đa tuyến trong lập trình mạng Hiểu các vấn đề xử lý đồng thời và race condition Chuẩn bị nền tảng cho các bài học nâng cao tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-7/","summary":"Giải thích lập trình đa tuyến và xử lý đồng thời trong Java – nền tảng cho các ứng dụng mạng nhiều client và hệ thống phân tán.","title":"Bài 7: Lập trình đa tuyến và xử lý đồng thời trong Java"},{"content":"Buổi 8 gồm 2 phần lớn:\nMulticast UDP: gửi dữ liệu từ một nguồn đến nhiều máy nhận cùng lúc (1 → N). Java RMI: gọi phương thức từ xa giữa các ứng dụng Java như gọi hàm bình thường (Remote Method Invocation). Đây là các kỹ thuật thường gặp trong streaming, trò chuyện nhóm, giám sát từ xa và hệ thống phân tán.\n1) UDP Multicast Unicast, Broadcast và Multicast Trong mạng máy tính có 3 kiểu gửi dữ liệu phổ biến:\nUnicast: 1 nguồn → 1 đích\nVí dụ: bạn mở một trang web, server trả dữ liệu cho riêng bạn.\nBroadcast: 1 nguồn → tất cả máy trong mạng nội bộ\nVí dụ: một thông báo phát cho toàn bộ LAN.\nMulticast: 1 nguồn → một nhóm máy đã đăng ký nhận dữ liệu\nVí dụ: server phát stream video cho nhóm người xem cùng lúc.\nMulticast là cách truyền hiệu quả khi nhiều máy cùng cần nhận một nội dung giống nhau.\nTại sao dùng UDP Multicast? UDP Multicast thường được dùng vì:\nHiệu suất cao: gửi 1 lần nhưng nhiều máy nhận → giảm tải mạng và server. Đơn giản, nhanh: UDP là kiểu “gửi và quên”, không phải chờ xác nhận. Tối ưu trong LAN: phù hợp môi trường mạng nội bộ (Local Area Network). Rất hợp streaming: audio/video cần tốc độ và độ trễ thấp hơn là đảm bảo tuyệt đối. Ứng dụng của Multicast Multicast có thể dùng trong:\nTruyền phát multimedia trực tiếp (audio/video streaming) Trò chuyện nhóm, hội thoại nhóm Quảng bá thông tin cấu hình mạng và cập nhật trong hệ thống mạng Game nhiều người chơi (gửi trạng thái game cho nhiều người) Phát thông tin trạng thái/cảnh báo cho nhiều thiết bị Phát tán cập nhật phần mềm trong mạng nội bộ Địa chỉ Multicast IPv4 Trong IPv4:\nClass D là dải địa chỉ dành cho multicast Dải địa chỉ multicast thường gặp: 224.0.0.0 – 239.255.255.255 Một số nhóm multicast hay được nhắc:\n224.0.0.1: tất cả host trong local subnet Multicast Group là gì? Multicast hoạt động theo “nhóm”:\nMột multicast group giống như một kênh. Máy nào muốn nhận dữ liệu phải tham gia nhóm (join group). Khi rời nhóm thì không nhận dữ liệu nữa. Multicast trong Java Java hỗ trợ multicast qua lớp:\njava.net.MulticastSocket (kế thừa từ DatagramSocket) Một số thao tác quan trọng:\njoinGroup(...): tham gia nhóm multicast leaveGroup(...): rời nhóm multicast setTimeToLive(ttl): đặt TTL (thời gian sống của gói tin, qua bao nhiêu router) Quy trình gửi dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket Tham gia nhóm multicast Tạo DatagramPacket chứa dữ liệu + địa chỉ nhóm + port Gửi packet Rời nhóm Ví dụ minh họa (ngắn, chỉ để hiểu):\n1 2 3 4 5 6 7 8 9 10 11 12 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(); socket.joinGroup(group); socket.setTimeToLive(5); byte[] data = \u0026#34;Hello Multicast\u0026#34;.getBytes(); DatagramPacket packet = new DatagramPacket(data, data.length, group, 9876); socket.send(packet); socket.leaveGroup(group); socket.close(); Quy trình nhận dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket lắng nghe trên port Tham gia nhóm multicast Tạo DatagramPacket rỗng để nhận dữ liệu Gọi receive() để chờ gói tin gửi về Đọc dữ liệu từ packet Rời nhóm và đóng socket Ví dụ minh họa (ngắn):\n1 2 3 4 5 6 7 8 9 10 11 12 13 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(9876); socket.joinGroup(group); byte[] buf = new byte[1024]; DatagramPacket packet = new DatagramPacket(buf, buf.length); socket.receive(packet); String msg = new String(packet.getData(), 0, packet.getLength()); System.out.println(\u0026#34;Received: \u0026#34; + msg); socket.leaveGroup(group); socket.close(); 2) Java RMI Java RMI là gì? RMI (Remote Method Invocation) cho phép chương trình Java:\nGọi phương thức của một đối tượng nằm trên máy khác Cảm giác giống như gọi method trong cùng chương trình Nói đơn giản:\nClient gọi: remoteObject.sum(1,2) Server thực thi thật và trả kết quả về cho client RMI giúp che giấu toàn bộ chi tiết mạng phía sau, người lập trình chỉ tập trung vào logic.\nVì sao dùng Java RMI? Java RMI được sử dụng vì:\nTích hợp sẵn trong Java, dễ triển khai nếu cả client và server đều dùng Java Gọi phương thức từ xa đơn giản như gọi hàm thông thường Hỗ trợ dữ liệu phức tạp: đối tượng, mảng, class tự định nghĩa Tự động xử lý giao tiếp mạng thông qua cơ chế stub / skeleton Dựa trên TCP/IP nên tương đối ổn định và tin cậy Hạn chế của Java RMI Một số điểm hạn chế cần lưu ý:\nPhụ thuộc Java: chủ yếu phù hợp Java ↔ Java Thiết kế dịch vụ phức tạp vẫn cần tổ chức tốt (đặc biệt khi dùng callback) Quản lý phiên và kết nối không mạnh như các giải pháp hiện đại Bảo mật cần cấu hình cẩn thận trong môi trường thực tế Ý tưởng kiến trúc RMI (hiểu nhanh) Trong Java RMI có các thành phần chính:\nRemote Interface\nKhai báo các phương thức cho phép gọi từ xa\nServer Implementation\nLớp cài đặt interface, chứa logic xử lý thật\nRMI Registry\nNơi đăng ký service để client tìm thấy server\nClient\nTìm (lookup) service trong registry và gọi phương thức\nCác bước triển khai RMI (tóm tắt) Định nghĩa Remote Interface Cài đặt interface bằng một class server (remote object) Viết chương trình server: tạo object và bind vào registry Viết chương trình client: lookup registry và gọi method Chạy RMI registry, chạy server, sau đó chạy client Ví dụ ứng dụng RMI Một số ví dụ thường gặp:\nTính tổng 2 số từ xa Dịch vụ quản lý tài khoản ATM Dịch vụ giám sát nhiệt độ có callback (server gọi ngược lại client) Bài tập gợi ý theo đúng nội dung buổi 8 BT8.01: Mô phỏng streaming video\n(1 server phát, nhiều client nhận dữ liệu)\nBT8.02: Server quản lý tài khoản ATM bằng RMI\n(thêm user, đăng nhập, gửi/rút tiền, lưu lịch sử giao dịch)\nKết luận Qua bài học này, bạn đã:\nHiểu sự khác nhau giữa Unicast, Broadcast và Multicast Nắm được vì sao Multicast UDP phù hợp cho truyền dữ liệu nhóm và streaming Biết cách Java hỗ trợ multicast qua MulticastSocket Hiểu Java RMI và cơ chế gọi phương thức từ xa Chuẩn bị nền tảng cho các bài ứng dụng mạng phân tán và đồ án học phần ","permalink":"http://localhost:1313/blog/bai-viet-8/","summary":"Giải thích Multicast UDP (gửi 1-n) và Java RMI (gọi phương thức từ xa) – nền tảng cho ứng dụng nhóm và hệ phân tán.","title":"Bài 8: Multicast UDP và Java RMI"},{"content":"Sau khi hoàn thành các bài về TCP, UDP, đa tuyến và xử lý đồng thời,\nchúng ta đã có đủ nền tảng để xây dựng một ứng dụng mạng hoàn chỉnh.\nBài học này giúp bạn xâu chuỗi toàn bộ kiến thức đã học,\nhiểu rõ mỗi công nghệ dùng trong trường hợp nào,\nvà cách thiết kế một hệ thống mạng đúng tư duy kỹ sư.\nNhìn lại các mô hình giao tiếp mạng đã học Trong lập trình mạng, các ứng dụng thường được xây dựng dựa trên mô hình Client – Server.\nClient: gửi yêu cầu, nhập dữ liệu, hiển thị kết quả Server: xử lý logic, quản lý dữ liệu, trả kết quả Tùy bài toán, ta lựa chọn giao thức và mô hình phù hợp.\nSo sánh TCP, UDP và Multicast TCP – Giao tiếp tin cậy TCP phù hợp khi:\nCần đảm bảo dữ liệu đúng và đủ Cần kết nối ổn định, hai chiều Ví dụ: chat, truyền file, game theo lượt, hệ thống ngân hàng Đặc trưng:\nCó bắt tay 3 bước Có kiểm soát lỗi, kiểm soát luồng Tốn tài nguyên hơn UDP UDP – Giao tiếp nhanh, không kết nối UDP phù hợp khi:\nƯu tiên tốc độ Chấp nhận mất gói Ví dụ: game thời gian thực, streaming, cảm biến Đặc trưng:\nKhông kết nối Không đảm bảo thứ tự Ít độ trễ UDP Multicast – Truyền dữ liệu nhóm Multicast được dùng khi:\nMột nguồn → nhiều người nhận Dữ liệu giống nhau cho tất cả client Ví dụ: livestream, thông báo hệ thống, truyền trạng thái Ưu điểm:\nGiảm tải server Tiết kiệm băng thông Phù hợp mạng LAN Vai trò của đa tuyến (Multithreading) Trong thực tế, server không thể xử lý từng client một cách tuần tự.\nĐa tuyến giúp:\nNhiều client kết nối cùng lúc Không client nào bị “đóng băng” Tăng khả năng mở rộng hệ thống Ví dụ:\nServer chat: mỗi client là một thread Server TCP: mỗi socket được xử lý riêng Thiết kế một ứng dụng mạng hoàn chỉnh Khi thiết kế, cần xác định rõ:\nGiao thức: TCP hay UDP? Mô hình: 1–1, 1–n, n–n? Đồng thời hay tuần tự? Client gửi gì? Server xử lý gì? Một thiết kế tốt luôn:\nPhân tách rõ giao tiếp – xử lý – dữ liệu Dễ mở rộng Dễ bảo trì Liên hệ với đồ án học phần Các đồ án như:\nChat đa tuyến Oẳn Tù Tì client–server Streaming UDP Dịch vụ RMI Đều là sự kết hợp của các kiến thức đã học,\nkhông phải nội dung mới.\nKết luận Qua bài học này, bạn đã:\nHệ thống lại toàn bộ kiến thức lập trình mạng Hiểu rõ khi nào dùng TCP, UDP, Multicast Nắm được vai trò của đa tuyến Biết cách tư duy thiết kế một ứng dụng mạng hoàn chỉnh Đây là bước chuẩn bị quan trọng trước khi vận dụng toàn bộ kiến thức vào một hệ thống thực tế.\n","permalink":"http://localhost:1313/blog/bai-viet-9/","summary":"Tổng hợp kiến thức TCP, UDP, đa tuyến và cách thiết kế ứng dụng mạng Client–Server hoàn chỉnh.","title":"Bài 9: Tổng hợp kiến thức \u0026 thiết kế ứng dụng mạng"},{"content":"Bài cuối cùng của học phần không nhằm giới thiệu công nghệ mới,\nmà tập trung vào cách vận dụng kiến thức đã học vào thực tế.\nĐây là giai đoạn chuyển từ:\n“Biết dùng” → “Biết thiết kế” → “Biết đánh giá hệ thống”\nTư duy vận dụng kiến thức Một ứng dụng mạng hoàn chỉnh cần trả lời được các câu hỏi:\nVì sao chọn TCP mà không phải UDP? Vì sao cần đa tuyến? Server có chịu được nhiều client không? Hệ thống có mở rộng được không? Đây chính là tư duy kỹ sư, không phải chỉ “chạy được là xong”.\nĐánh giá một ứng dụng mạng Khi hoàn thiện hệ thống, cần xem xét:\n1. Tính đúng đắn Dữ liệu có truyền đúng không? Có mất gói không? Có xử lý lỗi không? 2. Tính đồng thời Nhiều client có dùng chung được không? Có bị treo server không? Có race condition không? 3. Hiệu năng Độ trễ thế nào? Server có bị quá tải không? Có tách luồng hợp lý không? Liên hệ với các mô hình phân tán Các hệ thống đã học là nền tảng cho:\nHệ thống client–server lớn Ứng dụng phân tán Microservices Cloud services Java RMI, TCP đa tuyến hay UDP Multicast\nđều là những viên gạch đầu tiên.\nTừ học phần đến thực tế Sau học phần này, bạn có thể tiếp cận:\nWebSocket REST API gRPC Message Queue (Kafka, RabbitMQ) Hệ thống realtime Tư duy lập trình mạng không thay đổi, chỉ công nghệ thay đổi.\nTổng kết toàn bộ học phần Qua toàn bộ chuỗi bài, bạn đã:\nHiểu cách dữ liệu đi qua mạng Làm việc với TCP, UDP, Multicast Xử lý đa tuyến và đồng thời Tiếp cận lập trình phân tán với RMI Có tư duy thiết kế hệ thống mạng Lời kết Lập trình mạng không chỉ là code socket,\nmà là hiểu cách các hệ thống nói chuyện với nhau.\nNếu bạn hiểu được điều đó,\nbạn đã vượt xa mức “học để qua môn”.\n","permalink":"http://localhost:1313/blog/bai-viet-10/","summary":"Vận dụng toàn bộ kiến thức lập trình mạng để xây dựng, đánh giá và hoàn thiện một ứng dụng thực tế.","title":"Bài 10: Hoàn thiện \u0026 vận dụng lập trình mạng"},{"content":"Lời mở đầu Có những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\nMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\nHọc tập Những năm đại học trôi qua nhanh hơn mình từng nghĩ. Ngày mới bước chân vào giảng đường, mình vẫn còn khá mơ hồ về ngành học, về tương lai, về chính bản thân mình sẽ trở thành ai sau bốn năm. Nhưng rồi từng môn học, từng bài tập nhóm, từng đồ án kéo mình lại gần hơn với cách một hệ thống được hình thành và vận hành.\nHệ thống thông tin không chỉ là lập trình, cũng không đơn thuần là công nghệ. Đó là câu chuyện về con người, quy trình và dữ liệu. Mình học cách đặt câu hỏi, học cách lắng nghe yêu cầu, học cách vẽ ra những sơ đồ tưởng chừng khô khan nhưng lại chứa rất nhiều suy nghĩ phía sau. Dần dần, mình nhận ra mình thích phần “hiểu vấn đề” hơn là chỉ chăm chăm vào lời giải.\nĐịnh hướng Ở thời điểm hiện tại, mình đang định hướng theo con đường Business Analyst (BA). Mình hứng thú với vai trò đứng giữa – không quá xa kỹ thuật, cũng không tách rời nghiệp vụ. Đó là nơi cần sự rõ ràng trong tư duy, sự kiên nhẫn trong giao tiếp và khả năng chuyển hóa những điều mơ hồ thành thứ có thể triển khai được.\nMình không nghĩ BA là một vị trí “nhẹ nhàng” hay “an toàn”. Ngược lại, đó là công việc đòi hỏi phải học rất nhiều, sai rất nhiều và sửa rất nhiều. Nhưng chính điều đó khiến mình thấy phù hợp. Mình muốn hiểu hệ thống trước khi xây dựng nó, muốn biết vì sao người ta see cần một chức năng, chứ không chỉ là nó được viết như thế nào.\nBlog Blog này ra đời khá tự nhiên, giống như một cuốn sổ mở rộng hơn là một trang thể hiện điều gì đó to tát. Mình viết để nhớ, để hệ thống lại những gì đã học, và đôi khi là để sắp xếp lại suy nghĩ của chính mình.\nỞ đây có thể là kiến thức về Hệ thống thông tin, về phân tích nghiệp vụ, về lập trình, hoặc đơn giản là những trải nghiệm học tập và va chạm trong quá trình làm đồ án, làm việc nhóm, và chuẩn bị bước ra môi trường thực tế. Mình không mong mọi thứ phải hoàn hảo, chỉ mong nó thật và có ích cho ai đó đang đi trên con đường tương tự.\nLời kết Mình đang ở một giai đoạn chưa thể gọi là trưởng thành, nhưng cũng không còn quá non nớt. Vẫn đang học, vẫn đang thử, vẫn đang sai và sửa mỗi ngày. Nếu có một điều mình mong giữ được lâu nhất, thì đó là sự tò mò và tinh thần học hỏi – những thứ giúp mình không đứng yên giữa rất nhiều lựa chọn ngoài kia.\nCảm ơn bạn đã ghé qua và đọc những dòng này. Hy vọng ở một thời điểm nào đó, những chia sẻ nhỏ ở đây sẽ chạm đến bạn – dù chỉ là một chút. \u0026ldquo;Học để chia sẻ, chia sẻ để học nhiều hơn.\u0026rdquo;\nLiên hệ Nếu bạn muốn gửi cho mình vài dòng trao đổi,\nbạn có thể liên hệ với mình qua Email hoặc GitHub ,Facebook dưới đây.\nCảm ơn bạn đã ghé thăm blog! ","permalink":"http://localhost:1313/about/","summary":"\u003ch2 id=\"lời-mở-đầu\"\u003eLời mở đầu\u003c/h2\u003e\n\u003cp\u003eCó những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\u003c/p\u003e\n\u003cp\u003eMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\u003c/p\u003e","title":"Giới thiệu"},{"content":"Trong lập trình mạng, trước khi kết nối, ta phải biết \u0026ldquo;địa chỉ nhà\u0026rdquo; (IP) của mình và đối phương. Java cung cấp class\nHình 1.1: Hiệu ứng Dunning–Kruger – mức độ tự tin thay đổi theo kinh nghiệm học tập\nGóc nhìn học tập: Hiệu ứng Dunning–Kruger InetAddress để làm việc này.\nĐịa chỉ IP là gì trong lập trình mạng? IP (Internet Protocol Address) là địa chỉ định danh của một thiết bị khi tham gia vào mạng máy tính.\nTrong lập trình mạng, IP đóng vai trò quan trọng trong việc:\nXác định máy gửi và máy nhận Định tuyến dữ liệu trong quá trình truyền thông Thiết lập kết nối giữa các tiến trình chạy trên những máy khác nhau Nếu không có địa chỉ IP, các máy tính sẽ không thể nhận biết và giao tiếp với nhau.\nVai trò của lớp InetAddress trong Java Lớp InetAddress đại diện cho một địa chỉ IP trong Java.\nThông qua lớp này, lập trình viên có thể:\nLấy địa chỉ IP của máy đang chạy chương trình Lấy tên máy (hostname) Phân giải tên miền sang địa chỉ IP Chuẩn bị thông tin để tạo Socket hoặc ServerSocket Hầu hết các chương trình lập trình mạng trong Java đều sử dụng InetAddress ở bước khởi tạo.\nPhân tích ý nghĩa các lệnh trong chương trình InetAddress.getLocalHost()\n→ Trả về đối tượng đại diện cho máy cục bộ (localhost).\ngetHostName()\n→ Lấy tên máy do hệ điều hành hoặc mạng gán.\ngetHostAddress()\n→ Lấy địa chỉ IP của máy dưới dạng chuỗi.\nViệc in ra hostname và IP giúp:\nKiểm tra cấu hình mạng Xác định đúng máy khi kết nối Client – Server Debug lỗi mạng Một số lưu ý khi lấy IP trong Java Khi máy không kết nối mạng, IP có thể là 127.0.0.1 Khi máy có nhiều card mạng (WiFi, LAN, VPN), IP trả về có thể không phải IP Internet Trên Server, hostname và IP thường khác máy cá nhân Ứng dụng thực tế Việc xác định IP của máy thường được sử dụng trong:\nChương trình Client – Server Thông báo IP Server cho Client kết nối Kiểm tra kết nối mạng LAN Ghi log và giám sát hệ thống Kết luận Qua bài học này, ta đã:\nHiểu vai trò của địa chỉ IP trong lập trình mạng Biết cách lấy IP bằng lớp InetAddress Chuẩn bị nền tảng cho các kỹ thuật TCP, UDP và RMI Liên hệ với học phần Lập trình Mạng máy tính Bài học này nằm trong nội dung mở đầu của học phần Lập trình Mạng máy tính (CMP180) tại Trường Đại học Công nghệ TP.HCM (HUTECH).\nTrong lộ trình môn học, sinh viên sẽ lần lượt tiếp cận các nội dung:\nKiến thức nền tảng về mạng và lập trình mạng Quản lý luồng nhập xuất (I/O) Quản lý địa chỉ và kết nối mạng Lập trình Socket TCP và UDP Xử lý đa tuyến, đa luồng Multicast UDP và Java RMI Thực hiện đồ án học phần cá nhân Mục tiêu của bài học Thông qua Bài 1, sinh viên sẽ:\nLàm quen với môi trường lập trình mạng bằng Java Hiểu được vai trò của địa chỉ IP trong giao tiếp mạng Biết cách sử dụng lớp InetAddress để lấy IP và hostname Chuẩn bị nền tảng cho các bài học tiếp theo về Socket và Server – Client ","permalink":"http://localhost:1313/blog/bai-viet-1/","summary":"GIỚI THIỆU HỌC PHẦN.","title":"Bài 1: Tổng quan khoá học"},{"content":"Trong lập trình mạng, nếu IP được xem như địa chỉ nhà của một máy tính trong mạng,\nthì Port (cổng) chính là số hiệu dùng để xác định chương trình hoặc dịch vụ cụ thể đang chạy trên máy đó.\nMột máy tính có thể chạy đồng thời nhiều ứng dụng mạng như Web Server, Database Server, Game Server hoặc Chat Server.\nMỗi ứng dụng bắt buộc phải gắn với một Port riêng để hệ điều hành có thể phân biệt và định tuyến dữ liệu chính xác.\nPort nằm ở đâu trong mô hình TCP/IP? Trong bộ giao thức TCP/IP, Port thuộc về Transport Layer (Tầng giao vận) và được sử dụng bởi hai giao thức chính là TCP và UDP.\nĐịa chỉ IP xác định máy nào sẽ nhận dữ liệu Port xác định ứng dụng nào trên máy đó sẽ xử lý dữ liệu Sự kết hợp giữa IP + Port tạo thành một Socket, là điểm cuối (endpoint) của quá trình giao tiếp mạng.\nCác loại Port phổ biến Port được đánh số từ 0 đến 65535 và được chia thành ba nhóm chính:\nInternet và các End Devices Trước khi tìm hiểu về Port, cần hiểu Internet được cấu thành từ hàng tỷ thiết bị đầu cuối (End Devices) như máy tính, điện thoại, máy chủ và các thiết bị IoT.\nCác thiết bị này kết nối với nhau thông qua nhiều lớp mạng khác nhau, và mỗi thiết bị khi tham gia giao tiếp mạng đều cần có địa chỉ IP và Port để định danh. Hình 2.1: Sơ đồ minh họa Internet và các thiết bị đầu cuối (End Devices) kết nối thông qua các mạng truy cập và mạng lõi.\nTrong quá trình giao tiếp mạng, một thiết bị không chỉ cần địa chỉ IP để xác định vị trí trong mạng, mà còn cần Port để xác định chính xác ứng dụng hoặc dịch vụ đang lắng nghe trên thiết bị đó.\nDo đó, Port đóng vai trò như “điểm tiếp nhận” (endpoint) cho các tiến trình mạng chạy trên cùng một máy.\nMô hình các tầng giao thức TCP/IP Để hiểu rõ Port hoạt động ở đâu và vì sao Server cần Port, ta cần nắm được mô hình giao thức TCP/IP – nền tảng của mọi ứng dụng mạng hiện nay.\nHình 2.2: Mô hình các tầng giao thức TCP/IP và các giao thức tiêu biểu tương ứng với từng tầng.\nTrong mô hình TCP/IP, địa chỉ IP hoạt động ở tầng Internet, giúp xác định thiết bị trong mạng.\nTrong khi đó, Port hoạt động ở tầng Transport (TCP/UDP), giúp xác định chính xác ứng dụng hoặc dịch vụ đang giao tiếp trên thiết bị đó.\nWell-known Ports (0 – 1023) Được dùng cho các dịch vụ chuẩn:\nPort 80: HTTP Port 443: HTTPS Port 21: FTP Port 25: SMTP Registered Ports (1024 – 49151) Thường dùng cho các ứng dụng phổ biến:\nPort 3306: MySQL Port 8080: Web Server thay thế port 80 Dynamic / Private Ports (49152 – 65535) Do hệ điều hành cấp phát tạm thời cho Client khi giao tiếp mạng.\nVì sao Server thường dùng cổng 8080? Cổng 8080 rất phổ biến trong quá trình phát triển và học tập vì:\nTránh xung đột với cổng 80 đang được hệ điều hành chiếm dụng Không cần quyền Administrator khi mở Server Phù hợp cho các Web Server thử nghiệm như: Apache Tomcat Spring Boot Node.js Lỗi thường gặp: “Address already in use” Lỗi này xảy ra khi Server cố gắng mở một Port đã bị chương trình khác chiếm dụng.\nNguyên nhân phổ biến:\nServer cũ chưa được tắt Port đang được dùng bởi dịch vụ khác Chạy nhiều Server cùng lúc Cách khắc phục:\nĐổi sang Port khác (ví dụ: 8080 → 9090) Kiểm tra Port đang sử dụng trong hệ điều hành Đảm bảo chỉ có một Server chạy tại một thời điểm Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), khái niệm Port sẽ được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Xây dựng mô hình Client – Server Java RMI và Multicast Việc hiểu rõ Port là nền tảng bắt buộc trước khi triển khai các ứng dụng mạng thực tế.\nKết luận Qua bài học này, ta đã:\nHiểu được Port là gì và vai trò của Port trong lập trình mạng Nắm được mối quan hệ giữa IP, Port và Socket Giải thích được lý do Server thường sử dụng cổng 8080 Chuẩn bị kiến thức nền cho các bài học tiếp theo về TCP và UDP ","permalink":"http://localhost:1313/blog/bai-viet-2/","summary":"MẠNG MÁY TÍNH \u0026amp; INTERNET.","title":"Bài 2: Kiến thức nền tảng?"},{"content":"Trong lập trình Java, luồng nhập xuất (Input / Output Streams) đóng vai trò trung gian giúp chương trình đọc và ghi dữ liệu từ nhiều nguồn khác nhau như bàn phím, file, console, bộ nhớ và sau này là socket mạng.\nHiểu rõ cơ chế luồng nhập xuất là bước nền bắt buộc trước khi đi vào lập trình Socket TCP, UDP hay Java RMI.\nLuồng (Stream) là gì? Luồng (Stream) là dòng dữ liệu di chuyển\ntừ nguồn → chương trình hoặc từ chương trình → đích.\nKhi Java đọc hoặc ghi dữ liệu, dữ liệu không đi trực tiếp mà luôn được đóng gói và truyền qua luồng.\nLuồng nhập xuất là gì? Luồng nhập xuất là cơ chế cho phép chương trình:\nNhận dữ liệu từ bên ngoài (Input) Ghi dữ liệu ra bên ngoài (Output) Luồng có thể kết nối với nhiều nguồn và đích khác nhau:\nFile Bàn phím Màn hình (console) Bộ nhớ Kết nối mạng (TCP / UDP) Dữ liệu trong luồng tồn tại dưới những dạng nào? Trong Java, dữ liệu trong luồng tồn tại dưới hai dạng chính:\nLuồng byte Luồng ký tự Việc chọn đúng loại luồng ảnh hưởng trực tiếp đến hiệu năng và tính chính xác của chương trình.\nLuồng byte trong Java Đặc điểm Dữ liệu được xử lý dưới dạng nhị phân Phù hợp với: File nhị phân Ảnh, video Socket mạng Dữ liệu phức tạp Các lớp gốc InputStream – luồng đọc byte OutputStream – luồng ghi byte Cả hai đều là lớp trừu tượng (abstract).\nCác luồng byte đọc phổ biến FileInputStream – đọc byte từ file ByteArrayInputStream – đọc từ mảng byte PipedInputStream – đọc từ luồng pipe Các luồng byte ghi phổ biến FileOutputStream – ghi byte vào file ByteArrayOutputStream – ghi vào mảng byte PipedOutputStream – ghi vào luồng pipe Mô hình đọc/ghi dữ liệu với Stream Quy trình chung khi làm việc với luồng:\nTạo đối tượng Stream Gắn Stream với nguồn hoặc đích Đọc/ghi dữ liệu trong vòng lặp Đóng Stream sau khi hoàn tất Luồng ký tự trong Java Đặc điểm Xử lý dữ liệu dạng Unicode Phù hợp với: File văn bản Chuỗi Dữ liệu hiển thị cho người dùng Các lớp gốc Reader – luồng đọc ký tự Writer – luồng ghi ký tự Các luồng ký tự đọc phổ biến FileReader – đọc file văn bản BufferedReader – đọc có bộ đệm StringReader – đọc chuỗi CharArrayReader – đọc mảng ký tự Các luồng ký tự ghi phổ biến FileWriter – ghi vào file văn bản BufferedWriter – ghi có bộ đệm PrintWriter – ghi dữ liệu dạng dễ đọc StringWriter – ghi chuỗi Luồng lọc dữ liệu (Filtered Streams) Luồng lọc dùng để chuyển đổi dữ liệu từ dạng byte/ký tự sang các kiểu dữ liệu khác.\nCác luồng lọc phổ biến DataInputStream DataOutputStream Cho phép đọc/ghi các kiểu dữ liệu nguyên thủy:\nint float double boolean char Đây là cầu nối giữa luồng thô và dữ liệu có kiểu trong Java.\nLưu trạng thái đối tượng – Serialization Serialization là gì? Serialization (chuỗi hóa) là quá trình chuyển đối tượng Java thành luồng byte để:\nLưu vào file Truyền qua mạng Phục hồi lại sau này Deserialization Ngược lại, Deserialization (giải chuỗi) là quá trình:\nĐọc byte Tái tạo lại đối tượng ban đầu Đây là nền tảng cho:\nLưu dữ liệu chương trình Java RMI Truyền object qua mạng Try-with-resources (TWR) Java hỗ trợ Try-with-resources để:\nTự động đóng stream Tránh rò rỉ tài nguyên Code gọn và an toàn hơn So với try-catch truyền thống, TWR:\nÍt lỗi hơn Dễ bảo trì hơn Được khuyến khích sử dụng Các lỗi I/O thường gặp Khi làm việc với luồng, một số exception phổ biến là:\nFileNotFoundException IOException EOFException UnsupportedEncodingException FileAlreadyExistsException AccessDeniedException SocketException MalformedURLException SerializationException InvalidPathException Việc bắt và xử lý exception đúng cách là yêu cầu bắt buộc trong lập trình Java.\nLiên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), luồng nhập xuất được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Truyền dữ liệu Client – Server Java RMI Multicast UDP Không hiểu I/O Stream → không thể làm mạng đúng cách.\nKết luận Qua bài học này, ta đã:\nHiểu khái niệm luồng nhập xuất trong Java Phân biệt luồng byte và luồng ký tự Nắm được cách đọc/ghi dữ liệu với Stream Biết vai trò của Serialization và Filtered Streams Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo Khi xử lý các tác vụ mạng (như gọi API), người mới học JS hay viết code lồng nhau kiểu này:\n1 2 3 4 5 6 7 8 9 10 // Cực hình Callback Hell getData(function(a) { getMoreData(a, function(b) { getMoreData(b, function(c) { getMoreData(c, function(d) { console.log(d); }); }); }); }); ","permalink":"http://localhost:1313/blog/bai-viet-3/","summary":"Tổng quan về Input/Output Streams trong Java – nền tảng cho xử lý file, console và lập trình mạng.","title":"Bài 3: Quản lý luồng nhập xuất trong Java"},{"content":"Trong lập trình mạng, trước khi chương trình có thể gửi hoặc nhận dữ liệu, điều quan trọng nhất là xác định đúng địa chỉ kết nối mạng. Nếu xác định sai địa chỉ, chương trình sẽ không thể giao tiếp, dù phần xử lý dữ liệu có đúng đến đâu.\nBài học này giúp bạn hiểu cách Java làm việc với địa chỉ IP, tên miền (DNS) và URL. Đây là nền tảng bắt buộc trước khi đi vào Socket TCP, UDP, Web Crawler và Java RMI.\nĐịa chỉ kết nối mạng là gì? Địa chỉ kết nối mạng là thông tin dùng để xác định máy nào trong mạng cần giao tiếp và dịch vụ nào trên máy đó sẽ xử lý dữ liệu.\nTrong Internet, địa chỉ kết nối thường bao gồm:\nĐịa chỉ IP Tên miền (Domain Name) Cổng (Port) Giao thức (Protocol) DNS – Domain Name System Hình 4.1 – Mô hình hoạt động của DNS (Domain Name System)\nCon người dễ nhớ tên miền hơn các dãy số IP.\nDNS (Domain Name System) có nhiệm vụ ánh xạ tên miền sang địa chỉ IP, giúp client tìm đúng server cần kết nối.\nVí dụ:\ngoogle.com tương ứng với nhiều địa chỉ IP khác nhau www.cs.yale.edu tương ứng với 128.36.229.30 Nhờ DNS, người dùng không cần ghi nhớ địa chỉ IP khi truy cập Internet.\nĐịa chỉ IPv4 IPv4 là dạng địa chỉ phổ biến, gồm 32 bit, thường được viết thành bốn nhóm số.\nVí dụ:\n192.168.1.1 8.8.8.8 Một số dải địa chỉ đặc biệt:\n127.x.x.x là loopback (localhost) 224.0.0.0 – 239.255.255.255 là multicast Lớp InetAddress trong Java Java cung cấp lớp InetAddress để làm việc với địa chỉ IP và DNS.\nLớp này thường được dùng để:\nPhân giải tên miền sang IP Kiểm tra loại địa chỉ Kiểm tra khả năng kết nối mạng Ví dụ minh họa:\n1 InetAddress address = InetAddress.getByName(\u0026#34;google.com\u0026#34;); URL – Uniform Resource Locator URL được dùng để xác định tài nguyên trên Internet như trang web, file hoặc dịch vụ.\nMột URL đầy đủ thường bao gồm các thành phần sau:\nGiao thức (Protocol) Tên miền (Host) Cổng (Port) Đường dẫn (Path) Chuỗi truy vấn (Query) Ví dụ một URL đầy đủ: https://www.hutech.edu.vn/admission?id=123\nURL cho biết lấy dữ liệu ở đâu và bằng cách nào.\nLớp URL trong Java Lớp URL cho phép chương trình Java:\nPhân tích các thành phần của URL Kết nối tới server Đọc dữ liệu từ Internet Ví dụ minh họa:\n1 URL url = new URL(\u0026#34;https://www.example.com\u0026#34;); Ý nghĩa của việc quản lý địa chỉ kết nối mạng Hiểu rõ cách quản lý địa chỉ mạng giúp:\nTránh kết nối sai server Chuẩn bị đúng địa chỉ cho Socket TCP/UDP Hiểu cách Web Crawler hoạt động Nắm vững mô hình Client – Server Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm địa chỉ kết nối mạng Biết vai trò của DNS và IPv4 Nắm được cách Java làm việc với InetAddress Hiểu cấu trúc và vai trò của URL Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-4/","summary":"Tìm hiểu cách Java quản lý địa chỉ mạng thông qua InetAddress, URL, URLConnection và DNS.","title":"Bài 4: Quản lý địa chỉ kết nối mạng trong Java"},{"content":"Trong lập trình mạng, TCP Socket là cơ chế quan trọng nhất để xây dựng các ứng dụng Client – Server có độ tin cậy cao.\nBài học này giúp bạn hiểu TCP là gì, vì sao cần TCP, và cách Java triển khai TCP thông qua Socket và ServerSocket.\nĐây là bước chuyển tiếp trực tiếp từ kiến thức địa chỉ mạng (IP, DNS, URL) sang giao tiếp dữ liệu thực tế giữa các chương trình.\nTCP là gì? TCP (Transmission Control Protocol) là giao thức truyền thông hướng kết nối, đảm bảo dữ liệu được truyền:\nĐúng thứ tự Đầy đủ Không bị mất mát Không bị trùng lặp Trước khi truyền dữ liệu, TCP yêu cầu thiết lập kết nối giữa hai bên, và chỉ khi kết nối thành công thì dữ liệu mới được trao đổi.\nVì sao sử dụng TCP? TCP được sử dụng khi ứng dụng yêu cầu độ tin cậy cao, ví dụ:\nỨng dụng chat Ứng dụng client–server Truyền file Game online theo lượt Hệ thống ngân hàng, thương mại điện tử TCP cung cấp các cơ chế quan trọng:\nĐảm bảo dữ liệu: gói tin bị mất sẽ được gửi lại Kiểm soát lỗi: phát hiện và sửa lỗi trong quá trình truyền Kiểm soát luồng: tránh làm quá tải phía nhận Giao tiếp hai chiều: cho phép gửi và nhận dữ liệu đồng thời Cơ chế hoạt động của TCP Quá trình giao tiếp TCP gồm ba giai đoạn chính:\nThiết lập kết nối (Bắt tay 3 bước – Three-way Handshake) Truyền dữ liệu Giải phóng kết nối Nhờ cơ chế này, TCP đảm bảo rằng hai bên luôn sẵn sàng trước khi truyền và kết thúc an toàn sau khi hoàn tất.\nMô hình Client – Server Các ứng dụng TCP thường hoạt động theo mô hình Client – Server.\nServer:\nChạy trước Lắng nghe yêu cầu kết nối Cung cấp dịch vụ Trả kết quả cho client Client:\nChạy sau Chủ động kết nối tới server Gửi yêu cầu Nhận phản hồi từ server Quá trình giao tiếp gồm:\nClient gửi yêu cầu Server xử lý Server trả kết quả cho client Socket trong Java Trong Java, Socket đại diện cho điểm cuối giao tiếp giữa client và server khi sử dụng TCP.\nSocket cho phép:\nGửi dữ liệu tới server Nhận dữ liệu từ server Giao tiếp hai chiều thông qua luồng nhập/xuất Ví dụ minh họa tạo Socket phía client:\n1 Socket socket = new Socket(\u0026#34;localhost\u0026#34;, 8080); ServerSocket trong Java ServerSocket được sử dụng ở phía server để:\nMở một cổng lắng nghe Chờ client kết nối Chấp nhận kết nối và tạo Socket giao tiếp ServerSocket đóng vai trò như cửa ngõ, cho phép các client kết nối vào server.\nVí dụ minh họa:\n1 ServerSocket server = new ServerSocket(8080); Luồng dữ liệu trong TCP Socket Sau khi kết nối TCP được thiết lập, client và server trao đổi dữ liệu thông qua các luồng:\nInputStream: dùng để đọc dữ liệu từ socket OutputStream: dùng để ghi dữ liệu vào socket Luồng dữ liệu này hoạt động tương tự như I/O Stream đã học ở bài trước,\nnhưng nguồn và đích là mạng thay vì file hay bàn phím.\nVí dụ ứng dụng: Trò chơi Oẳn Tù Tì Một bài tập tiêu biểu sử dụng TCP Socket là trò chơi Oẳn Tù Tì theo mô hình Client – Server.\nĐặc điểm Server quản lý luật chơi và điểm số Hai client gửi lựa chọn (kéo – búa – bao) Server xác định kết quả và gửi lại cho client Dữ liệu được truyền qua TCP để đảm bảo chính xác Thông qua bài tập này, sinh viên hiểu rõ:\nCách thiết lập kết nối TCP Cách trao đổi dữ liệu giữa nhiều client Cách xử lý lỗi mạng và ngoại lệ Ý nghĩa của lập trình TCP Socket Việc nắm vững TCP Socket giúp bạn:\nHiểu bản chất giao tiếp mạng Xây dựng hệ thống Client – Server thực tế Chuẩn bị cho các bài nâng cao như: Đa tuyến (Multi-thread) Socket UDP Java RMI Ứng dụng mạng phân tán Kết luận Qua bài học này, bạn đã:\nHiểu TCP là gì và vì sao cần TCP Nắm được mô hình Client – Server Biết vai trò của Socket và ServerSocket trong Java Hiểu cách dữ liệu được truyền qua TCP Chuẩn bị nền tảng cho các bài học UDP và xử lý đồng thời tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-5/","summary":"Giải thích mô hình Client–Server và cách lập trình Socket TCP trong Java – nền tảng cho giao tiếp mạng tin cậy.","title":"Bài 5: Lập trình Socket TCP trong Java"},{"content":"#Trong lập trình mạng, không phải lúc nào ứng dụng cũng cần độ tin cậy tuyệt đối như TCP.\nTrong nhiều trường hợp, điều quan trọng hơn là tốc độ truyền nhanh và độ trễ thấp.\nBài học này giới thiệu UDP Socket – cơ chế truyền dữ liệu không kết nối, được sử dụng rộng rãi trong các ứng dụng thời gian thực.\nUDP là gì? UDP (User Datagram Protocol) là giao thức truyền thông không hướng kết nối.\nĐiều này có nghĩa là:\nKhông thiết lập kết nối trước khi truyền Không đảm bảo dữ liệu đến nơi Không đảm bảo thứ tự gói tin Không tự động gửi lại gói tin bị mất UDP gửi dữ liệu theo từng datagram (gói tin độc lập).\nSo sánh TCP và UDP TCP UDP Có kết nối Không kết nối Đảm bảo dữ liệu Không đảm bảo Truyền theo luồng Truyền theo gói Độ trễ cao hơn Độ trễ thấp Phù hợp dữ liệu quan trọng Phù hợp dữ liệu thời gian thực Khi nào sử dụng UDP? UDP được sử dụng khi:\nCần truyền nhanh Có thể chấp nhận mất gói tin Dữ liệu được gửi liên tục Ví dụ ứng dụng UDP:\nTruyền video, audio trực tuyến Game online thời gian thực Chat broadcast DNS Multicast, streaming UDP Socket trong Java Java hỗ trợ UDP thông qua hai lớp chính:\nDatagramSocket: quản lý socket UDP DatagramPacket: đại diện cho gói dữ liệu UDP UDP không phân biệt client hay server rõ ràng như TCP.\nMỗi chương trình chỉ cần một DatagramSocket để gửi và nhận dữ liệu.\nDatagramPacket là gì? DatagramPacket là gói dữ liệu UDP, bao gồm:\nDữ liệu cần gửi Địa chỉ IP đích Số hiệu cổng Mỗi lần gửi hoặc nhận dữ liệu, UDP làm việc với một DatagramPacket riêng biệt.\nLuồng dữ liệu trong UDP UDP không có luồng InputStream / OutputStream như TCP.\nQuy trình truyền dữ liệu UDP:\nTạo DatagramSocket Tạo DatagramPacket chứa dữ liệu Gửi packet đi Nhận packet về Đọc dữ liệu từ packet Mỗi gói tin là độc lập, không liên quan đến các gói khác.\nĐặc điểm quan trọng của UDP Không kiểm soát lỗi Không kiểm soát luồng Không bắt tay kết nối Gửi nhanh, xử lý đơn giản Phù hợp truyền broadcast và multicast Chính vì vậy, UDP thường được dùng khi tốc độ quan trọng hơn độ chính xác tuyệt đối.\nÝ nghĩa của lập trình Socket UDP Nắm vững UDP giúp bạn:\nHiểu bản chất truyền dữ liệu không kết nối Xây dựng ứng dụng thời gian thực Phân biệt rõ TCP và UDP trong thiết kế hệ thống Chuẩn bị cho các chủ đề nâng cao như: Multicast UDP Java RMI Hệ thống phân tán Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính, UDP được sử dụng trong:\nSocket UDP Multicast Ứng dụng truyền tin nhanh Game, streaming, broadcast Hiểu UDP giúp bạn chọn đúng giao thức cho từng bài toán thực tế.\nKết luận Qua bài học này, bạn đã:\nHiểu UDP là gì và cơ chế hoạt động Phân biệt được TCP và UDP Biết vai trò của DatagramSocket và DatagramPacket Hiểu cách truyền dữ liệu không kết nối Chuẩn bị nền tảng cho bài Multicast UDP \u0026amp; Java RMI tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-6/","summary":"Giải thích giao thức UDP và cách Java lập trình Socket UDP – nền tảng cho truyền dữ liệu nhanh, không kết nối.","title":"Bài 6: Lập trình Socket UDP trong Java"},{"content":"Trong các ứng dụng mạng thực tế, đặc biệt là Server, chương trình thường phải xử lý nhiều yêu cầu cùng lúc.\nNếu chỉ sử dụng một luồng thực thi, server sẽ bị tắc nghẽn, các client phải chờ đợi và hiệu năng giảm nghiêm trọng.\nVì vậy, lập trình đa tuyến (Multithreading) và xử lý đồng thời (Concurrency) là kỹ thuật bắt buộc trong lập trình mạng.\nTuyến (Thread) là gì? Thread là một dòng điều khiển tuần tự bên trong một chương trình.\nMột chương trình (process) có thể chứa nhiều thread Các thread có thể chạy đồng thời Mỗi thread thực hiện một nhiệm vụ riêng Thread không phải là một chương trình độc lập,\nnó luôn thuộc về một process.\nProcess và Thread Process:\nCó không gian bộ nhớ riêng Chạy độc lập với process khác Tạo và chuyển đổi tốn nhiều tài nguyên Thread:\nChia sẻ bộ nhớ với các thread khác trong cùng process Tạo nhanh hơn process Chuyển đổi nhanh hơn Nhờ thread, chương trình có thể thực hiện nhiều công việc cùng lúc trong cùng một ứng dụng.\nVì sao cần lập trình đa tuyến? Lập trình đa tuyến giúp:\nTăng hiệu suất và khả năng đáp ứng Tận dụng thời gian chờ đợi (I/O, mạng, tải file) Chia nhỏ tác vụ và xử lý đồng thời Cải thiện trải nghiệm người dùng Trong lập trình mạng, đa tuyến cho phép server phục vụ nhiều client cùng lúc.\nThực thi Thread trong Java Trong Java, một thread bắt đầu chạy khi gọi phương thức start().\nKhi thread chạy, JVM thực thi mã trong phương thức run() Khi run() kết thúc, thread cũng kết thúc Một thread không thể start lại, muốn chạy lại phải tạo thread mới Thread cần có điều kiện dừng rõ ràng để tránh chạy vô hạn.\nỨng dụng đa tuyến trong lập trình mạng Ứng dụng Chat đa tuyến Một ví dụ tiêu biểu của đa tuyến trong mạng là ứng dụng chat nhiều client – một server.\nĐặc điểm:\nServer chấp nhận nhiều client kết nối cùng lúc Mỗi client được xử lý bởi một thread riêng Tin nhắn từ một client được gửi tới tất cả client khác Server ghi lại nội dung chat vào file log Thông qua ví dụ này, sinh viên hiểu rõ:\nCách server xử lý nhiều kết nối đồng thời Cách phối hợp giữa socket và thread Vai trò của đa tuyến trong ứng dụng mạng Xử lý đồng thời (Concurrency) Xử lý đồng thời xảy ra khi nhiều thread:\nChạy cùng lúc Truy cập tài nguyên chung (biến, file, bộ nhớ) Nếu không kiểm soát tốt, chương trình có thể gặp các vấn đề nghiêm trọng.\nRace Condition Race Condition xảy ra khi:\nNhiều thread cùng truy cập và thay đổi dữ liệu chung Kết quả phụ thuộc vào thứ tự thực thi không xác định Điều này có thể dẫn đến:\nDữ liệu sai lệch Kết quả không nhất quán Lỗi khó phát hiện Đồng bộ hóa (Synchronization) Để tránh race condition, Java cung cấp cơ chế đồng bộ hóa:\nĐảm bảo chỉ một thread được truy cập tài nguyên tại một thời điểm Giữ cho dữ liệu luôn nhất quán Đồng bộ hóa là nền tảng để xây dựng các ứng dụng an toàn và ổn định khi chạy đa tuyến.\nCác vấn đề thường gặp trong xử lý đồng thời Một số vấn đề phổ biến:\nRace condition: tranh chấp dữ liệu Deadlock: các thread chờ nhau vô hạn Livelock: các thread liên tục phản ứng nhưng không tiến triển Starvation: thread không bao giờ được cấp tài nguyên Những vấn đề này khiến lập trình đa tuyến trở nên phức tạp và khó debug.\nLập lịch Thread trong Java Java sử dụng cơ chế lập lịch theo độ ưu tiên:\nMỗi thread có độ ưu tiên từ MIN_PRIORITY đến MAX_PRIORITY JVM chọn thread runnable có độ ưu tiên cao hơn để chạy Thread có thể nhường CPU cho thread khác bằng cách gọi yield() Việc hiểu cơ chế lập lịch giúp lập trình viên thiết kế thread hợp lý hơn.\nÝ nghĩa của lập trình đa tuyến và xử lý đồng thời Nắm vững kiến thức bài này giúp bạn:\nXây dựng server xử lý nhiều client Viết ứng dụng mạng hiệu năng cao Tránh lỗi tranh chấp dữ liệu Chuẩn bị cho các chủ đề nâng cao như: Server đa tuyến Pooling Threads Multicast UDP Java RMI Hệ thống phân tán Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm thread và multithreading Phân biệt process và thread Biết vai trò của đa tuyến trong lập trình mạng Hiểu các vấn đề xử lý đồng thời và race condition Chuẩn bị nền tảng cho các bài học nâng cao tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-7/","summary":"Giải thích lập trình đa tuyến và xử lý đồng thời trong Java – nền tảng cho các ứng dụng mạng nhiều client và hệ thống phân tán.","title":"Bài 7: Lập trình đa tuyến và xử lý đồng thời trong Java"},{"content":"Buổi 8 gồm 2 phần lớn:\nMulticast UDP: gửi dữ liệu từ một nguồn đến nhiều máy nhận cùng lúc (1 → N). Java RMI: gọi phương thức từ xa giữa các ứng dụng Java như gọi hàm bình thường (Remote Method Invocation). Đây là các kỹ thuật thường gặp trong streaming, trò chuyện nhóm, giám sát từ xa và hệ thống phân tán.\n1) UDP Multicast Unicast, Broadcast và Multicast Trong mạng máy tính có 3 kiểu gửi dữ liệu phổ biến:\nUnicast: 1 nguồn → 1 đích\nVí dụ: bạn mở một trang web, server trả dữ liệu cho riêng bạn.\nBroadcast: 1 nguồn → tất cả máy trong mạng nội bộ\nVí dụ: một thông báo phát cho toàn bộ LAN.\nMulticast: 1 nguồn → một nhóm máy đã đăng ký nhận dữ liệu\nVí dụ: server phát stream video cho nhóm người xem cùng lúc.\nMulticast là cách truyền hiệu quả khi nhiều máy cùng cần nhận một nội dung giống nhau.\nTại sao dùng UDP Multicast? UDP Multicast thường được dùng vì:\nHiệu suất cao: gửi 1 lần nhưng nhiều máy nhận → giảm tải mạng và server. Đơn giản, nhanh: UDP là kiểu “gửi và quên”, không phải chờ xác nhận. Tối ưu trong LAN: phù hợp môi trường mạng nội bộ (Local Area Network). Rất hợp streaming: audio/video cần tốc độ và độ trễ thấp hơn là đảm bảo tuyệt đối. Ứng dụng của Multicast Multicast có thể dùng trong:\nTruyền phát multimedia trực tiếp (audio/video streaming) Trò chuyện nhóm, hội thoại nhóm Quảng bá thông tin cấu hình mạng và cập nhật trong hệ thống mạng Game nhiều người chơi (gửi trạng thái game cho nhiều người) Phát thông tin trạng thái/cảnh báo cho nhiều thiết bị Phát tán cập nhật phần mềm trong mạng nội bộ Địa chỉ Multicast IPv4 Trong IPv4:\nClass D là dải địa chỉ dành cho multicast Dải địa chỉ multicast thường gặp: 224.0.0.0 – 239.255.255.255 Một số nhóm multicast hay được nhắc:\n224.0.0.1: tất cả host trong local subnet Multicast Group là gì? Multicast hoạt động theo “nhóm”:\nMột multicast group giống như một kênh. Máy nào muốn nhận dữ liệu phải tham gia nhóm (join group). Khi rời nhóm thì không nhận dữ liệu nữa. Multicast trong Java Java hỗ trợ multicast qua lớp:\njava.net.MulticastSocket (kế thừa từ DatagramSocket) Một số thao tác quan trọng:\njoinGroup(...): tham gia nhóm multicast leaveGroup(...): rời nhóm multicast setTimeToLive(ttl): đặt TTL (thời gian sống của gói tin, qua bao nhiêu router) Quy trình gửi dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket Tham gia nhóm multicast Tạo DatagramPacket chứa dữ liệu + địa chỉ nhóm + port Gửi packet Rời nhóm Ví dụ minh họa (ngắn, chỉ để hiểu):\n1 2 3 4 5 6 7 8 9 10 11 12 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(); socket.joinGroup(group); socket.setTimeToLive(5); byte[] data = \u0026#34;Hello Multicast\u0026#34;.getBytes(); DatagramPacket packet = new DatagramPacket(data, data.length, group, 9876); socket.send(packet); socket.leaveGroup(group); socket.close(); Quy trình nhận dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket lắng nghe trên port Tham gia nhóm multicast Tạo DatagramPacket rỗng để nhận dữ liệu Gọi receive() để chờ gói tin gửi về Đọc dữ liệu từ packet Rời nhóm và đóng socket Ví dụ minh họa (ngắn):\n1 2 3 4 5 6 7 8 9 10 11 12 13 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(9876); socket.joinGroup(group); byte[] buf = new byte[1024]; DatagramPacket packet = new DatagramPacket(buf, buf.length); socket.receive(packet); String msg = new String(packet.getData(), 0, packet.getLength()); System.out.println(\u0026#34;Received: \u0026#34; + msg); socket.leaveGroup(group); socket.close(); 2) Java RMI Java RMI là gì? RMI (Remote Method Invocation) cho phép chương trình Java:\nGọi phương thức của một đối tượng nằm trên máy khác Cảm giác giống như gọi method trong cùng chương trình Nói đơn giản:\nClient gọi: remoteObject.sum(1,2) Server thực thi thật và trả kết quả về cho client RMI giúp che giấu toàn bộ chi tiết mạng phía sau, người lập trình chỉ tập trung vào logic.\nVì sao dùng Java RMI? Java RMI được sử dụng vì:\nTích hợp sẵn trong Java, dễ triển khai nếu cả client và server đều dùng Java Gọi phương thức từ xa đơn giản như gọi hàm thông thường Hỗ trợ dữ liệu phức tạp: đối tượng, mảng, class tự định nghĩa Tự động xử lý giao tiếp mạng thông qua cơ chế stub / skeleton Dựa trên TCP/IP nên tương đối ổn định và tin cậy Hạn chế của Java RMI Một số điểm hạn chế cần lưu ý:\nPhụ thuộc Java: chủ yếu phù hợp Java ↔ Java Thiết kế dịch vụ phức tạp vẫn cần tổ chức tốt (đặc biệt khi dùng callback) Quản lý phiên và kết nối không mạnh như các giải pháp hiện đại Bảo mật cần cấu hình cẩn thận trong môi trường thực tế Ý tưởng kiến trúc RMI (hiểu nhanh) Trong Java RMI có các thành phần chính:\nRemote Interface\nKhai báo các phương thức cho phép gọi từ xa\nServer Implementation\nLớp cài đặt interface, chứa logic xử lý thật\nRMI Registry\nNơi đăng ký service để client tìm thấy server\nClient\nTìm (lookup) service trong registry và gọi phương thức\nCác bước triển khai RMI (tóm tắt) Định nghĩa Remote Interface Cài đặt interface bằng một class server (remote object) Viết chương trình server: tạo object và bind vào registry Viết chương trình client: lookup registry và gọi method Chạy RMI registry, chạy server, sau đó chạy client Ví dụ ứng dụng RMI Một số ví dụ thường gặp:\nTính tổng 2 số từ xa Dịch vụ quản lý tài khoản ATM Dịch vụ giám sát nhiệt độ có callback (server gọi ngược lại client) Bài tập gợi ý theo đúng nội dung buổi 8 BT8.01: Mô phỏng streaming video\n(1 server phát, nhiều client nhận dữ liệu)\nBT8.02: Server quản lý tài khoản ATM bằng RMI\n(thêm user, đăng nhập, gửi/rút tiền, lưu lịch sử giao dịch)\nKết luận Qua bài học này, bạn đã:\nHiểu sự khác nhau giữa Unicast, Broadcast và Multicast Nắm được vì sao Multicast UDP phù hợp cho truyền dữ liệu nhóm và streaming Biết cách Java hỗ trợ multicast qua MulticastSocket Hiểu Java RMI và cơ chế gọi phương thức từ xa Chuẩn bị nền tảng cho các bài ứng dụng mạng phân tán và đồ án học phần ","permalink":"http://localhost:1313/blog/bai-viet-8/","summary":"Giải thích Multicast UDP (gửi 1-n) và Java RMI (gọi phương thức từ xa) – nền tảng cho ứng dụng nhóm và hệ phân tán.","title":"Bài 8: Multicast UDP và Java RMI"},{"content":"Sau khi hoàn thành các bài về TCP, UDP, đa tuyến và xử lý đồng thời,\nchúng ta đã có đủ nền tảng để xây dựng một ứng dụng mạng hoàn chỉnh.\nBài học này giúp bạn xâu chuỗi toàn bộ kiến thức đã học,\nhiểu rõ mỗi công nghệ dùng trong trường hợp nào,\nvà cách thiết kế một hệ thống mạng đúng tư duy kỹ sư.\nNhìn lại các mô hình giao tiếp mạng đã học Trong lập trình mạng, các ứng dụng thường được xây dựng dựa trên mô hình Client – Server.\nClient: gửi yêu cầu, nhập dữ liệu, hiển thị kết quả Server: xử lý logic, quản lý dữ liệu, trả kết quả Tùy bài toán, ta lựa chọn giao thức và mô hình phù hợp.\nSo sánh TCP, UDP và Multicast TCP – Giao tiếp tin cậy TCP phù hợp khi:\nCần đảm bảo dữ liệu đúng và đủ Cần kết nối ổn định, hai chiều Ví dụ: chat, truyền file, game theo lượt, hệ thống ngân hàng Đặc trưng:\nCó bắt tay 3 bước Có kiểm soát lỗi, kiểm soát luồng Tốn tài nguyên hơn UDP UDP – Giao tiếp nhanh, không kết nối UDP phù hợp khi:\nƯu tiên tốc độ Chấp nhận mất gói Ví dụ: game thời gian thực, streaming, cảm biến Đặc trưng:\nKhông kết nối Không đảm bảo thứ tự Ít độ trễ UDP Multicast – Truyền dữ liệu nhóm Multicast được dùng khi:\nMột nguồn → nhiều người nhận Dữ liệu giống nhau cho tất cả client Ví dụ: livestream, thông báo hệ thống, truyền trạng thái Ưu điểm:\nGiảm tải server Tiết kiệm băng thông Phù hợp mạng LAN Vai trò của đa tuyến (Multithreading) Trong thực tế, server không thể xử lý từng client một cách tuần tự.\nĐa tuyến giúp:\nNhiều client kết nối cùng lúc Không client nào bị “đóng băng” Tăng khả năng mở rộng hệ thống Ví dụ:\nServer chat: mỗi client là một thread Server TCP: mỗi socket được xử lý riêng Thiết kế một ứng dụng mạng hoàn chỉnh Khi thiết kế, cần xác định rõ:\nGiao thức: TCP hay UDP? Mô hình: 1–1, 1–n, n–n? Đồng thời hay tuần tự? Client gửi gì? Server xử lý gì? Một thiết kế tốt luôn:\nPhân tách rõ giao tiếp – xử lý – dữ liệu Dễ mở rộng Dễ bảo trì Liên hệ với đồ án học phần Các đồ án như:\nChat đa tuyến Oẳn Tù Tì client–server Streaming UDP Dịch vụ RMI Đều là sự kết hợp của các kiến thức đã học,\nkhông phải nội dung mới.\nKết luận Qua bài học này, bạn đã:\nHệ thống lại toàn bộ kiến thức lập trình mạng Hiểu rõ khi nào dùng TCP, UDP, Multicast Nắm được vai trò của đa tuyến Biết cách tư duy thiết kế một ứng dụng mạng hoàn chỉnh Đây là bước chuẩn bị quan trọng trước khi vận dụng toàn bộ kiến thức vào một hệ thống thực tế.\n","permalink":"http://localhost:1313/blog/bai-viet-9/","summary":"Tổng hợp kiến thức TCP, UDP, đa tuyến và cách thiết kế ứng dụng mạng Client–Server hoàn chỉnh.","title":"Bài 9: Tổng hợp kiến thức \u0026 thiết kế ứng dụng mạng"},{"content":"Bài cuối cùng của học phần không nhằm giới thiệu công nghệ mới,\nmà tập trung vào cách vận dụng kiến thức đã học vào thực tế.\nĐây là giai đoạn chuyển từ:\n“Biết dùng” → “Biết thiết kế” → “Biết đánh giá hệ thống”\nTư duy vận dụng kiến thức Một ứng dụng mạng hoàn chỉnh cần trả lời được các câu hỏi:\nVì sao chọn TCP mà không phải UDP? Vì sao cần đa tuyến? Server có chịu được nhiều client không? Hệ thống có mở rộng được không? Đây chính là tư duy kỹ sư, không phải chỉ “chạy được là xong”.\nĐánh giá một ứng dụng mạng Khi hoàn thiện hệ thống, cần xem xét:\n1. Tính đúng đắn Dữ liệu có truyền đúng không? Có mất gói không? Có xử lý lỗi không? 2. Tính đồng thời Nhiều client có dùng chung được không? Có bị treo server không? Có race condition không? 3. Hiệu năng Độ trễ thế nào? Server có bị quá tải không? Có tách luồng hợp lý không? Liên hệ với các mô hình phân tán Các hệ thống đã học là nền tảng cho:\nHệ thống client–server lớn Ứng dụng phân tán Microservices Cloud services Java RMI, TCP đa tuyến hay UDP Multicast\nđều là những viên gạch đầu tiên.\nTừ học phần đến thực tế Sau học phần này, bạn có thể tiếp cận:\nWebSocket REST API gRPC Message Queue (Kafka, RabbitMQ) Hệ thống realtime Tư duy lập trình mạng không thay đổi, chỉ công nghệ thay đổi.\nTổng kết toàn bộ học phần Qua toàn bộ chuỗi bài, bạn đã:\nHiểu cách dữ liệu đi qua mạng Làm việc với TCP, UDP, Multicast Xử lý đa tuyến và đồng thời Tiếp cận lập trình phân tán với RMI Có tư duy thiết kế hệ thống mạng Lời kết Lập trình mạng không chỉ là code socket,\nmà là hiểu cách các hệ thống nói chuyện với nhau.\nNếu bạn hiểu được điều đó,\nbạn đã vượt xa mức “học để qua môn”.\n","permalink":"http://localhost:1313/blog/bai-viet-10/","summary":"Vận dụng toàn bộ kiến thức lập trình mạng để xây dựng, đánh giá và hoàn thiện một ứng dụng thực tế.","title":"Bài 10: Hoàn thiện \u0026 vận dụng lập trình mạng"},{"content":"Lời mở đầu Có những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\nMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\nHọc tập Những năm đại học trôi qua nhanh hơn mình từng nghĩ. Ngày mới bước chân vào giảng đường, mình vẫn còn khá mơ hồ về ngành học, về tương lai, về chính bản thân mình sẽ trở thành ai sau bốn năm. Nhưng rồi từng môn học, từng bài tập nhóm, từng đồ án kéo mình lại gần hơn với cách một hệ thống được hình thành và vận hành.\nHệ thống thông tin không chỉ là lập trình, cũng không đơn thuần là công nghệ. Đó là câu chuyện về con người, quy trình và dữ liệu. Mình học cách đặt câu hỏi, học cách lắng nghe yêu cầu, học cách vẽ ra những sơ đồ tưởng chừng khô khan nhưng lại chứa rất nhiều suy nghĩ phía sau. Dần dần, mình nhận ra mình thích phần “hiểu vấn đề” hơn là chỉ chăm chăm vào lời giải.\nĐịnh hướng Ở thời điểm hiện tại, mình đang định hướng theo con đường Business Analyst (BA). Mình hứng thú với vai trò đứng giữa – không quá xa kỹ thuật, cũng không tách rời nghiệp vụ. Đó là nơi cần sự rõ ràng trong tư duy, sự kiên nhẫn trong giao tiếp và khả năng chuyển hóa những điều mơ hồ thành thứ có thể triển khai được.\nMình không nghĩ BA là một vị trí “nhẹ nhàng” hay “an toàn”. Ngược lại, đó là công việc đòi hỏi phải học rất nhiều, sai rất nhiều và sửa rất nhiều. Nhưng chính điều đó khiến mình thấy phù hợp. Mình muốn hiểu hệ thống trước khi xây dựng nó, muốn biết vì sao người ta see cần một chức năng, chứ không chỉ là nó được viết như thế nào.\nBlog Blog này ra đời khá tự nhiên, giống như một cuốn sổ mở rộng hơn là một trang thể hiện điều gì đó to tát. Mình viết để nhớ, để hệ thống lại những gì đã học, và đôi khi là để sắp xếp lại suy nghĩ của chính mình.\nỞ đây có thể là kiến thức về Hệ thống thông tin, về phân tích nghiệp vụ, về lập trình, hoặc đơn giản là những trải nghiệm học tập và va chạm trong quá trình làm đồ án, làm việc nhóm, và chuẩn bị bước ra môi trường thực tế. Mình không mong mọi thứ phải hoàn hảo, chỉ mong nó thật và có ích cho ai đó đang đi trên con đường tương tự.\nLời kết Mình đang ở một giai đoạn chưa thể gọi là trưởng thành, nhưng cũng không còn quá non nớt. Vẫn đang học, vẫn đang thử, vẫn đang sai và sửa mỗi ngày. Nếu có một điều mình mong giữ được lâu nhất, thì đó là sự tò mò và tinh thần học hỏi – những thứ giúp mình không đứng yên giữa rất nhiều lựa chọn ngoài kia.\nCảm ơn bạn đã ghé qua và đọc những dòng này. Hy vọng ở một thời điểm nào đó, những chia sẻ nhỏ ở đây sẽ chạm đến bạn – dù chỉ là một chút. \u0026ldquo;Học để chia sẻ, chia sẻ để học nhiều hơn.\u0026rdquo;\nLiên hệ Nếu bạn muốn gửi cho mình vài dòng trao đổi,\nbạn có thể liên hệ với mình qua Email hoặc GitHub ,Facebook dưới đây.\nCảm ơn bạn đã ghé thăm blog! ","permalink":"http://localhost:1313/about/","summary":"\u003ch2 id=\"lời-mở-đầu\"\u003eLời mở đầu\u003c/h2\u003e\n\u003cp\u003eCó những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\u003c/p\u003e\n\u003cp\u003eMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\u003c/p\u003e","title":"Giới thiệu"},{"content":"Trong lập trình mạng, trước khi kết nối, ta phải biết \u0026ldquo;địa chỉ nhà\u0026rdquo; (IP) của mình và đối phương. Java cung cấp class\nHình 1.1: Hiệu ứng Dunning–Kruger – mức độ tự tin thay đổi theo kinh nghiệm học tập\nGóc nhìn học tập: Hiệu ứng Dunning–Kruger InetAddress để làm việc này.\nĐịa chỉ IP là gì trong lập trình mạng? IP (Internet Protocol Address) là địa chỉ định danh của một thiết bị khi tham gia vào mạng máy tính.\nTrong lập trình mạng, IP đóng vai trò quan trọng trong việc:\nXác định máy gửi và máy nhận Định tuyến dữ liệu trong quá trình truyền thông Thiết lập kết nối giữa các tiến trình chạy trên những máy khác nhau Nếu không có địa chỉ IP, các máy tính sẽ không thể nhận biết và giao tiếp với nhau.\nVai trò của lớp InetAddress trong Java Lớp InetAddress đại diện cho một địa chỉ IP trong Java.\nThông qua lớp này, lập trình viên có thể:\nLấy địa chỉ IP của máy đang chạy chương trình Lấy tên máy (hostname) Phân giải tên miền sang địa chỉ IP Chuẩn bị thông tin để tạo Socket hoặc ServerSocket Hầu hết các chương trình lập trình mạng trong Java đều sử dụng InetAddress ở bước khởi tạo.\nPhân tích ý nghĩa các lệnh trong chương trình InetAddress.getLocalHost()\n→ Trả về đối tượng đại diện cho máy cục bộ (localhost).\ngetHostName()\n→ Lấy tên máy do hệ điều hành hoặc mạng gán.\ngetHostAddress()\n→ Lấy địa chỉ IP của máy dưới dạng chuỗi.\nViệc in ra hostname và IP giúp:\nKiểm tra cấu hình mạng Xác định đúng máy khi kết nối Client – Server Debug lỗi mạng Một số lưu ý khi lấy IP trong Java Khi máy không kết nối mạng, IP có thể là 127.0.0.1 Khi máy có nhiều card mạng (WiFi, LAN, VPN), IP trả về có thể không phải IP Internet Trên Server, hostname và IP thường khác máy cá nhân Ứng dụng thực tế Việc xác định IP của máy thường được sử dụng trong:\nChương trình Client – Server Thông báo IP Server cho Client kết nối Kiểm tra kết nối mạng LAN Ghi log và giám sát hệ thống Kết luận Qua bài học này, ta đã:\nHiểu vai trò của địa chỉ IP trong lập trình mạng Biết cách lấy IP bằng lớp InetAddress Chuẩn bị nền tảng cho các kỹ thuật TCP, UDP và RMI Liên hệ với học phần Lập trình Mạng máy tính Bài học này nằm trong nội dung mở đầu của học phần Lập trình Mạng máy tính (CMP180) tại Trường Đại học Công nghệ TP.HCM (HUTECH).\nTrong lộ trình môn học, sinh viên sẽ lần lượt tiếp cận các nội dung:\nKiến thức nền tảng về mạng và lập trình mạng Quản lý luồng nhập xuất (I/O) Quản lý địa chỉ và kết nối mạng Lập trình Socket TCP và UDP Xử lý đa tuyến, đa luồng Multicast UDP và Java RMI Thực hiện đồ án học phần cá nhân Mục tiêu của bài học Thông qua Bài 1, sinh viên sẽ:\nLàm quen với môi trường lập trình mạng bằng Java Hiểu được vai trò của địa chỉ IP trong giao tiếp mạng Biết cách sử dụng lớp InetAddress để lấy IP và hostname Chuẩn bị nền tảng cho các bài học tiếp theo về Socket và Server – Client ","permalink":"http://localhost:1313/blog/bai-viet-1/","summary":"GIỚI THIỆU HỌC PHẦN.","title":"Bài 1: Tổng quan khoá học"},{"content":"Trong lập trình mạng, nếu IP được xem như địa chỉ nhà của một máy tính trong mạng,\nthì Port (cổng) chính là số hiệu dùng để xác định chương trình hoặc dịch vụ cụ thể đang chạy trên máy đó.\nMột máy tính có thể chạy đồng thời nhiều ứng dụng mạng như Web Server, Database Server, Game Server hoặc Chat Server.\nMỗi ứng dụng bắt buộc phải gắn với một Port riêng để hệ điều hành có thể phân biệt và định tuyến dữ liệu chính xác.\nPort nằm ở đâu trong mô hình TCP/IP? Trong bộ giao thức TCP/IP, Port thuộc về Transport Layer (Tầng giao vận) và được sử dụng bởi hai giao thức chính là TCP và UDP.\nĐịa chỉ IP xác định máy nào sẽ nhận dữ liệu Port xác định ứng dụng nào trên máy đó sẽ xử lý dữ liệu Sự kết hợp giữa IP + Port tạo thành một Socket, là điểm cuối (endpoint) của quá trình giao tiếp mạng.\nCác loại Port phổ biến Port được đánh số từ 0 đến 65535 và được chia thành ba nhóm chính:\nInternet và các End Devices Trước khi tìm hiểu về Port, cần hiểu Internet được cấu thành từ hàng tỷ thiết bị đầu cuối (End Devices) như máy tính, điện thoại, máy chủ và các thiết bị IoT.\nCác thiết bị này kết nối với nhau thông qua nhiều lớp mạng khác nhau, và mỗi thiết bị khi tham gia giao tiếp mạng đều cần có địa chỉ IP và Port để định danh. Hình 2.1: Sơ đồ minh họa Internet và các thiết bị đầu cuối (End Devices) kết nối thông qua các mạng truy cập và mạng lõi.\nTrong quá trình giao tiếp mạng, một thiết bị không chỉ cần địa chỉ IP để xác định vị trí trong mạng, mà còn cần Port để xác định chính xác ứng dụng hoặc dịch vụ đang lắng nghe trên thiết bị đó.\nDo đó, Port đóng vai trò như “điểm tiếp nhận” (endpoint) cho các tiến trình mạng chạy trên cùng một máy.\nMô hình các tầng giao thức TCP/IP Để hiểu rõ Port hoạt động ở đâu và vì sao Server cần Port, ta cần nắm được mô hình giao thức TCP/IP – nền tảng của mọi ứng dụng mạng hiện nay.\nHình 2.2: Mô hình các tầng giao thức TCP/IP và các giao thức tiêu biểu tương ứng với từng tầng.\nTrong mô hình TCP/IP, địa chỉ IP hoạt động ở tầng Internet, giúp xác định thiết bị trong mạng.\nTrong khi đó, Port hoạt động ở tầng Transport (TCP/UDP), giúp xác định chính xác ứng dụng hoặc dịch vụ đang giao tiếp trên thiết bị đó.\nWell-known Ports (0 – 1023) Được dùng cho các dịch vụ chuẩn:\nPort 80: HTTP Port 443: HTTPS Port 21: FTP Port 25: SMTP Registered Ports (1024 – 49151) Thường dùng cho các ứng dụng phổ biến:\nPort 3306: MySQL Port 8080: Web Server thay thế port 80 Dynamic / Private Ports (49152 – 65535) Do hệ điều hành cấp phát tạm thời cho Client khi giao tiếp mạng.\nVì sao Server thường dùng cổng 8080? Cổng 8080 rất phổ biến trong quá trình phát triển và học tập vì:\nTránh xung đột với cổng 80 đang được hệ điều hành chiếm dụng Không cần quyền Administrator khi mở Server Phù hợp cho các Web Server thử nghiệm như: Apache Tomcat Spring Boot Node.js Lỗi thường gặp: “Address already in use” Lỗi này xảy ra khi Server cố gắng mở một Port đã bị chương trình khác chiếm dụng.\nNguyên nhân phổ biến:\nServer cũ chưa được tắt Port đang được dùng bởi dịch vụ khác Chạy nhiều Server cùng lúc Cách khắc phục:\nĐổi sang Port khác (ví dụ: 8080 → 9090) Kiểm tra Port đang sử dụng trong hệ điều hành Đảm bảo chỉ có một Server chạy tại một thời điểm Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), khái niệm Port sẽ được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Xây dựng mô hình Client – Server Java RMI và Multicast Việc hiểu rõ Port là nền tảng bắt buộc trước khi triển khai các ứng dụng mạng thực tế.\nKết luận Qua bài học này, ta đã:\nHiểu được Port là gì và vai trò của Port trong lập trình mạng Nắm được mối quan hệ giữa IP, Port và Socket Giải thích được lý do Server thường sử dụng cổng 8080 Chuẩn bị kiến thức nền cho các bài học tiếp theo về TCP và UDP ","permalink":"http://localhost:1313/blog/bai-viet-2/","summary":"MẠNG MÁY TÍNH \u0026amp; INTERNET.","title":"Bài 2: Kiến thức nền tảng?"},{"content":"Trong lập trình Java, luồng nhập xuất (Input / Output Streams) đóng vai trò trung gian giúp chương trình đọc và ghi dữ liệu từ nhiều nguồn khác nhau như bàn phím, file, console, bộ nhớ và sau này là socket mạng.\nHiểu rõ cơ chế luồng nhập xuất là bước nền bắt buộc trước khi đi vào lập trình Socket TCP, UDP hay Java RMI.\nLuồng (Stream) là gì? Luồng (Stream) là dòng dữ liệu di chuyển\ntừ nguồn → chương trình hoặc từ chương trình → đích.\nKhi Java đọc hoặc ghi dữ liệu, dữ liệu không đi trực tiếp mà luôn được đóng gói và truyền qua luồng.\nLuồng nhập xuất là gì? Luồng nhập xuất là cơ chế cho phép chương trình:\nNhận dữ liệu từ bên ngoài (Input) Ghi dữ liệu ra bên ngoài (Output) Luồng có thể kết nối với nhiều nguồn và đích khác nhau:\nFile Bàn phím Màn hình (console) Bộ nhớ Kết nối mạng (TCP / UDP) Dữ liệu trong luồng tồn tại dưới những dạng nào? Trong Java, dữ liệu trong luồng tồn tại dưới hai dạng chính:\nLuồng byte Luồng ký tự Việc chọn đúng loại luồng ảnh hưởng trực tiếp đến hiệu năng và tính chính xác của chương trình.\nLuồng byte trong Java Đặc điểm Dữ liệu được xử lý dưới dạng nhị phân Phù hợp với: File nhị phân Ảnh, video Socket mạng Dữ liệu phức tạp Các lớp gốc InputStream – luồng đọc byte OutputStream – luồng ghi byte Cả hai đều là lớp trừu tượng (abstract).\nCác luồng byte đọc phổ biến FileInputStream – đọc byte từ file ByteArrayInputStream – đọc từ mảng byte PipedInputStream – đọc từ luồng pipe Các luồng byte ghi phổ biến FileOutputStream – ghi byte vào file ByteArrayOutputStream – ghi vào mảng byte PipedOutputStream – ghi vào luồng pipe Mô hình đọc/ghi dữ liệu với Stream Quy trình chung khi làm việc với luồng:\nTạo đối tượng Stream Gắn Stream với nguồn hoặc đích Đọc/ghi dữ liệu trong vòng lặp Đóng Stream sau khi hoàn tất Luồng ký tự trong Java Đặc điểm Xử lý dữ liệu dạng Unicode Phù hợp với: File văn bản Chuỗi Dữ liệu hiển thị cho người dùng Các lớp gốc Reader – luồng đọc ký tự Writer – luồng ghi ký tự Các luồng ký tự đọc phổ biến FileReader – đọc file văn bản BufferedReader – đọc có bộ đệm StringReader – đọc chuỗi CharArrayReader – đọc mảng ký tự Các luồng ký tự ghi phổ biến FileWriter – ghi vào file văn bản BufferedWriter – ghi có bộ đệm PrintWriter – ghi dữ liệu dạng dễ đọc StringWriter – ghi chuỗi Luồng lọc dữ liệu (Filtered Streams) Luồng lọc dùng để chuyển đổi dữ liệu từ dạng byte/ký tự sang các kiểu dữ liệu khác.\nCác luồng lọc phổ biến DataInputStream DataOutputStream Cho phép đọc/ghi các kiểu dữ liệu nguyên thủy:\nint float double boolean char Đây là cầu nối giữa luồng thô và dữ liệu có kiểu trong Java.\nLưu trạng thái đối tượng – Serialization Serialization là gì? Serialization (chuỗi hóa) là quá trình chuyển đối tượng Java thành luồng byte để:\nLưu vào file Truyền qua mạng Phục hồi lại sau này Deserialization Ngược lại, Deserialization (giải chuỗi) là quá trình:\nĐọc byte Tái tạo lại đối tượng ban đầu Đây là nền tảng cho:\nLưu dữ liệu chương trình Java RMI Truyền object qua mạng Try-with-resources (TWR) Java hỗ trợ Try-with-resources để:\nTự động đóng stream Tránh rò rỉ tài nguyên Code gọn và an toàn hơn So với try-catch truyền thống, TWR:\nÍt lỗi hơn Dễ bảo trì hơn Được khuyến khích sử dụng Các lỗi I/O thường gặp Khi làm việc với luồng, một số exception phổ biến là:\nFileNotFoundException IOException EOFException UnsupportedEncodingException FileAlreadyExistsException AccessDeniedException SocketException MalformedURLException SerializationException InvalidPathException Việc bắt và xử lý exception đúng cách là yêu cầu bắt buộc trong lập trình Java.\nLiên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), luồng nhập xuất được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Truyền dữ liệu Client – Server Java RMI Multicast UDP Không hiểu I/O Stream → không thể làm mạng đúng cách.\nKết luận Qua bài học này, ta đã:\nHiểu khái niệm luồng nhập xuất trong Java Phân biệt luồng byte và luồng ký tự Nắm được cách đọc/ghi dữ liệu với Stream Biết vai trò của Serialization và Filtered Streams Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo Khi xử lý các tác vụ mạng (như gọi API), người mới học JS hay viết code lồng nhau kiểu này:\n1 2 3 4 5 6 7 8 9 10 // Cực hình Callback Hell getData(function(a) { getMoreData(a, function(b) { getMoreData(b, function(c) { getMoreData(c, function(d) { console.log(d); }); }); }); }); ","permalink":"http://localhost:1313/blog/bai-viet-3/","summary":"Tổng quan về Input/Output Streams trong Java – nền tảng cho xử lý file, console và lập trình mạng.","title":"Bài 3: Quản lý luồng nhập xuất trong Java"},{"content":"Trong lập trình mạng, trước khi chương trình có thể gửi hoặc nhận dữ liệu, điều quan trọng nhất là xác định đúng địa chỉ kết nối mạng. Nếu xác định sai địa chỉ, chương trình sẽ không thể giao tiếp, dù phần xử lý dữ liệu có đúng đến đâu.\nBài học này giúp bạn hiểu cách Java làm việc với địa chỉ IP, tên miền (DNS) và URL. Đây là nền tảng bắt buộc trước khi đi vào Socket TCP, UDP, Web Crawler và Java RMI.\nĐịa chỉ kết nối mạng là gì? Địa chỉ kết nối mạng là thông tin dùng để xác định máy nào trong mạng cần giao tiếp và dịch vụ nào trên máy đó sẽ xử lý dữ liệu.\nTrong Internet, địa chỉ kết nối thường bao gồm:\nĐịa chỉ IP Tên miền (Domain Name) Cổng (Port) Giao thức (Protocol) DNS – Domain Name System Hình 4.1 – Mô hình hoạt động của DNS (Domain Name System)\nCon người dễ nhớ tên miền hơn các dãy số IP.\nDNS (Domain Name System) có nhiệm vụ ánh xạ tên miền sang địa chỉ IP, giúp client tìm đúng server cần kết nối.\nVí dụ:\ngoogle.com tương ứng với nhiều địa chỉ IP khác nhau www.cs.yale.edu tương ứng với 128.36.229.30 Nhờ DNS, người dùng không cần ghi nhớ địa chỉ IP khi truy cập Internet.\nĐịa chỉ IPv4 IPv4 là dạng địa chỉ phổ biến, gồm 32 bit, thường được viết thành bốn nhóm số.\nVí dụ:\n192.168.1.1 8.8.8.8 Một số dải địa chỉ đặc biệt:\n127.x.x.x là loopback (localhost) 224.0.0.0 – 239.255.255.255 là multicast Lớp InetAddress trong Java Java cung cấp lớp InetAddress để làm việc với địa chỉ IP và DNS.\nLớp này thường được dùng để:\nPhân giải tên miền sang IP Kiểm tra loại địa chỉ Kiểm tra khả năng kết nối mạng Ví dụ minh họa:\n1 InetAddress address = InetAddress.getByName(\u0026#34;google.com\u0026#34;); URL – Uniform Resource Locator URL được dùng để xác định tài nguyên trên Internet như trang web, file hoặc dịch vụ.\nMột URL đầy đủ thường bao gồm các thành phần sau:\nGiao thức (Protocol) Tên miền (Host) Cổng (Port) Đường dẫn (Path) Chuỗi truy vấn (Query) Ví dụ một URL đầy đủ: https://www.hutech.edu.vn/admission?id=123\nURL cho biết lấy dữ liệu ở đâu và bằng cách nào.\nLớp URL trong Java Lớp URL cho phép chương trình Java:\nPhân tích các thành phần của URL Kết nối tới server Đọc dữ liệu từ Internet Ví dụ minh họa:\n1 URL url = new URL(\u0026#34;https://www.example.com\u0026#34;); Ý nghĩa của việc quản lý địa chỉ kết nối mạng Hiểu rõ cách quản lý địa chỉ mạng giúp:\nTránh kết nối sai server Chuẩn bị đúng địa chỉ cho Socket TCP/UDP Hiểu cách Web Crawler hoạt động Nắm vững mô hình Client – Server Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm địa chỉ kết nối mạng Biết vai trò của DNS và IPv4 Nắm được cách Java làm việc với InetAddress Hiểu cấu trúc và vai trò của URL Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-4/","summary":"Tìm hiểu cách Java quản lý địa chỉ mạng thông qua InetAddress, URL, URLConnection và DNS.","title":"Bài 4: Quản lý địa chỉ kết nối mạng trong Java"},{"content":"Trong lập trình mạng, TCP Socket là cơ chế quan trọng nhất để xây dựng các ứng dụng Client – Server có độ tin cậy cao.\nBài học này giúp bạn hiểu TCP là gì, vì sao cần TCP, và cách Java triển khai TCP thông qua Socket và ServerSocket.\nĐây là bước chuyển tiếp trực tiếp từ kiến thức địa chỉ mạng (IP, DNS, URL) sang giao tiếp dữ liệu thực tế giữa các chương trình.\nTCP là gì? TCP (Transmission Control Protocol) là giao thức truyền thông hướng kết nối, đảm bảo dữ liệu được truyền:\nĐúng thứ tự Đầy đủ Không bị mất mát Không bị trùng lặp Trước khi truyền dữ liệu, TCP yêu cầu thiết lập kết nối giữa hai bên, và chỉ khi kết nối thành công thì dữ liệu mới được trao đổi.\nVì sao sử dụng TCP? TCP được sử dụng khi ứng dụng yêu cầu độ tin cậy cao, ví dụ:\nỨng dụng chat Ứng dụng client–server Truyền file Game online theo lượt Hệ thống ngân hàng, thương mại điện tử TCP cung cấp các cơ chế quan trọng:\nĐảm bảo dữ liệu: gói tin bị mất sẽ được gửi lại Kiểm soát lỗi: phát hiện và sửa lỗi trong quá trình truyền Kiểm soát luồng: tránh làm quá tải phía nhận Giao tiếp hai chiều: cho phép gửi và nhận dữ liệu đồng thời Cơ chế hoạt động của TCP Quá trình giao tiếp TCP gồm ba giai đoạn chính:\nThiết lập kết nối (Bắt tay 3 bước – Three-way Handshake) Truyền dữ liệu Giải phóng kết nối Nhờ cơ chế này, TCP đảm bảo rằng hai bên luôn sẵn sàng trước khi truyền và kết thúc an toàn sau khi hoàn tất.\nMô hình Client – Server Các ứng dụng TCP thường hoạt động theo mô hình Client – Server.\nServer:\nChạy trước Lắng nghe yêu cầu kết nối Cung cấp dịch vụ Trả kết quả cho client Client:\nChạy sau Chủ động kết nối tới server Gửi yêu cầu Nhận phản hồi từ server Quá trình giao tiếp gồm:\nClient gửi yêu cầu Server xử lý Server trả kết quả cho client Socket trong Java Trong Java, Socket đại diện cho điểm cuối giao tiếp giữa client và server khi sử dụng TCP.\nSocket cho phép:\nGửi dữ liệu tới server Nhận dữ liệu từ server Giao tiếp hai chiều thông qua luồng nhập/xuất Ví dụ minh họa tạo Socket phía client:\n1 Socket socket = new Socket(\u0026#34;localhost\u0026#34;, 8080); ServerSocket trong Java ServerSocket được sử dụng ở phía server để:\nMở một cổng lắng nghe Chờ client kết nối Chấp nhận kết nối và tạo Socket giao tiếp ServerSocket đóng vai trò như cửa ngõ, cho phép các client kết nối vào server.\nVí dụ minh họa:\n1 ServerSocket server = new ServerSocket(8080); Luồng dữ liệu trong TCP Socket Sau khi kết nối TCP được thiết lập, client và server trao đổi dữ liệu thông qua các luồng:\nInputStream: dùng để đọc dữ liệu từ socket OutputStream: dùng để ghi dữ liệu vào socket Luồng dữ liệu này hoạt động tương tự như I/O Stream đã học ở bài trước,\nnhưng nguồn và đích là mạng thay vì file hay bàn phím.\nVí dụ ứng dụng: Trò chơi Oẳn Tù Tì Một bài tập tiêu biểu sử dụng TCP Socket là trò chơi Oẳn Tù Tì theo mô hình Client – Server.\nĐặc điểm Server quản lý luật chơi và điểm số Hai client gửi lựa chọn (kéo – búa – bao) Server xác định kết quả và gửi lại cho client Dữ liệu được truyền qua TCP để đảm bảo chính xác Thông qua bài tập này, sinh viên hiểu rõ:\nCách thiết lập kết nối TCP Cách trao đổi dữ liệu giữa nhiều client Cách xử lý lỗi mạng và ngoại lệ Ý nghĩa của lập trình TCP Socket Việc nắm vững TCP Socket giúp bạn:\nHiểu bản chất giao tiếp mạng Xây dựng hệ thống Client – Server thực tế Chuẩn bị cho các bài nâng cao như: Đa tuyến (Multi-thread) Socket UDP Java RMI Ứng dụng mạng phân tán Kết luận Qua bài học này, bạn đã:\nHiểu TCP là gì và vì sao cần TCP Nắm được mô hình Client – Server Biết vai trò của Socket và ServerSocket trong Java Hiểu cách dữ liệu được truyền qua TCP Chuẩn bị nền tảng cho các bài học UDP và xử lý đồng thời tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-5/","summary":"Giải thích mô hình Client–Server và cách lập trình Socket TCP trong Java – nền tảng cho giao tiếp mạng tin cậy.","title":"Bài 5: Lập trình Socket TCP trong Java"},{"content":"#Trong lập trình mạng, không phải lúc nào ứng dụng cũng cần độ tin cậy tuyệt đối như TCP.\nTrong nhiều trường hợp, điều quan trọng hơn là tốc độ truyền nhanh và độ trễ thấp.\nBài học này giới thiệu UDP Socket – cơ chế truyền dữ liệu không kết nối, được sử dụng rộng rãi trong các ứng dụng thời gian thực.\nUDP là gì? UDP (User Datagram Protocol) là giao thức truyền thông không hướng kết nối.\nĐiều này có nghĩa là:\nKhông thiết lập kết nối trước khi truyền Không đảm bảo dữ liệu đến nơi Không đảm bảo thứ tự gói tin Không tự động gửi lại gói tin bị mất UDP gửi dữ liệu theo từng datagram (gói tin độc lập).\nSo sánh TCP và UDP TCP UDP Có kết nối Không kết nối Đảm bảo dữ liệu Không đảm bảo Truyền theo luồng Truyền theo gói Độ trễ cao hơn Độ trễ thấp Phù hợp dữ liệu quan trọng Phù hợp dữ liệu thời gian thực Khi nào sử dụng UDP? UDP được sử dụng khi:\nCần truyền nhanh Có thể chấp nhận mất gói tin Dữ liệu được gửi liên tục Ví dụ ứng dụng UDP:\nTruyền video, audio trực tuyến Game online thời gian thực Chat broadcast DNS Multicast, streaming UDP Socket trong Java Java hỗ trợ UDP thông qua hai lớp chính:\nDatagramSocket: quản lý socket UDP DatagramPacket: đại diện cho gói dữ liệu UDP UDP không phân biệt client hay server rõ ràng như TCP.\nMỗi chương trình chỉ cần một DatagramSocket để gửi và nhận dữ liệu.\nDatagramPacket là gì? DatagramPacket là gói dữ liệu UDP, bao gồm:\nDữ liệu cần gửi Địa chỉ IP đích Số hiệu cổng Mỗi lần gửi hoặc nhận dữ liệu, UDP làm việc với một DatagramPacket riêng biệt.\nLuồng dữ liệu trong UDP UDP không có luồng InputStream / OutputStream như TCP.\nQuy trình truyền dữ liệu UDP:\nTạo DatagramSocket Tạo DatagramPacket chứa dữ liệu Gửi packet đi Nhận packet về Đọc dữ liệu từ packet Mỗi gói tin là độc lập, không liên quan đến các gói khác.\nĐặc điểm quan trọng của UDP Không kiểm soát lỗi Không kiểm soát luồng Không bắt tay kết nối Gửi nhanh, xử lý đơn giản Phù hợp truyền broadcast và multicast Chính vì vậy, UDP thường được dùng khi tốc độ quan trọng hơn độ chính xác tuyệt đối.\nÝ nghĩa của lập trình Socket UDP Nắm vững UDP giúp bạn:\nHiểu bản chất truyền dữ liệu không kết nối Xây dựng ứng dụng thời gian thực Phân biệt rõ TCP và UDP trong thiết kế hệ thống Chuẩn bị cho các chủ đề nâng cao như: Multicast UDP Java RMI Hệ thống phân tán Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính, UDP được sử dụng trong:\nSocket UDP Multicast Ứng dụng truyền tin nhanh Game, streaming, broadcast Hiểu UDP giúp bạn chọn đúng giao thức cho từng bài toán thực tế.\nKết luận Qua bài học này, bạn đã:\nHiểu UDP là gì và cơ chế hoạt động Phân biệt được TCP và UDP Biết vai trò của DatagramSocket và DatagramPacket Hiểu cách truyền dữ liệu không kết nối Chuẩn bị nền tảng cho bài Multicast UDP \u0026amp; Java RMI tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-6/","summary":"Giải thích giao thức UDP và cách Java lập trình Socket UDP – nền tảng cho truyền dữ liệu nhanh, không kết nối.","title":"Bài 6: Lập trình Socket UDP trong Java"},{"content":"Trong các ứng dụng mạng thực tế, đặc biệt là Server, chương trình thường phải xử lý nhiều yêu cầu cùng lúc.\nNếu chỉ sử dụng một luồng thực thi, server sẽ bị tắc nghẽn, các client phải chờ đợi và hiệu năng giảm nghiêm trọng.\nVì vậy, lập trình đa tuyến (Multithreading) và xử lý đồng thời (Concurrency) là kỹ thuật bắt buộc trong lập trình mạng.\nTuyến (Thread) là gì? Thread là một dòng điều khiển tuần tự bên trong một chương trình.\nMột chương trình (process) có thể chứa nhiều thread Các thread có thể chạy đồng thời Mỗi thread thực hiện một nhiệm vụ riêng Thread không phải là một chương trình độc lập,\nnó luôn thuộc về một process.\nProcess và Thread Process:\nCó không gian bộ nhớ riêng Chạy độc lập với process khác Tạo và chuyển đổi tốn nhiều tài nguyên Thread:\nChia sẻ bộ nhớ với các thread khác trong cùng process Tạo nhanh hơn process Chuyển đổi nhanh hơn Nhờ thread, chương trình có thể thực hiện nhiều công việc cùng lúc trong cùng một ứng dụng.\nVì sao cần lập trình đa tuyến? Lập trình đa tuyến giúp:\nTăng hiệu suất và khả năng đáp ứng Tận dụng thời gian chờ đợi (I/O, mạng, tải file) Chia nhỏ tác vụ và xử lý đồng thời Cải thiện trải nghiệm người dùng Trong lập trình mạng, đa tuyến cho phép server phục vụ nhiều client cùng lúc.\nThực thi Thread trong Java Trong Java, một thread bắt đầu chạy khi gọi phương thức start().\nKhi thread chạy, JVM thực thi mã trong phương thức run() Khi run() kết thúc, thread cũng kết thúc Một thread không thể start lại, muốn chạy lại phải tạo thread mới Thread cần có điều kiện dừng rõ ràng để tránh chạy vô hạn.\nỨng dụng đa tuyến trong lập trình mạng Ứng dụng Chat đa tuyến Một ví dụ tiêu biểu của đa tuyến trong mạng là ứng dụng chat nhiều client – một server.\nĐặc điểm:\nServer chấp nhận nhiều client kết nối cùng lúc Mỗi client được xử lý bởi một thread riêng Tin nhắn từ một client được gửi tới tất cả client khác Server ghi lại nội dung chat vào file log Thông qua ví dụ này, sinh viên hiểu rõ:\nCách server xử lý nhiều kết nối đồng thời Cách phối hợp giữa socket và thread Vai trò của đa tuyến trong ứng dụng mạng Xử lý đồng thời (Concurrency) Xử lý đồng thời xảy ra khi nhiều thread:\nChạy cùng lúc Truy cập tài nguyên chung (biến, file, bộ nhớ) Nếu không kiểm soát tốt, chương trình có thể gặp các vấn đề nghiêm trọng.\nRace Condition Race Condition xảy ra khi:\nNhiều thread cùng truy cập và thay đổi dữ liệu chung Kết quả phụ thuộc vào thứ tự thực thi không xác định Điều này có thể dẫn đến:\nDữ liệu sai lệch Kết quả không nhất quán Lỗi khó phát hiện Đồng bộ hóa (Synchronization) Để tránh race condition, Java cung cấp cơ chế đồng bộ hóa:\nĐảm bảo chỉ một thread được truy cập tài nguyên tại một thời điểm Giữ cho dữ liệu luôn nhất quán Đồng bộ hóa là nền tảng để xây dựng các ứng dụng an toàn và ổn định khi chạy đa tuyến.\nCác vấn đề thường gặp trong xử lý đồng thời Một số vấn đề phổ biến:\nRace condition: tranh chấp dữ liệu Deadlock: các thread chờ nhau vô hạn Livelock: các thread liên tục phản ứng nhưng không tiến triển Starvation: thread không bao giờ được cấp tài nguyên Những vấn đề này khiến lập trình đa tuyến trở nên phức tạp và khó debug.\nLập lịch Thread trong Java Java sử dụng cơ chế lập lịch theo độ ưu tiên:\nMỗi thread có độ ưu tiên từ MIN_PRIORITY đến MAX_PRIORITY JVM chọn thread runnable có độ ưu tiên cao hơn để chạy Thread có thể nhường CPU cho thread khác bằng cách gọi yield() Việc hiểu cơ chế lập lịch giúp lập trình viên thiết kế thread hợp lý hơn.\nÝ nghĩa của lập trình đa tuyến và xử lý đồng thời Nắm vững kiến thức bài này giúp bạn:\nXây dựng server xử lý nhiều client Viết ứng dụng mạng hiệu năng cao Tránh lỗi tranh chấp dữ liệu Chuẩn bị cho các chủ đề nâng cao như: Server đa tuyến Pooling Threads Multicast UDP Java RMI Hệ thống phân tán Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm thread và multithreading Phân biệt process và thread Biết vai trò của đa tuyến trong lập trình mạng Hiểu các vấn đề xử lý đồng thời và race condition Chuẩn bị nền tảng cho các bài học nâng cao tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-7/","summary":"Giải thích lập trình đa tuyến và xử lý đồng thời trong Java – nền tảng cho các ứng dụng mạng nhiều client và hệ thống phân tán.","title":"Bài 7: Lập trình đa tuyến và xử lý đồng thời trong Java"},{"content":"Buổi 8 gồm 2 phần lớn:\nMulticast UDP: gửi dữ liệu từ một nguồn đến nhiều máy nhận cùng lúc (1 → N). Java RMI: gọi phương thức từ xa giữa các ứng dụng Java như gọi hàm bình thường (Remote Method Invocation). Đây là các kỹ thuật thường gặp trong streaming, trò chuyện nhóm, giám sát từ xa và hệ thống phân tán.\n1) UDP Multicast Unicast, Broadcast và Multicast Trong mạng máy tính có 3 kiểu gửi dữ liệu phổ biến:\nUnicast: 1 nguồn → 1 đích\nVí dụ: bạn mở một trang web, server trả dữ liệu cho riêng bạn.\nBroadcast: 1 nguồn → tất cả máy trong mạng nội bộ\nVí dụ: một thông báo phát cho toàn bộ LAN.\nMulticast: 1 nguồn → một nhóm máy đã đăng ký nhận dữ liệu\nVí dụ: server phát stream video cho nhóm người xem cùng lúc.\nMulticast là cách truyền hiệu quả khi nhiều máy cùng cần nhận một nội dung giống nhau.\nTại sao dùng UDP Multicast? UDP Multicast thường được dùng vì:\nHiệu suất cao: gửi 1 lần nhưng nhiều máy nhận → giảm tải mạng và server. Đơn giản, nhanh: UDP là kiểu “gửi và quên”, không phải chờ xác nhận. Tối ưu trong LAN: phù hợp môi trường mạng nội bộ (Local Area Network). Rất hợp streaming: audio/video cần tốc độ và độ trễ thấp hơn là đảm bảo tuyệt đối. Ứng dụng của Multicast Multicast có thể dùng trong:\nTruyền phát multimedia trực tiếp (audio/video streaming) Trò chuyện nhóm, hội thoại nhóm Quảng bá thông tin cấu hình mạng và cập nhật trong hệ thống mạng Game nhiều người chơi (gửi trạng thái game cho nhiều người) Phát thông tin trạng thái/cảnh báo cho nhiều thiết bị Phát tán cập nhật phần mềm trong mạng nội bộ Địa chỉ Multicast IPv4 Trong IPv4:\nClass D là dải địa chỉ dành cho multicast Dải địa chỉ multicast thường gặp: 224.0.0.0 – 239.255.255.255 Một số nhóm multicast hay được nhắc:\n224.0.0.1: tất cả host trong local subnet Multicast Group là gì? Multicast hoạt động theo “nhóm”:\nMột multicast group giống như một kênh. Máy nào muốn nhận dữ liệu phải tham gia nhóm (join group). Khi rời nhóm thì không nhận dữ liệu nữa. Multicast trong Java Java hỗ trợ multicast qua lớp:\njava.net.MulticastSocket (kế thừa từ DatagramSocket) Một số thao tác quan trọng:\njoinGroup(...): tham gia nhóm multicast leaveGroup(...): rời nhóm multicast setTimeToLive(ttl): đặt TTL (thời gian sống của gói tin, qua bao nhiêu router) Quy trình gửi dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket Tham gia nhóm multicast Tạo DatagramPacket chứa dữ liệu + địa chỉ nhóm + port Gửi packet Rời nhóm Ví dụ minh họa (ngắn, chỉ để hiểu):\n1 2 3 4 5 6 7 8 9 10 11 12 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(); socket.joinGroup(group); socket.setTimeToLive(5); byte[] data = \u0026#34;Hello Multicast\u0026#34;.getBytes(); DatagramPacket packet = new DatagramPacket(data, data.length, group, 9876); socket.send(packet); socket.leaveGroup(group); socket.close(); Quy trình nhận dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket lắng nghe trên port Tham gia nhóm multicast Tạo DatagramPacket rỗng để nhận dữ liệu Gọi receive() để chờ gói tin gửi về Đọc dữ liệu từ packet Rời nhóm và đóng socket Ví dụ minh họa (ngắn):\n1 2 3 4 5 6 7 8 9 10 11 12 13 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(9876); socket.joinGroup(group); byte[] buf = new byte[1024]; DatagramPacket packet = new DatagramPacket(buf, buf.length); socket.receive(packet); String msg = new String(packet.getData(), 0, packet.getLength()); System.out.println(\u0026#34;Received: \u0026#34; + msg); socket.leaveGroup(group); socket.close(); 2) Java RMI Java RMI là gì? RMI (Remote Method Invocation) cho phép chương trình Java:\nGọi phương thức của một đối tượng nằm trên máy khác Cảm giác giống như gọi method trong cùng chương trình Nói đơn giản:\nClient gọi: remoteObject.sum(1,2) Server thực thi thật và trả kết quả về cho client RMI giúp che giấu toàn bộ chi tiết mạng phía sau, người lập trình chỉ tập trung vào logic.\nVì sao dùng Java RMI? Java RMI được sử dụng vì:\nTích hợp sẵn trong Java, dễ triển khai nếu cả client và server đều dùng Java Gọi phương thức từ xa đơn giản như gọi hàm thông thường Hỗ trợ dữ liệu phức tạp: đối tượng, mảng, class tự định nghĩa Tự động xử lý giao tiếp mạng thông qua cơ chế stub / skeleton Dựa trên TCP/IP nên tương đối ổn định và tin cậy Hạn chế của Java RMI Một số điểm hạn chế cần lưu ý:\nPhụ thuộc Java: chủ yếu phù hợp Java ↔ Java Thiết kế dịch vụ phức tạp vẫn cần tổ chức tốt (đặc biệt khi dùng callback) Quản lý phiên và kết nối không mạnh như các giải pháp hiện đại Bảo mật cần cấu hình cẩn thận trong môi trường thực tế Ý tưởng kiến trúc RMI (hiểu nhanh) Trong Java RMI có các thành phần chính:\nRemote Interface\nKhai báo các phương thức cho phép gọi từ xa\nServer Implementation\nLớp cài đặt interface, chứa logic xử lý thật\nRMI Registry\nNơi đăng ký service để client tìm thấy server\nClient\nTìm (lookup) service trong registry và gọi phương thức\nCác bước triển khai RMI (tóm tắt) Định nghĩa Remote Interface Cài đặt interface bằng một class server (remote object) Viết chương trình server: tạo object và bind vào registry Viết chương trình client: lookup registry và gọi method Chạy RMI registry, chạy server, sau đó chạy client Ví dụ ứng dụng RMI Một số ví dụ thường gặp:\nTính tổng 2 số từ xa Dịch vụ quản lý tài khoản ATM Dịch vụ giám sát nhiệt độ có callback (server gọi ngược lại client) Bài tập gợi ý theo đúng nội dung buổi 8 BT8.01: Mô phỏng streaming video\n(1 server phát, nhiều client nhận dữ liệu)\nBT8.02: Server quản lý tài khoản ATM bằng RMI\n(thêm user, đăng nhập, gửi/rút tiền, lưu lịch sử giao dịch)\nKết luận Qua bài học này, bạn đã:\nHiểu sự khác nhau giữa Unicast, Broadcast và Multicast Nắm được vì sao Multicast UDP phù hợp cho truyền dữ liệu nhóm và streaming Biết cách Java hỗ trợ multicast qua MulticastSocket Hiểu Java RMI và cơ chế gọi phương thức từ xa Chuẩn bị nền tảng cho các bài ứng dụng mạng phân tán và đồ án học phần ","permalink":"http://localhost:1313/blog/bai-viet-8/","summary":"Giải thích Multicast UDP (gửi 1-n) và Java RMI (gọi phương thức từ xa) – nền tảng cho ứng dụng nhóm và hệ phân tán.","title":"Bài 8: Multicast UDP và Java RMI"},{"content":"Sau khi hoàn thành các bài về TCP, UDP, đa tuyến và xử lý đồng thời,\nchúng ta đã có đủ nền tảng để xây dựng một ứng dụng mạng hoàn chỉnh.\nBài học này giúp bạn xâu chuỗi toàn bộ kiến thức đã học,\nhiểu rõ mỗi công nghệ dùng trong trường hợp nào,\nvà cách thiết kế một hệ thống mạng đúng tư duy kỹ sư.\nNhìn lại các mô hình giao tiếp mạng đã học Trong lập trình mạng, các ứng dụng thường được xây dựng dựa trên mô hình Client – Server.\nClient: gửi yêu cầu, nhập dữ liệu, hiển thị kết quả Server: xử lý logic, quản lý dữ liệu, trả kết quả Tùy bài toán, ta lựa chọn giao thức và mô hình phù hợp.\nSo sánh TCP, UDP và Multicast TCP – Giao tiếp tin cậy TCP phù hợp khi:\nCần đảm bảo dữ liệu đúng và đủ Cần kết nối ổn định, hai chiều Ví dụ: chat, truyền file, game theo lượt, hệ thống ngân hàng Đặc trưng:\nCó bắt tay 3 bước Có kiểm soát lỗi, kiểm soát luồng Tốn tài nguyên hơn UDP UDP – Giao tiếp nhanh, không kết nối UDP phù hợp khi:\nƯu tiên tốc độ Chấp nhận mất gói Ví dụ: game thời gian thực, streaming, cảm biến Đặc trưng:\nKhông kết nối Không đảm bảo thứ tự Ít độ trễ UDP Multicast – Truyền dữ liệu nhóm Multicast được dùng khi:\nMột nguồn → nhiều người nhận Dữ liệu giống nhau cho tất cả client Ví dụ: livestream, thông báo hệ thống, truyền trạng thái Ưu điểm:\nGiảm tải server Tiết kiệm băng thông Phù hợp mạng LAN Vai trò của đa tuyến (Multithreading) Trong thực tế, server không thể xử lý từng client một cách tuần tự.\nĐa tuyến giúp:\nNhiều client kết nối cùng lúc Không client nào bị “đóng băng” Tăng khả năng mở rộng hệ thống Ví dụ:\nServer chat: mỗi client là một thread Server TCP: mỗi socket được xử lý riêng Thiết kế một ứng dụng mạng hoàn chỉnh Khi thiết kế, cần xác định rõ:\nGiao thức: TCP hay UDP? Mô hình: 1–1, 1–n, n–n? Đồng thời hay tuần tự? Client gửi gì? Server xử lý gì? Một thiết kế tốt luôn:\nPhân tách rõ giao tiếp – xử lý – dữ liệu Dễ mở rộng Dễ bảo trì Liên hệ với đồ án học phần Các đồ án như:\nChat đa tuyến Oẳn Tù Tì client–server Streaming UDP Dịch vụ RMI Đều là sự kết hợp của các kiến thức đã học,\nkhông phải nội dung mới.\nKết luận Qua bài học này, bạn đã:\nHệ thống lại toàn bộ kiến thức lập trình mạng Hiểu rõ khi nào dùng TCP, UDP, Multicast Nắm được vai trò của đa tuyến Biết cách tư duy thiết kế một ứng dụng mạng hoàn chỉnh Đây là bước chuẩn bị quan trọng trước khi vận dụng toàn bộ kiến thức vào một hệ thống thực tế.\n","permalink":"http://localhost:1313/blog/bai-viet-9/","summary":"Tổng hợp kiến thức TCP, UDP, đa tuyến và cách thiết kế ứng dụng mạng Client–Server hoàn chỉnh.","title":"Bài 9: Tổng hợp kiến thức \u0026 thiết kế ứng dụng mạng"},{"content":"Bài cuối cùng của học phần không nhằm giới thiệu công nghệ mới,\nmà tập trung vào cách vận dụng kiến thức đã học vào thực tế.\nĐây là giai đoạn chuyển từ:\n“Biết dùng” → “Biết thiết kế” → “Biết đánh giá hệ thống”\nTư duy vận dụng kiến thức Một ứng dụng mạng hoàn chỉnh cần trả lời được các câu hỏi:\nVì sao chọn TCP mà không phải UDP? Vì sao cần đa tuyến? Server có chịu được nhiều client không? Hệ thống có mở rộng được không? Đây chính là tư duy kỹ sư, không phải chỉ “chạy được là xong”.\nĐánh giá một ứng dụng mạng Khi hoàn thiện hệ thống, cần xem xét:\n1. Tính đúng đắn Dữ liệu có truyền đúng không? Có mất gói không? Có xử lý lỗi không? 2. Tính đồng thời Nhiều client có dùng chung được không? Có bị treo server không? Có race condition không? 3. Hiệu năng Độ trễ thế nào? Server có bị quá tải không? Có tách luồng hợp lý không? Liên hệ với các mô hình phân tán Các hệ thống đã học là nền tảng cho:\nHệ thống client–server lớn Ứng dụng phân tán Microservices Cloud services Java RMI, TCP đa tuyến hay UDP Multicast\nđều là những viên gạch đầu tiên.\nTừ học phần đến thực tế Sau học phần này, bạn có thể tiếp cận:\nWebSocket REST API gRPC Message Queue (Kafka, RabbitMQ) Hệ thống realtime Tư duy lập trình mạng không thay đổi, chỉ công nghệ thay đổi.\nTổng kết toàn bộ học phần Qua toàn bộ chuỗi bài, bạn đã:\nHiểu cách dữ liệu đi qua mạng Làm việc với TCP, UDP, Multicast Xử lý đa tuyến và đồng thời Tiếp cận lập trình phân tán với RMI Có tư duy thiết kế hệ thống mạng Lời kết Lập trình mạng không chỉ là code socket,\nmà là hiểu cách các hệ thống nói chuyện với nhau.\nNếu bạn hiểu được điều đó,\nbạn đã vượt xa mức “học để qua môn”.\n","permalink":"http://localhost:1313/blog/bai-viet-10/","summary":"Vận dụng toàn bộ kiến thức lập trình mạng để xây dựng, đánh giá và hoàn thiện một ứng dụng thực tế.","title":"Bài 10: Hoàn thiện \u0026 vận dụng lập trình mạng"},{"content":"Lời mở đầu Có những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\nMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\nHọc tập Những năm đại học trôi qua nhanh hơn mình từng nghĩ. Ngày mới bước chân vào giảng đường, mình vẫn còn khá mơ hồ về ngành học, về tương lai, về chính bản thân mình sẽ trở thành ai sau bốn năm. Nhưng rồi từng môn học, từng bài tập nhóm, từng đồ án kéo mình lại gần hơn với cách một hệ thống được hình thành và vận hành.\nHệ thống thông tin không chỉ là lập trình, cũng không đơn thuần là công nghệ. Đó là câu chuyện về con người, quy trình và dữ liệu. Mình học cách đặt câu hỏi, học cách lắng nghe yêu cầu, học cách vẽ ra những sơ đồ tưởng chừng khô khan nhưng lại chứa rất nhiều suy nghĩ phía sau. Dần dần, mình nhận ra mình thích phần “hiểu vấn đề” hơn là chỉ chăm chăm vào lời giải.\nĐịnh hướng Ở thời điểm hiện tại, mình đang định hướng theo con đường Business Analyst (BA). Mình hứng thú với vai trò đứng giữa – không quá xa kỹ thuật, cũng không tách rời nghiệp vụ. Đó là nơi cần sự rõ ràng trong tư duy, sự kiên nhẫn trong giao tiếp và khả năng chuyển hóa những điều mơ hồ thành thứ có thể triển khai được.\nMình không nghĩ BA là một vị trí “nhẹ nhàng” hay “an toàn”. Ngược lại, đó là công việc đòi hỏi phải học rất nhiều, sai rất nhiều và sửa rất nhiều. Nhưng chính điều đó khiến mình thấy phù hợp. Mình muốn hiểu hệ thống trước khi xây dựng nó, muốn biết vì sao người ta see cần một chức năng, chứ không chỉ là nó được viết như thế nào.\nBlog Blog này ra đời khá tự nhiên, giống như một cuốn sổ mở rộng hơn là một trang thể hiện điều gì đó to tát. Mình viết để nhớ, để hệ thống lại những gì đã học, và đôi khi là để sắp xếp lại suy nghĩ của chính mình.\nỞ đây có thể là kiến thức về Hệ thống thông tin, về phân tích nghiệp vụ, về lập trình, hoặc đơn giản là những trải nghiệm học tập và va chạm trong quá trình làm đồ án, làm việc nhóm, và chuẩn bị bước ra môi trường thực tế. Mình không mong mọi thứ phải hoàn hảo, chỉ mong nó thật và có ích cho ai đó đang đi trên con đường tương tự.\nLời kết Mình đang ở một giai đoạn chưa thể gọi là trưởng thành, nhưng cũng không còn quá non nớt. Vẫn đang học, vẫn đang thử, vẫn đang sai và sửa mỗi ngày. Nếu có một điều mình mong giữ được lâu nhất, thì đó là sự tò mò và tinh thần học hỏi – những thứ giúp mình không đứng yên giữa rất nhiều lựa chọn ngoài kia.\nCảm ơn bạn đã ghé qua và đọc những dòng này. Hy vọng ở một thời điểm nào đó, những chia sẻ nhỏ ở đây sẽ chạm đến bạn – dù chỉ là một chút. \u0026ldquo;Học để chia sẻ, chia sẻ để học nhiều hơn.\u0026rdquo;\nLiên hệ Nếu bạn muốn gửi cho mình vài dòng trao đổi,\nbạn có thể liên hệ với mình qua Email hoặc GitHub ,Facebook dưới đây.\nCảm ơn bạn đã ghé thăm blog! ","permalink":"http://localhost:1313/about/","summary":"\u003ch2 id=\"lời-mở-đầu\"\u003eLời mở đầu\u003c/h2\u003e\n\u003cp\u003eCó những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\u003c/p\u003e\n\u003cp\u003eMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\u003c/p\u003e","title":"Giới thiệu"},{"content":"Trong lập trình mạng, trước khi kết nối, ta phải biết \u0026ldquo;địa chỉ nhà\u0026rdquo; (IP) của mình và đối phương. Java cung cấp class\nHình 1.1: Hiệu ứng Dunning–Kruger – mức độ tự tin thay đổi theo kinh nghiệm học tập\nGóc nhìn học tập: Hiệu ứng Dunning–Kruger InetAddress để làm việc này.\nĐịa chỉ IP là gì trong lập trình mạng? IP (Internet Protocol Address) là địa chỉ định danh của một thiết bị khi tham gia vào mạng máy tính.\nTrong lập trình mạng, IP đóng vai trò quan trọng trong việc:\nXác định máy gửi và máy nhận Định tuyến dữ liệu trong quá trình truyền thông Thiết lập kết nối giữa các tiến trình chạy trên những máy khác nhau Nếu không có địa chỉ IP, các máy tính sẽ không thể nhận biết và giao tiếp với nhau.\nVai trò của lớp InetAddress trong Java Lớp InetAddress đại diện cho một địa chỉ IP trong Java.\nThông qua lớp này, lập trình viên có thể:\nLấy địa chỉ IP của máy đang chạy chương trình Lấy tên máy (hostname) Phân giải tên miền sang địa chỉ IP Chuẩn bị thông tin để tạo Socket hoặc ServerSocket Hầu hết các chương trình lập trình mạng trong Java đều sử dụng InetAddress ở bước khởi tạo.\nPhân tích ý nghĩa các lệnh trong chương trình InetAddress.getLocalHost()\n→ Trả về đối tượng đại diện cho máy cục bộ (localhost).\ngetHostName()\n→ Lấy tên máy do hệ điều hành hoặc mạng gán.\ngetHostAddress()\n→ Lấy địa chỉ IP của máy dưới dạng chuỗi.\nViệc in ra hostname và IP giúp:\nKiểm tra cấu hình mạng Xác định đúng máy khi kết nối Client – Server Debug lỗi mạng Một số lưu ý khi lấy IP trong Java Khi máy không kết nối mạng, IP có thể là 127.0.0.1 Khi máy có nhiều card mạng (WiFi, LAN, VPN), IP trả về có thể không phải IP Internet Trên Server, hostname và IP thường khác máy cá nhân Ứng dụng thực tế Việc xác định IP của máy thường được sử dụng trong:\nChương trình Client – Server Thông báo IP Server cho Client kết nối Kiểm tra kết nối mạng LAN Ghi log và giám sát hệ thống Kết luận Qua bài học này, ta đã:\nHiểu vai trò của địa chỉ IP trong lập trình mạng Biết cách lấy IP bằng lớp InetAddress Chuẩn bị nền tảng cho các kỹ thuật TCP, UDP và RMI Liên hệ với học phần Lập trình Mạng máy tính Bài học này nằm trong nội dung mở đầu của học phần Lập trình Mạng máy tính (CMP180) tại Trường Đại học Công nghệ TP.HCM (HUTECH).\nTrong lộ trình môn học, sinh viên sẽ lần lượt tiếp cận các nội dung:\nKiến thức nền tảng về mạng và lập trình mạng Quản lý luồng nhập xuất (I/O) Quản lý địa chỉ và kết nối mạng Lập trình Socket TCP và UDP Xử lý đa tuyến, đa luồng Multicast UDP và Java RMI Thực hiện đồ án học phần cá nhân Mục tiêu của bài học Thông qua Bài 1, sinh viên sẽ:\nLàm quen với môi trường lập trình mạng bằng Java Hiểu được vai trò của địa chỉ IP trong giao tiếp mạng Biết cách sử dụng lớp InetAddress để lấy IP và hostname Chuẩn bị nền tảng cho các bài học tiếp theo về Socket và Server – Client ","permalink":"http://localhost:1313/blog/bai-viet-1/","summary":"GIỚI THIỆU HỌC PHẦN.","title":"Bài 1: Tổng quan khoá học"},{"content":"Trong lập trình mạng, nếu IP được xem như địa chỉ nhà của một máy tính trong mạng,\nthì Port (cổng) chính là số hiệu dùng để xác định chương trình hoặc dịch vụ cụ thể đang chạy trên máy đó.\nMột máy tính có thể chạy đồng thời nhiều ứng dụng mạng như Web Server, Database Server, Game Server hoặc Chat Server.\nMỗi ứng dụng bắt buộc phải gắn với một Port riêng để hệ điều hành có thể phân biệt và định tuyến dữ liệu chính xác.\nPort nằm ở đâu trong mô hình TCP/IP? Trong bộ giao thức TCP/IP, Port thuộc về Transport Layer (Tầng giao vận) và được sử dụng bởi hai giao thức chính là TCP và UDP.\nĐịa chỉ IP xác định máy nào sẽ nhận dữ liệu Port xác định ứng dụng nào trên máy đó sẽ xử lý dữ liệu Sự kết hợp giữa IP + Port tạo thành một Socket, là điểm cuối (endpoint) của quá trình giao tiếp mạng.\nCác loại Port phổ biến Port được đánh số từ 0 đến 65535 và được chia thành ba nhóm chính:\nInternet và các End Devices Trước khi tìm hiểu về Port, cần hiểu Internet được cấu thành từ hàng tỷ thiết bị đầu cuối (End Devices) như máy tính, điện thoại, máy chủ và các thiết bị IoT.\nCác thiết bị này kết nối với nhau thông qua nhiều lớp mạng khác nhau, và mỗi thiết bị khi tham gia giao tiếp mạng đều cần có địa chỉ IP và Port để định danh. Hình 2.1: Sơ đồ minh họa Internet và các thiết bị đầu cuối (End Devices) kết nối thông qua các mạng truy cập và mạng lõi.\nTrong quá trình giao tiếp mạng, một thiết bị không chỉ cần địa chỉ IP để xác định vị trí trong mạng, mà còn cần Port để xác định chính xác ứng dụng hoặc dịch vụ đang lắng nghe trên thiết bị đó.\nDo đó, Port đóng vai trò như “điểm tiếp nhận” (endpoint) cho các tiến trình mạng chạy trên cùng một máy.\nMô hình các tầng giao thức TCP/IP Để hiểu rõ Port hoạt động ở đâu và vì sao Server cần Port, ta cần nắm được mô hình giao thức TCP/IP – nền tảng của mọi ứng dụng mạng hiện nay.\nHình 2.2: Mô hình các tầng giao thức TCP/IP và các giao thức tiêu biểu tương ứng với từng tầng.\nTrong mô hình TCP/IP, địa chỉ IP hoạt động ở tầng Internet, giúp xác định thiết bị trong mạng.\nTrong khi đó, Port hoạt động ở tầng Transport (TCP/UDP), giúp xác định chính xác ứng dụng hoặc dịch vụ đang giao tiếp trên thiết bị đó.\nWell-known Ports (0 – 1023) Được dùng cho các dịch vụ chuẩn:\nPort 80: HTTP Port 443: HTTPS Port 21: FTP Port 25: SMTP Registered Ports (1024 – 49151) Thường dùng cho các ứng dụng phổ biến:\nPort 3306: MySQL Port 8080: Web Server thay thế port 80 Dynamic / Private Ports (49152 – 65535) Do hệ điều hành cấp phát tạm thời cho Client khi giao tiếp mạng.\nVì sao Server thường dùng cổng 8080? Cổng 8080 rất phổ biến trong quá trình phát triển và học tập vì:\nTránh xung đột với cổng 80 đang được hệ điều hành chiếm dụng Không cần quyền Administrator khi mở Server Phù hợp cho các Web Server thử nghiệm như: Apache Tomcat Spring Boot Node.js Lỗi thường gặp: “Address already in use” Lỗi này xảy ra khi Server cố gắng mở một Port đã bị chương trình khác chiếm dụng.\nNguyên nhân phổ biến:\nServer cũ chưa được tắt Port đang được dùng bởi dịch vụ khác Chạy nhiều Server cùng lúc Cách khắc phục:\nĐổi sang Port khác (ví dụ: 8080 → 9090) Kiểm tra Port đang sử dụng trong hệ điều hành Đảm bảo chỉ có một Server chạy tại một thời điểm Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), khái niệm Port sẽ được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Xây dựng mô hình Client – Server Java RMI và Multicast Việc hiểu rõ Port là nền tảng bắt buộc trước khi triển khai các ứng dụng mạng thực tế.\nKết luận Qua bài học này, ta đã:\nHiểu được Port là gì và vai trò của Port trong lập trình mạng Nắm được mối quan hệ giữa IP, Port và Socket Giải thích được lý do Server thường sử dụng cổng 8080 Chuẩn bị kiến thức nền cho các bài học tiếp theo về TCP và UDP ","permalink":"http://localhost:1313/blog/bai-viet-2/","summary":"MẠNG MÁY TÍNH \u0026amp; INTERNET.","title":"Bài 2: Kiến thức nền tảng?"},{"content":"Trong lập trình Java, luồng nhập xuất (Input / Output Streams) đóng vai trò trung gian giúp chương trình đọc và ghi dữ liệu từ nhiều nguồn khác nhau như bàn phím, file, console, bộ nhớ và sau này là socket mạng.\nHiểu rõ cơ chế luồng nhập xuất là bước nền bắt buộc trước khi đi vào lập trình Socket TCP, UDP hay Java RMI.\nLuồng (Stream) là gì? Luồng (Stream) là dòng dữ liệu di chuyển\ntừ nguồn → chương trình hoặc từ chương trình → đích.\nKhi Java đọc hoặc ghi dữ liệu, dữ liệu không đi trực tiếp mà luôn được đóng gói và truyền qua luồng.\nLuồng nhập xuất là gì? Luồng nhập xuất là cơ chế cho phép chương trình:\nNhận dữ liệu từ bên ngoài (Input) Ghi dữ liệu ra bên ngoài (Output) Luồng có thể kết nối với nhiều nguồn và đích khác nhau:\nFile Bàn phím Màn hình (console) Bộ nhớ Kết nối mạng (TCP / UDP) Dữ liệu trong luồng tồn tại dưới những dạng nào? Trong Java, dữ liệu trong luồng tồn tại dưới hai dạng chính:\nLuồng byte Luồng ký tự Việc chọn đúng loại luồng ảnh hưởng trực tiếp đến hiệu năng và tính chính xác của chương trình.\nLuồng byte trong Java Đặc điểm Dữ liệu được xử lý dưới dạng nhị phân Phù hợp với: File nhị phân Ảnh, video Socket mạng Dữ liệu phức tạp Các lớp gốc InputStream – luồng đọc byte OutputStream – luồng ghi byte Cả hai đều là lớp trừu tượng (abstract).\nCác luồng byte đọc phổ biến FileInputStream – đọc byte từ file ByteArrayInputStream – đọc từ mảng byte PipedInputStream – đọc từ luồng pipe Các luồng byte ghi phổ biến FileOutputStream – ghi byte vào file ByteArrayOutputStream – ghi vào mảng byte PipedOutputStream – ghi vào luồng pipe Mô hình đọc/ghi dữ liệu với Stream Quy trình chung khi làm việc với luồng:\nTạo đối tượng Stream Gắn Stream với nguồn hoặc đích Đọc/ghi dữ liệu trong vòng lặp Đóng Stream sau khi hoàn tất Luồng ký tự trong Java Đặc điểm Xử lý dữ liệu dạng Unicode Phù hợp với: File văn bản Chuỗi Dữ liệu hiển thị cho người dùng Các lớp gốc Reader – luồng đọc ký tự Writer – luồng ghi ký tự Các luồng ký tự đọc phổ biến FileReader – đọc file văn bản BufferedReader – đọc có bộ đệm StringReader – đọc chuỗi CharArrayReader – đọc mảng ký tự Các luồng ký tự ghi phổ biến FileWriter – ghi vào file văn bản BufferedWriter – ghi có bộ đệm PrintWriter – ghi dữ liệu dạng dễ đọc StringWriter – ghi chuỗi Luồng lọc dữ liệu (Filtered Streams) Luồng lọc dùng để chuyển đổi dữ liệu từ dạng byte/ký tự sang các kiểu dữ liệu khác.\nCác luồng lọc phổ biến DataInputStream DataOutputStream Cho phép đọc/ghi các kiểu dữ liệu nguyên thủy:\nint float double boolean char Đây là cầu nối giữa luồng thô và dữ liệu có kiểu trong Java.\nLưu trạng thái đối tượng – Serialization Serialization là gì? Serialization (chuỗi hóa) là quá trình chuyển đối tượng Java thành luồng byte để:\nLưu vào file Truyền qua mạng Phục hồi lại sau này Deserialization Ngược lại, Deserialization (giải chuỗi) là quá trình:\nĐọc byte Tái tạo lại đối tượng ban đầu Đây là nền tảng cho:\nLưu dữ liệu chương trình Java RMI Truyền object qua mạng Try-with-resources (TWR) Java hỗ trợ Try-with-resources để:\nTự động đóng stream Tránh rò rỉ tài nguyên Code gọn và an toàn hơn So với try-catch truyền thống, TWR:\nÍt lỗi hơn Dễ bảo trì hơn Được khuyến khích sử dụng Các lỗi I/O thường gặp Khi làm việc với luồng, một số exception phổ biến là:\nFileNotFoundException IOException EOFException UnsupportedEncodingException FileAlreadyExistsException AccessDeniedException SocketException MalformedURLException SerializationException InvalidPathException Việc bắt và xử lý exception đúng cách là yêu cầu bắt buộc trong lập trình Java.\nLiên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), luồng nhập xuất được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Truyền dữ liệu Client – Server Java RMI Multicast UDP Không hiểu I/O Stream → không thể làm mạng đúng cách.\nKết luận Qua bài học này, ta đã:\nHiểu khái niệm luồng nhập xuất trong Java Phân biệt luồng byte và luồng ký tự Nắm được cách đọc/ghi dữ liệu với Stream Biết vai trò của Serialization và Filtered Streams Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo Khi xử lý các tác vụ mạng (như gọi API), người mới học JS hay viết code lồng nhau kiểu này:\n1 2 3 4 5 6 7 8 9 10 // Cực hình Callback Hell getData(function(a) { getMoreData(a, function(b) { getMoreData(b, function(c) { getMoreData(c, function(d) { console.log(d); }); }); }); }); ","permalink":"http://localhost:1313/blog/bai-viet-3/","summary":"Tổng quan về Input/Output Streams trong Java – nền tảng cho xử lý file, console và lập trình mạng.","title":"Bài 3: Quản lý luồng nhập xuất trong Java"},{"content":"Trong lập trình mạng, trước khi chương trình có thể gửi hoặc nhận dữ liệu, điều quan trọng nhất là xác định đúng địa chỉ kết nối mạng. Nếu xác định sai địa chỉ, chương trình sẽ không thể giao tiếp, dù phần xử lý dữ liệu có đúng đến đâu.\nBài học này giúp bạn hiểu cách Java làm việc với địa chỉ IP, tên miền (DNS) và URL. Đây là nền tảng bắt buộc trước khi đi vào Socket TCP, UDP, Web Crawler và Java RMI.\nĐịa chỉ kết nối mạng là gì? Địa chỉ kết nối mạng là thông tin dùng để xác định máy nào trong mạng cần giao tiếp và dịch vụ nào trên máy đó sẽ xử lý dữ liệu.\nTrong Internet, địa chỉ kết nối thường bao gồm:\nĐịa chỉ IP Tên miền (Domain Name) Cổng (Port) Giao thức (Protocol) DNS – Domain Name System Hình 4.1 – Mô hình hoạt động của DNS (Domain Name System) Client gửi yêu cầu phân giải tên miền đến DNS Server, DNS trả về địa chỉ IP tương ứng để client kết nối đến server đích.*\nCon người dễ nhớ tên miền hơn các dãy số IP.\nDNS (Domain Name System) có nhiệm vụ ánh xạ tên miền sang địa chỉ IP, giúp client tìm đúng server cần kết nối.\nVí dụ:\ngoogle.com tương ứng với nhiều địa chỉ IP khác nhau www.cs.yale.edu tương ứng với 128.36.229.30 Nhờ DNS, người dùng không cần ghi nhớ địa chỉ IP khi truy cập Internet.\nĐịa chỉ IPv4 IPv4 là dạng địa chỉ phổ biến, gồm 32 bit, thường được viết thành bốn nhóm số.\nVí dụ:\n192.168.1.1 8.8.8.8 Một số dải địa chỉ đặc biệt:\n127.x.x.x là loopback (localhost) 224.0.0.0 – 239.255.255.255 là multicast Lớp InetAddress trong Java Java cung cấp lớp InetAddress để làm việc với địa chỉ IP và DNS.\nLớp này thường được dùng để:\nPhân giải tên miền sang IP Kiểm tra loại địa chỉ Kiểm tra khả năng kết nối mạng Ví dụ minh họa:\n1 InetAddress address = InetAddress.getByName(\u0026#34;google.com\u0026#34;); URL – Uniform Resource Locator URL được dùng để xác định tài nguyên trên Internet như trang web, file hoặc dịch vụ.\nMột URL đầy đủ thường bao gồm các thành phần sau:\nGiao thức (Protocol) Tên miền (Host) Cổng (Port) Đường dẫn (Path) Chuỗi truy vấn (Query) Ví dụ một URL đầy đủ: https://www.hutech.edu.vn/admission?id=123\nURL cho biết lấy dữ liệu ở đâu và bằng cách nào.\nLớp URL trong Java Lớp URL cho phép chương trình Java:\nPhân tích các thành phần của URL Kết nối tới server Đọc dữ liệu từ Internet Ví dụ minh họa:\n1 URL url = new URL(\u0026#34;https://www.example.com\u0026#34;); Ý nghĩa của việc quản lý địa chỉ kết nối mạng Hiểu rõ cách quản lý địa chỉ mạng giúp:\nTránh kết nối sai server Chuẩn bị đúng địa chỉ cho Socket TCP/UDP Hiểu cách Web Crawler hoạt động Nắm vững mô hình Client – Server Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm địa chỉ kết nối mạng Biết vai trò của DNS và IPv4 Nắm được cách Java làm việc với InetAddress Hiểu cấu trúc và vai trò của URL Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-4/","summary":"Tìm hiểu cách Java quản lý địa chỉ mạng thông qua InetAddress, URL, URLConnection và DNS.","title":"Bài 4: Quản lý địa chỉ kết nối mạng trong Java"},{"content":"Trong lập trình mạng, TCP Socket là cơ chế quan trọng nhất để xây dựng các ứng dụng Client – Server có độ tin cậy cao.\nBài học này giúp bạn hiểu TCP là gì, vì sao cần TCP, và cách Java triển khai TCP thông qua Socket và ServerSocket.\nĐây là bước chuyển tiếp trực tiếp từ kiến thức địa chỉ mạng (IP, DNS, URL) sang giao tiếp dữ liệu thực tế giữa các chương trình.\nTCP là gì? TCP (Transmission Control Protocol) là giao thức truyền thông hướng kết nối, đảm bảo dữ liệu được truyền:\nĐúng thứ tự Đầy đủ Không bị mất mát Không bị trùng lặp Trước khi truyền dữ liệu, TCP yêu cầu thiết lập kết nối giữa hai bên, và chỉ khi kết nối thành công thì dữ liệu mới được trao đổi.\nVì sao sử dụng TCP? TCP được sử dụng khi ứng dụng yêu cầu độ tin cậy cao, ví dụ:\nỨng dụng chat Ứng dụng client–server Truyền file Game online theo lượt Hệ thống ngân hàng, thương mại điện tử TCP cung cấp các cơ chế quan trọng:\nĐảm bảo dữ liệu: gói tin bị mất sẽ được gửi lại Kiểm soát lỗi: phát hiện và sửa lỗi trong quá trình truyền Kiểm soát luồng: tránh làm quá tải phía nhận Giao tiếp hai chiều: cho phép gửi và nhận dữ liệu đồng thời Cơ chế hoạt động của TCP Quá trình giao tiếp TCP gồm ba giai đoạn chính:\nThiết lập kết nối (Bắt tay 3 bước – Three-way Handshake) Truyền dữ liệu Giải phóng kết nối Nhờ cơ chế này, TCP đảm bảo rằng hai bên luôn sẵn sàng trước khi truyền và kết thúc an toàn sau khi hoàn tất.\nMô hình Client – Server Các ứng dụng TCP thường hoạt động theo mô hình Client – Server.\nServer:\nChạy trước Lắng nghe yêu cầu kết nối Cung cấp dịch vụ Trả kết quả cho client Client:\nChạy sau Chủ động kết nối tới server Gửi yêu cầu Nhận phản hồi từ server Quá trình giao tiếp gồm:\nClient gửi yêu cầu Server xử lý Server trả kết quả cho client Socket trong Java Trong Java, Socket đại diện cho điểm cuối giao tiếp giữa client và server khi sử dụng TCP.\nSocket cho phép:\nGửi dữ liệu tới server Nhận dữ liệu từ server Giao tiếp hai chiều thông qua luồng nhập/xuất Ví dụ minh họa tạo Socket phía client:\n1 Socket socket = new Socket(\u0026#34;localhost\u0026#34;, 8080); ServerSocket trong Java ServerSocket được sử dụng ở phía server để:\nMở một cổng lắng nghe Chờ client kết nối Chấp nhận kết nối và tạo Socket giao tiếp ServerSocket đóng vai trò như cửa ngõ, cho phép các client kết nối vào server.\nVí dụ minh họa:\n1 ServerSocket server = new ServerSocket(8080); Luồng dữ liệu trong TCP Socket Sau khi kết nối TCP được thiết lập, client và server trao đổi dữ liệu thông qua các luồng:\nInputStream: dùng để đọc dữ liệu từ socket OutputStream: dùng để ghi dữ liệu vào socket Luồng dữ liệu này hoạt động tương tự như I/O Stream đã học ở bài trước,\nnhưng nguồn và đích là mạng thay vì file hay bàn phím.\nVí dụ ứng dụng: Trò chơi Oẳn Tù Tì Một bài tập tiêu biểu sử dụng TCP Socket là trò chơi Oẳn Tù Tì theo mô hình Client – Server.\nĐặc điểm Server quản lý luật chơi và điểm số Hai client gửi lựa chọn (kéo – búa – bao) Server xác định kết quả và gửi lại cho client Dữ liệu được truyền qua TCP để đảm bảo chính xác Thông qua bài tập này, sinh viên hiểu rõ:\nCách thiết lập kết nối TCP Cách trao đổi dữ liệu giữa nhiều client Cách xử lý lỗi mạng và ngoại lệ Ý nghĩa của lập trình TCP Socket Việc nắm vững TCP Socket giúp bạn:\nHiểu bản chất giao tiếp mạng Xây dựng hệ thống Client – Server thực tế Chuẩn bị cho các bài nâng cao như: Đa tuyến (Multi-thread) Socket UDP Java RMI Ứng dụng mạng phân tán Kết luận Qua bài học này, bạn đã:\nHiểu TCP là gì và vì sao cần TCP Nắm được mô hình Client – Server Biết vai trò của Socket và ServerSocket trong Java Hiểu cách dữ liệu được truyền qua TCP Chuẩn bị nền tảng cho các bài học UDP và xử lý đồng thời tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-5/","summary":"Giải thích mô hình Client–Server và cách lập trình Socket TCP trong Java – nền tảng cho giao tiếp mạng tin cậy.","title":"Bài 5: Lập trình Socket TCP trong Java"},{"content":"#Trong lập trình mạng, không phải lúc nào ứng dụng cũng cần độ tin cậy tuyệt đối như TCP.\nTrong nhiều trường hợp, điều quan trọng hơn là tốc độ truyền nhanh và độ trễ thấp.\nBài học này giới thiệu UDP Socket – cơ chế truyền dữ liệu không kết nối, được sử dụng rộng rãi trong các ứng dụng thời gian thực.\nUDP là gì? UDP (User Datagram Protocol) là giao thức truyền thông không hướng kết nối.\nĐiều này có nghĩa là:\nKhông thiết lập kết nối trước khi truyền Không đảm bảo dữ liệu đến nơi Không đảm bảo thứ tự gói tin Không tự động gửi lại gói tin bị mất UDP gửi dữ liệu theo từng datagram (gói tin độc lập).\nSo sánh TCP và UDP TCP UDP Có kết nối Không kết nối Đảm bảo dữ liệu Không đảm bảo Truyền theo luồng Truyền theo gói Độ trễ cao hơn Độ trễ thấp Phù hợp dữ liệu quan trọng Phù hợp dữ liệu thời gian thực Khi nào sử dụng UDP? UDP được sử dụng khi:\nCần truyền nhanh Có thể chấp nhận mất gói tin Dữ liệu được gửi liên tục Ví dụ ứng dụng UDP:\nTruyền video, audio trực tuyến Game online thời gian thực Chat broadcast DNS Multicast, streaming UDP Socket trong Java Java hỗ trợ UDP thông qua hai lớp chính:\nDatagramSocket: quản lý socket UDP DatagramPacket: đại diện cho gói dữ liệu UDP UDP không phân biệt client hay server rõ ràng như TCP.\nMỗi chương trình chỉ cần một DatagramSocket để gửi và nhận dữ liệu.\nDatagramPacket là gì? DatagramPacket là gói dữ liệu UDP, bao gồm:\nDữ liệu cần gửi Địa chỉ IP đích Số hiệu cổng Mỗi lần gửi hoặc nhận dữ liệu, UDP làm việc với một DatagramPacket riêng biệt.\nLuồng dữ liệu trong UDP UDP không có luồng InputStream / OutputStream như TCP.\nQuy trình truyền dữ liệu UDP:\nTạo DatagramSocket Tạo DatagramPacket chứa dữ liệu Gửi packet đi Nhận packet về Đọc dữ liệu từ packet Mỗi gói tin là độc lập, không liên quan đến các gói khác.\nĐặc điểm quan trọng của UDP Không kiểm soát lỗi Không kiểm soát luồng Không bắt tay kết nối Gửi nhanh, xử lý đơn giản Phù hợp truyền broadcast và multicast Chính vì vậy, UDP thường được dùng khi tốc độ quan trọng hơn độ chính xác tuyệt đối.\nÝ nghĩa của lập trình Socket UDP Nắm vững UDP giúp bạn:\nHiểu bản chất truyền dữ liệu không kết nối Xây dựng ứng dụng thời gian thực Phân biệt rõ TCP và UDP trong thiết kế hệ thống Chuẩn bị cho các chủ đề nâng cao như: Multicast UDP Java RMI Hệ thống phân tán Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính, UDP được sử dụng trong:\nSocket UDP Multicast Ứng dụng truyền tin nhanh Game, streaming, broadcast Hiểu UDP giúp bạn chọn đúng giao thức cho từng bài toán thực tế.\nKết luận Qua bài học này, bạn đã:\nHiểu UDP là gì và cơ chế hoạt động Phân biệt được TCP và UDP Biết vai trò của DatagramSocket và DatagramPacket Hiểu cách truyền dữ liệu không kết nối Chuẩn bị nền tảng cho bài Multicast UDP \u0026amp; Java RMI tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-6/","summary":"Giải thích giao thức UDP và cách Java lập trình Socket UDP – nền tảng cho truyền dữ liệu nhanh, không kết nối.","title":"Bài 6: Lập trình Socket UDP trong Java"},{"content":"Trong các ứng dụng mạng thực tế, đặc biệt là Server, chương trình thường phải xử lý nhiều yêu cầu cùng lúc.\nNếu chỉ sử dụng một luồng thực thi, server sẽ bị tắc nghẽn, các client phải chờ đợi và hiệu năng giảm nghiêm trọng.\nVì vậy, lập trình đa tuyến (Multithreading) và xử lý đồng thời (Concurrency) là kỹ thuật bắt buộc trong lập trình mạng.\nTuyến (Thread) là gì? Thread là một dòng điều khiển tuần tự bên trong một chương trình.\nMột chương trình (process) có thể chứa nhiều thread Các thread có thể chạy đồng thời Mỗi thread thực hiện một nhiệm vụ riêng Thread không phải là một chương trình độc lập,\nnó luôn thuộc về một process.\nProcess và Thread Process:\nCó không gian bộ nhớ riêng Chạy độc lập với process khác Tạo và chuyển đổi tốn nhiều tài nguyên Thread:\nChia sẻ bộ nhớ với các thread khác trong cùng process Tạo nhanh hơn process Chuyển đổi nhanh hơn Nhờ thread, chương trình có thể thực hiện nhiều công việc cùng lúc trong cùng một ứng dụng.\nVì sao cần lập trình đa tuyến? Lập trình đa tuyến giúp:\nTăng hiệu suất và khả năng đáp ứng Tận dụng thời gian chờ đợi (I/O, mạng, tải file) Chia nhỏ tác vụ và xử lý đồng thời Cải thiện trải nghiệm người dùng Trong lập trình mạng, đa tuyến cho phép server phục vụ nhiều client cùng lúc.\nThực thi Thread trong Java Trong Java, một thread bắt đầu chạy khi gọi phương thức start().\nKhi thread chạy, JVM thực thi mã trong phương thức run() Khi run() kết thúc, thread cũng kết thúc Một thread không thể start lại, muốn chạy lại phải tạo thread mới Thread cần có điều kiện dừng rõ ràng để tránh chạy vô hạn.\nỨng dụng đa tuyến trong lập trình mạng Ứng dụng Chat đa tuyến Một ví dụ tiêu biểu của đa tuyến trong mạng là ứng dụng chat nhiều client – một server.\nĐặc điểm:\nServer chấp nhận nhiều client kết nối cùng lúc Mỗi client được xử lý bởi một thread riêng Tin nhắn từ một client được gửi tới tất cả client khác Server ghi lại nội dung chat vào file log Thông qua ví dụ này, sinh viên hiểu rõ:\nCách server xử lý nhiều kết nối đồng thời Cách phối hợp giữa socket và thread Vai trò của đa tuyến trong ứng dụng mạng Xử lý đồng thời (Concurrency) Xử lý đồng thời xảy ra khi nhiều thread:\nChạy cùng lúc Truy cập tài nguyên chung (biến, file, bộ nhớ) Nếu không kiểm soát tốt, chương trình có thể gặp các vấn đề nghiêm trọng.\nRace Condition Race Condition xảy ra khi:\nNhiều thread cùng truy cập và thay đổi dữ liệu chung Kết quả phụ thuộc vào thứ tự thực thi không xác định Điều này có thể dẫn đến:\nDữ liệu sai lệch Kết quả không nhất quán Lỗi khó phát hiện Đồng bộ hóa (Synchronization) Để tránh race condition, Java cung cấp cơ chế đồng bộ hóa:\nĐảm bảo chỉ một thread được truy cập tài nguyên tại một thời điểm Giữ cho dữ liệu luôn nhất quán Đồng bộ hóa là nền tảng để xây dựng các ứng dụng an toàn và ổn định khi chạy đa tuyến.\nCác vấn đề thường gặp trong xử lý đồng thời Một số vấn đề phổ biến:\nRace condition: tranh chấp dữ liệu Deadlock: các thread chờ nhau vô hạn Livelock: các thread liên tục phản ứng nhưng không tiến triển Starvation: thread không bao giờ được cấp tài nguyên Những vấn đề này khiến lập trình đa tuyến trở nên phức tạp và khó debug.\nLập lịch Thread trong Java Java sử dụng cơ chế lập lịch theo độ ưu tiên:\nMỗi thread có độ ưu tiên từ MIN_PRIORITY đến MAX_PRIORITY JVM chọn thread runnable có độ ưu tiên cao hơn để chạy Thread có thể nhường CPU cho thread khác bằng cách gọi yield() Việc hiểu cơ chế lập lịch giúp lập trình viên thiết kế thread hợp lý hơn.\nÝ nghĩa của lập trình đa tuyến và xử lý đồng thời Nắm vững kiến thức bài này giúp bạn:\nXây dựng server xử lý nhiều client Viết ứng dụng mạng hiệu năng cao Tránh lỗi tranh chấp dữ liệu Chuẩn bị cho các chủ đề nâng cao như: Server đa tuyến Pooling Threads Multicast UDP Java RMI Hệ thống phân tán Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm thread và multithreading Phân biệt process và thread Biết vai trò của đa tuyến trong lập trình mạng Hiểu các vấn đề xử lý đồng thời và race condition Chuẩn bị nền tảng cho các bài học nâng cao tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-7/","summary":"Giải thích lập trình đa tuyến và xử lý đồng thời trong Java – nền tảng cho các ứng dụng mạng nhiều client và hệ thống phân tán.","title":"Bài 7: Lập trình đa tuyến và xử lý đồng thời trong Java"},{"content":"Buổi 8 gồm 2 phần lớn:\nMulticast UDP: gửi dữ liệu từ một nguồn đến nhiều máy nhận cùng lúc (1 → N). Java RMI: gọi phương thức từ xa giữa các ứng dụng Java như gọi hàm bình thường (Remote Method Invocation). Đây là các kỹ thuật thường gặp trong streaming, trò chuyện nhóm, giám sát từ xa và hệ thống phân tán.\n1) UDP Multicast Unicast, Broadcast và Multicast Trong mạng máy tính có 3 kiểu gửi dữ liệu phổ biến:\nUnicast: 1 nguồn → 1 đích\nVí dụ: bạn mở một trang web, server trả dữ liệu cho riêng bạn.\nBroadcast: 1 nguồn → tất cả máy trong mạng nội bộ\nVí dụ: một thông báo phát cho toàn bộ LAN.\nMulticast: 1 nguồn → một nhóm máy đã đăng ký nhận dữ liệu\nVí dụ: server phát stream video cho nhóm người xem cùng lúc.\nMulticast là cách truyền hiệu quả khi nhiều máy cùng cần nhận một nội dung giống nhau.\nTại sao dùng UDP Multicast? UDP Multicast thường được dùng vì:\nHiệu suất cao: gửi 1 lần nhưng nhiều máy nhận → giảm tải mạng và server. Đơn giản, nhanh: UDP là kiểu “gửi và quên”, không phải chờ xác nhận. Tối ưu trong LAN: phù hợp môi trường mạng nội bộ (Local Area Network). Rất hợp streaming: audio/video cần tốc độ và độ trễ thấp hơn là đảm bảo tuyệt đối. Ứng dụng của Multicast Multicast có thể dùng trong:\nTruyền phát multimedia trực tiếp (audio/video streaming) Trò chuyện nhóm, hội thoại nhóm Quảng bá thông tin cấu hình mạng và cập nhật trong hệ thống mạng Game nhiều người chơi (gửi trạng thái game cho nhiều người) Phát thông tin trạng thái/cảnh báo cho nhiều thiết bị Phát tán cập nhật phần mềm trong mạng nội bộ Địa chỉ Multicast IPv4 Trong IPv4:\nClass D là dải địa chỉ dành cho multicast Dải địa chỉ multicast thường gặp: 224.0.0.0 – 239.255.255.255 Một số nhóm multicast hay được nhắc:\n224.0.0.1: tất cả host trong local subnet Multicast Group là gì? Multicast hoạt động theo “nhóm”:\nMột multicast group giống như một kênh. Máy nào muốn nhận dữ liệu phải tham gia nhóm (join group). Khi rời nhóm thì không nhận dữ liệu nữa. Multicast trong Java Java hỗ trợ multicast qua lớp:\njava.net.MulticastSocket (kế thừa từ DatagramSocket) Một số thao tác quan trọng:\njoinGroup(...): tham gia nhóm multicast leaveGroup(...): rời nhóm multicast setTimeToLive(ttl): đặt TTL (thời gian sống của gói tin, qua bao nhiêu router) Quy trình gửi dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket Tham gia nhóm multicast Tạo DatagramPacket chứa dữ liệu + địa chỉ nhóm + port Gửi packet Rời nhóm Ví dụ minh họa (ngắn, chỉ để hiểu):\n1 2 3 4 5 6 7 8 9 10 11 12 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(); socket.joinGroup(group); socket.setTimeToLive(5); byte[] data = \u0026#34;Hello Multicast\u0026#34;.getBytes(); DatagramPacket packet = new DatagramPacket(data, data.length, group, 9876); socket.send(packet); socket.leaveGroup(group); socket.close(); Quy trình nhận dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket lắng nghe trên port Tham gia nhóm multicast Tạo DatagramPacket rỗng để nhận dữ liệu Gọi receive() để chờ gói tin gửi về Đọc dữ liệu từ packet Rời nhóm và đóng socket Ví dụ minh họa (ngắn):\n1 2 3 4 5 6 7 8 9 10 11 12 13 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(9876); socket.joinGroup(group); byte[] buf = new byte[1024]; DatagramPacket packet = new DatagramPacket(buf, buf.length); socket.receive(packet); String msg = new String(packet.getData(), 0, packet.getLength()); System.out.println(\u0026#34;Received: \u0026#34; + msg); socket.leaveGroup(group); socket.close(); 2) Java RMI Java RMI là gì? RMI (Remote Method Invocation) cho phép chương trình Java:\nGọi phương thức của một đối tượng nằm trên máy khác Cảm giác giống như gọi method trong cùng chương trình Nói đơn giản:\nClient gọi: remoteObject.sum(1,2) Server thực thi thật và trả kết quả về cho client RMI giúp che giấu toàn bộ chi tiết mạng phía sau, người lập trình chỉ tập trung vào logic.\nVì sao dùng Java RMI? Java RMI được sử dụng vì:\nTích hợp sẵn trong Java, dễ triển khai nếu cả client và server đều dùng Java Gọi phương thức từ xa đơn giản như gọi hàm thông thường Hỗ trợ dữ liệu phức tạp: đối tượng, mảng, class tự định nghĩa Tự động xử lý giao tiếp mạng thông qua cơ chế stub / skeleton Dựa trên TCP/IP nên tương đối ổn định và tin cậy Hạn chế của Java RMI Một số điểm hạn chế cần lưu ý:\nPhụ thuộc Java: chủ yếu phù hợp Java ↔ Java Thiết kế dịch vụ phức tạp vẫn cần tổ chức tốt (đặc biệt khi dùng callback) Quản lý phiên và kết nối không mạnh như các giải pháp hiện đại Bảo mật cần cấu hình cẩn thận trong môi trường thực tế Ý tưởng kiến trúc RMI (hiểu nhanh) Trong Java RMI có các thành phần chính:\nRemote Interface\nKhai báo các phương thức cho phép gọi từ xa\nServer Implementation\nLớp cài đặt interface, chứa logic xử lý thật\nRMI Registry\nNơi đăng ký service để client tìm thấy server\nClient\nTìm (lookup) service trong registry và gọi phương thức\nCác bước triển khai RMI (tóm tắt) Định nghĩa Remote Interface Cài đặt interface bằng một class server (remote object) Viết chương trình server: tạo object và bind vào registry Viết chương trình client: lookup registry và gọi method Chạy RMI registry, chạy server, sau đó chạy client Ví dụ ứng dụng RMI Một số ví dụ thường gặp:\nTính tổng 2 số từ xa Dịch vụ quản lý tài khoản ATM Dịch vụ giám sát nhiệt độ có callback (server gọi ngược lại client) Bài tập gợi ý theo đúng nội dung buổi 8 BT8.01: Mô phỏng streaming video\n(1 server phát, nhiều client nhận dữ liệu)\nBT8.02: Server quản lý tài khoản ATM bằng RMI\n(thêm user, đăng nhập, gửi/rút tiền, lưu lịch sử giao dịch)\nKết luận Qua bài học này, bạn đã:\nHiểu sự khác nhau giữa Unicast, Broadcast và Multicast Nắm được vì sao Multicast UDP phù hợp cho truyền dữ liệu nhóm và streaming Biết cách Java hỗ trợ multicast qua MulticastSocket Hiểu Java RMI và cơ chế gọi phương thức từ xa Chuẩn bị nền tảng cho các bài ứng dụng mạng phân tán và đồ án học phần ","permalink":"http://localhost:1313/blog/bai-viet-8/","summary":"Giải thích Multicast UDP (gửi 1-n) và Java RMI (gọi phương thức từ xa) – nền tảng cho ứng dụng nhóm và hệ phân tán.","title":"Bài 8: Multicast UDP và Java RMI"},{"content":"Sau khi hoàn thành các bài về TCP, UDP, đa tuyến và xử lý đồng thời,\nchúng ta đã có đủ nền tảng để xây dựng một ứng dụng mạng hoàn chỉnh.\nBài học này giúp bạn xâu chuỗi toàn bộ kiến thức đã học,\nhiểu rõ mỗi công nghệ dùng trong trường hợp nào,\nvà cách thiết kế một hệ thống mạng đúng tư duy kỹ sư.\nNhìn lại các mô hình giao tiếp mạng đã học Trong lập trình mạng, các ứng dụng thường được xây dựng dựa trên mô hình Client – Server.\nClient: gửi yêu cầu, nhập dữ liệu, hiển thị kết quả Server: xử lý logic, quản lý dữ liệu, trả kết quả Tùy bài toán, ta lựa chọn giao thức và mô hình phù hợp.\nSo sánh TCP, UDP và Multicast TCP – Giao tiếp tin cậy TCP phù hợp khi:\nCần đảm bảo dữ liệu đúng và đủ Cần kết nối ổn định, hai chiều Ví dụ: chat, truyền file, game theo lượt, hệ thống ngân hàng Đặc trưng:\nCó bắt tay 3 bước Có kiểm soát lỗi, kiểm soát luồng Tốn tài nguyên hơn UDP UDP – Giao tiếp nhanh, không kết nối UDP phù hợp khi:\nƯu tiên tốc độ Chấp nhận mất gói Ví dụ: game thời gian thực, streaming, cảm biến Đặc trưng:\nKhông kết nối Không đảm bảo thứ tự Ít độ trễ UDP Multicast – Truyền dữ liệu nhóm Multicast được dùng khi:\nMột nguồn → nhiều người nhận Dữ liệu giống nhau cho tất cả client Ví dụ: livestream, thông báo hệ thống, truyền trạng thái Ưu điểm:\nGiảm tải server Tiết kiệm băng thông Phù hợp mạng LAN Vai trò của đa tuyến (Multithreading) Trong thực tế, server không thể xử lý từng client một cách tuần tự.\nĐa tuyến giúp:\nNhiều client kết nối cùng lúc Không client nào bị “đóng băng” Tăng khả năng mở rộng hệ thống Ví dụ:\nServer chat: mỗi client là một thread Server TCP: mỗi socket được xử lý riêng Thiết kế một ứng dụng mạng hoàn chỉnh Khi thiết kế, cần xác định rõ:\nGiao thức: TCP hay UDP? Mô hình: 1–1, 1–n, n–n? Đồng thời hay tuần tự? Client gửi gì? Server xử lý gì? Một thiết kế tốt luôn:\nPhân tách rõ giao tiếp – xử lý – dữ liệu Dễ mở rộng Dễ bảo trì Liên hệ với đồ án học phần Các đồ án như:\nChat đa tuyến Oẳn Tù Tì client–server Streaming UDP Dịch vụ RMI Đều là sự kết hợp của các kiến thức đã học,\nkhông phải nội dung mới.\nKết luận Qua bài học này, bạn đã:\nHệ thống lại toàn bộ kiến thức lập trình mạng Hiểu rõ khi nào dùng TCP, UDP, Multicast Nắm được vai trò của đa tuyến Biết cách tư duy thiết kế một ứng dụng mạng hoàn chỉnh Đây là bước chuẩn bị quan trọng trước khi vận dụng toàn bộ kiến thức vào một hệ thống thực tế.\n","permalink":"http://localhost:1313/blog/bai-viet-9/","summary":"Tổng hợp kiến thức TCP, UDP, đa tuyến và cách thiết kế ứng dụng mạng Client–Server hoàn chỉnh.","title":"Bài 9: Tổng hợp kiến thức \u0026 thiết kế ứng dụng mạng"},{"content":"Bài cuối cùng của học phần không nhằm giới thiệu công nghệ mới,\nmà tập trung vào cách vận dụng kiến thức đã học vào thực tế.\nĐây là giai đoạn chuyển từ:\n“Biết dùng” → “Biết thiết kế” → “Biết đánh giá hệ thống”\nTư duy vận dụng kiến thức Một ứng dụng mạng hoàn chỉnh cần trả lời được các câu hỏi:\nVì sao chọn TCP mà không phải UDP? Vì sao cần đa tuyến? Server có chịu được nhiều client không? Hệ thống có mở rộng được không? Đây chính là tư duy kỹ sư, không phải chỉ “chạy được là xong”.\nĐánh giá một ứng dụng mạng Khi hoàn thiện hệ thống, cần xem xét:\n1. Tính đúng đắn Dữ liệu có truyền đúng không? Có mất gói không? Có xử lý lỗi không? 2. Tính đồng thời Nhiều client có dùng chung được không? Có bị treo server không? Có race condition không? 3. Hiệu năng Độ trễ thế nào? Server có bị quá tải không? Có tách luồng hợp lý không? Liên hệ với các mô hình phân tán Các hệ thống đã học là nền tảng cho:\nHệ thống client–server lớn Ứng dụng phân tán Microservices Cloud services Java RMI, TCP đa tuyến hay UDP Multicast\nđều là những viên gạch đầu tiên.\nTừ học phần đến thực tế Sau học phần này, bạn có thể tiếp cận:\nWebSocket REST API gRPC Message Queue (Kafka, RabbitMQ) Hệ thống realtime Tư duy lập trình mạng không thay đổi, chỉ công nghệ thay đổi.\nTổng kết toàn bộ học phần Qua toàn bộ chuỗi bài, bạn đã:\nHiểu cách dữ liệu đi qua mạng Làm việc với TCP, UDP, Multicast Xử lý đa tuyến và đồng thời Tiếp cận lập trình phân tán với RMI Có tư duy thiết kế hệ thống mạng Lời kết Lập trình mạng không chỉ là code socket,\nmà là hiểu cách các hệ thống nói chuyện với nhau.\nNếu bạn hiểu được điều đó,\nbạn đã vượt xa mức “học để qua môn”.\n","permalink":"http://localhost:1313/blog/bai-viet-10/","summary":"Vận dụng toàn bộ kiến thức lập trình mạng để xây dựng, đánh giá và hoàn thiện một ứng dụng thực tế.","title":"Bài 10: Hoàn thiện \u0026 vận dụng lập trình mạng"},{"content":"Lời mở đầu Có những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\nMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\nHọc tập Những năm đại học trôi qua nhanh hơn mình từng nghĩ. Ngày mới bước chân vào giảng đường, mình vẫn còn khá mơ hồ về ngành học, về tương lai, về chính bản thân mình sẽ trở thành ai sau bốn năm. Nhưng rồi từng môn học, từng bài tập nhóm, từng đồ án kéo mình lại gần hơn với cách một hệ thống được hình thành và vận hành.\nHệ thống thông tin không chỉ là lập trình, cũng không đơn thuần là công nghệ. Đó là câu chuyện về con người, quy trình và dữ liệu. Mình học cách đặt câu hỏi, học cách lắng nghe yêu cầu, học cách vẽ ra những sơ đồ tưởng chừng khô khan nhưng lại chứa rất nhiều suy nghĩ phía sau. Dần dần, mình nhận ra mình thích phần “hiểu vấn đề” hơn là chỉ chăm chăm vào lời giải.\nĐịnh hướng Ở thời điểm hiện tại, mình đang định hướng theo con đường Business Analyst (BA). Mình hứng thú với vai trò đứng giữa – không quá xa kỹ thuật, cũng không tách rời nghiệp vụ. Đó là nơi cần sự rõ ràng trong tư duy, sự kiên nhẫn trong giao tiếp và khả năng chuyển hóa những điều mơ hồ thành thứ có thể triển khai được.\nMình không nghĩ BA là một vị trí “nhẹ nhàng” hay “an toàn”. Ngược lại, đó là công việc đòi hỏi phải học rất nhiều, sai rất nhiều và sửa rất nhiều. Nhưng chính điều đó khiến mình thấy phù hợp. Mình muốn hiểu hệ thống trước khi xây dựng nó, muốn biết vì sao người ta see cần một chức năng, chứ không chỉ là nó được viết như thế nào.\nBlog Blog này ra đời khá tự nhiên, giống như một cuốn sổ mở rộng hơn là một trang thể hiện điều gì đó to tát. Mình viết để nhớ, để hệ thống lại những gì đã học, và đôi khi là để sắp xếp lại suy nghĩ của chính mình.\nỞ đây có thể là kiến thức về Hệ thống thông tin, về phân tích nghiệp vụ, về lập trình, hoặc đơn giản là những trải nghiệm học tập và va chạm trong quá trình làm đồ án, làm việc nhóm, và chuẩn bị bước ra môi trường thực tế. Mình không mong mọi thứ phải hoàn hảo, chỉ mong nó thật và có ích cho ai đó đang đi trên con đường tương tự.\nLời kết Mình đang ở một giai đoạn chưa thể gọi là trưởng thành, nhưng cũng không còn quá non nớt. Vẫn đang học, vẫn đang thử, vẫn đang sai và sửa mỗi ngày. Nếu có một điều mình mong giữ được lâu nhất, thì đó là sự tò mò và tinh thần học hỏi – những thứ giúp mình không đứng yên giữa rất nhiều lựa chọn ngoài kia.\nCảm ơn bạn đã ghé qua và đọc những dòng này. Hy vọng ở một thời điểm nào đó, những chia sẻ nhỏ ở đây sẽ chạm đến bạn – dù chỉ là một chút. \u0026ldquo;Học để chia sẻ, chia sẻ để học nhiều hơn.\u0026rdquo;\nLiên hệ Nếu bạn muốn gửi cho mình vài dòng trao đổi,\nbạn có thể liên hệ với mình qua Email hoặc GitHub ,Facebook dưới đây.\nCảm ơn bạn đã ghé thăm blog! ","permalink":"http://localhost:1313/about/","summary":"\u003ch2 id=\"lời-mở-đầu\"\u003eLời mở đầu\u003c/h2\u003e\n\u003cp\u003eCó những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\u003c/p\u003e\n\u003cp\u003eMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\u003c/p\u003e","title":"Giới thiệu"},{"content":"Trong lập trình mạng, trước khi kết nối, ta phải biết \u0026ldquo;địa chỉ nhà\u0026rdquo; (IP) của mình và đối phương. Java cung cấp class\nHình 1.1: Hiệu ứng Dunning–Kruger – mức độ tự tin thay đổi theo kinh nghiệm học tập\nGóc nhìn học tập: Hiệu ứng Dunning–Kruger InetAddress để làm việc này.\nĐịa chỉ IP là gì trong lập trình mạng? IP (Internet Protocol Address) là địa chỉ định danh của một thiết bị khi tham gia vào mạng máy tính.\nTrong lập trình mạng, IP đóng vai trò quan trọng trong việc:\nXác định máy gửi và máy nhận Định tuyến dữ liệu trong quá trình truyền thông Thiết lập kết nối giữa các tiến trình chạy trên những máy khác nhau Nếu không có địa chỉ IP, các máy tính sẽ không thể nhận biết và giao tiếp với nhau.\nVai trò của lớp InetAddress trong Java Lớp InetAddress đại diện cho một địa chỉ IP trong Java.\nThông qua lớp này, lập trình viên có thể:\nLấy địa chỉ IP của máy đang chạy chương trình Lấy tên máy (hostname) Phân giải tên miền sang địa chỉ IP Chuẩn bị thông tin để tạo Socket hoặc ServerSocket Hầu hết các chương trình lập trình mạng trong Java đều sử dụng InetAddress ở bước khởi tạo.\nPhân tích ý nghĩa các lệnh trong chương trình InetAddress.getLocalHost()\n→ Trả về đối tượng đại diện cho máy cục bộ (localhost).\ngetHostName()\n→ Lấy tên máy do hệ điều hành hoặc mạng gán.\ngetHostAddress()\n→ Lấy địa chỉ IP của máy dưới dạng chuỗi.\nViệc in ra hostname và IP giúp:\nKiểm tra cấu hình mạng Xác định đúng máy khi kết nối Client – Server Debug lỗi mạng Một số lưu ý khi lấy IP trong Java Khi máy không kết nối mạng, IP có thể là 127.0.0.1 Khi máy có nhiều card mạng (WiFi, LAN, VPN), IP trả về có thể không phải IP Internet Trên Server, hostname và IP thường khác máy cá nhân Ứng dụng thực tế Việc xác định IP của máy thường được sử dụng trong:\nChương trình Client – Server Thông báo IP Server cho Client kết nối Kiểm tra kết nối mạng LAN Ghi log và giám sát hệ thống Kết luận Qua bài học này, ta đã:\nHiểu vai trò của địa chỉ IP trong lập trình mạng Biết cách lấy IP bằng lớp InetAddress Chuẩn bị nền tảng cho các kỹ thuật TCP, UDP và RMI Liên hệ với học phần Lập trình Mạng máy tính Bài học này nằm trong nội dung mở đầu của học phần Lập trình Mạng máy tính (CMP180) tại Trường Đại học Công nghệ TP.HCM (HUTECH).\nTrong lộ trình môn học, sinh viên sẽ lần lượt tiếp cận các nội dung:\nKiến thức nền tảng về mạng và lập trình mạng Quản lý luồng nhập xuất (I/O) Quản lý địa chỉ và kết nối mạng Lập trình Socket TCP và UDP Xử lý đa tuyến, đa luồng Multicast UDP và Java RMI Thực hiện đồ án học phần cá nhân Mục tiêu của bài học Thông qua Bài 1, sinh viên sẽ:\nLàm quen với môi trường lập trình mạng bằng Java Hiểu được vai trò của địa chỉ IP trong giao tiếp mạng Biết cách sử dụng lớp InetAddress để lấy IP và hostname Chuẩn bị nền tảng cho các bài học tiếp theo về Socket và Server – Client ","permalink":"http://localhost:1313/blog/bai-viet-1/","summary":"GIỚI THIỆU HỌC PHẦN.","title":"Bài 1: Tổng quan khoá học"},{"content":"Trong lập trình mạng, nếu IP được xem như địa chỉ nhà của một máy tính trong mạng,\nthì Port (cổng) chính là số hiệu dùng để xác định chương trình hoặc dịch vụ cụ thể đang chạy trên máy đó.\nMột máy tính có thể chạy đồng thời nhiều ứng dụng mạng như Web Server, Database Server, Game Server hoặc Chat Server.\nMỗi ứng dụng bắt buộc phải gắn với một Port riêng để hệ điều hành có thể phân biệt và định tuyến dữ liệu chính xác.\nPort nằm ở đâu trong mô hình TCP/IP? Trong bộ giao thức TCP/IP, Port thuộc về Transport Layer (Tầng giao vận) và được sử dụng bởi hai giao thức chính là TCP và UDP.\nĐịa chỉ IP xác định máy nào sẽ nhận dữ liệu Port xác định ứng dụng nào trên máy đó sẽ xử lý dữ liệu Sự kết hợp giữa IP + Port tạo thành một Socket, là điểm cuối (endpoint) của quá trình giao tiếp mạng.\nCác loại Port phổ biến Port được đánh số từ 0 đến 65535 và được chia thành ba nhóm chính:\nInternet và các End Devices Trước khi tìm hiểu về Port, cần hiểu Internet được cấu thành từ hàng tỷ thiết bị đầu cuối (End Devices) như máy tính, điện thoại, máy chủ và các thiết bị IoT.\nCác thiết bị này kết nối với nhau thông qua nhiều lớp mạng khác nhau, và mỗi thiết bị khi tham gia giao tiếp mạng đều cần có địa chỉ IP và Port để định danh. Hình 2.1: Sơ đồ minh họa Internet và các thiết bị đầu cuối (End Devices) kết nối thông qua các mạng truy cập và mạng lõi.\nTrong quá trình giao tiếp mạng, một thiết bị không chỉ cần địa chỉ IP để xác định vị trí trong mạng, mà còn cần Port để xác định chính xác ứng dụng hoặc dịch vụ đang lắng nghe trên thiết bị đó.\nDo đó, Port đóng vai trò như “điểm tiếp nhận” (endpoint) cho các tiến trình mạng chạy trên cùng một máy.\nMô hình các tầng giao thức TCP/IP Để hiểu rõ Port hoạt động ở đâu và vì sao Server cần Port, ta cần nắm được mô hình giao thức TCP/IP – nền tảng của mọi ứng dụng mạng hiện nay.\nHình 2.2: Mô hình các tầng giao thức TCP/IP và các giao thức tiêu biểu tương ứng với từng tầng.\nTrong mô hình TCP/IP, địa chỉ IP hoạt động ở tầng Internet, giúp xác định thiết bị trong mạng.\nTrong khi đó, Port hoạt động ở tầng Transport (TCP/UDP), giúp xác định chính xác ứng dụng hoặc dịch vụ đang giao tiếp trên thiết bị đó.\nWell-known Ports (0 – 1023) Được dùng cho các dịch vụ chuẩn:\nPort 80: HTTP Port 443: HTTPS Port 21: FTP Port 25: SMTP Registered Ports (1024 – 49151) Thường dùng cho các ứng dụng phổ biến:\nPort 3306: MySQL Port 8080: Web Server thay thế port 80 Dynamic / Private Ports (49152 – 65535) Do hệ điều hành cấp phát tạm thời cho Client khi giao tiếp mạng.\nVì sao Server thường dùng cổng 8080? Cổng 8080 rất phổ biến trong quá trình phát triển và học tập vì:\nTránh xung đột với cổng 80 đang được hệ điều hành chiếm dụng Không cần quyền Administrator khi mở Server Phù hợp cho các Web Server thử nghiệm như: Apache Tomcat Spring Boot Node.js Lỗi thường gặp: “Address already in use” Lỗi này xảy ra khi Server cố gắng mở một Port đã bị chương trình khác chiếm dụng.\nNguyên nhân phổ biến:\nServer cũ chưa được tắt Port đang được dùng bởi dịch vụ khác Chạy nhiều Server cùng lúc Cách khắc phục:\nĐổi sang Port khác (ví dụ: 8080 → 9090) Kiểm tra Port đang sử dụng trong hệ điều hành Đảm bảo chỉ có một Server chạy tại một thời điểm Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), khái niệm Port sẽ được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Xây dựng mô hình Client – Server Java RMI và Multicast Việc hiểu rõ Port là nền tảng bắt buộc trước khi triển khai các ứng dụng mạng thực tế.\nKết luận Qua bài học này, ta đã:\nHiểu được Port là gì và vai trò của Port trong lập trình mạng Nắm được mối quan hệ giữa IP, Port và Socket Giải thích được lý do Server thường sử dụng cổng 8080 Chuẩn bị kiến thức nền cho các bài học tiếp theo về TCP và UDP ","permalink":"http://localhost:1313/blog/bai-viet-2/","summary":"MẠNG MÁY TÍNH \u0026amp; INTERNET.","title":"Bài 2: Kiến thức nền tảng?"},{"content":"Trong lập trình Java, luồng nhập xuất (Input / Output Streams) đóng vai trò trung gian giúp chương trình đọc và ghi dữ liệu từ nhiều nguồn khác nhau như bàn phím, file, console, bộ nhớ và sau này là socket mạng.\nHiểu rõ cơ chế luồng nhập xuất là bước nền bắt buộc trước khi đi vào lập trình Socket TCP, UDP hay Java RMI.\nLuồng (Stream) là gì? Luồng (Stream) là dòng dữ liệu di chuyển\ntừ nguồn → chương trình hoặc từ chương trình → đích.\nKhi Java đọc hoặc ghi dữ liệu, dữ liệu không đi trực tiếp mà luôn được đóng gói và truyền qua luồng.\nLuồng nhập xuất là gì? Luồng nhập xuất là cơ chế cho phép chương trình:\nNhận dữ liệu từ bên ngoài (Input) Ghi dữ liệu ra bên ngoài (Output) Luồng có thể kết nối với nhiều nguồn và đích khác nhau:\nFile Bàn phím Màn hình (console) Bộ nhớ Kết nối mạng (TCP / UDP) Dữ liệu trong luồng tồn tại dưới những dạng nào? Trong Java, dữ liệu trong luồng tồn tại dưới hai dạng chính:\nLuồng byte Luồng ký tự Việc chọn đúng loại luồng ảnh hưởng trực tiếp đến hiệu năng và tính chính xác của chương trình.\nLuồng byte trong Java Đặc điểm Dữ liệu được xử lý dưới dạng nhị phân Phù hợp với: File nhị phân Ảnh, video Socket mạng Dữ liệu phức tạp Các lớp gốc InputStream – luồng đọc byte OutputStream – luồng ghi byte Cả hai đều là lớp trừu tượng (abstract).\nCác luồng byte đọc phổ biến FileInputStream – đọc byte từ file ByteArrayInputStream – đọc từ mảng byte PipedInputStream – đọc từ luồng pipe Các luồng byte ghi phổ biến FileOutputStream – ghi byte vào file ByteArrayOutputStream – ghi vào mảng byte PipedOutputStream – ghi vào luồng pipe Mô hình đọc/ghi dữ liệu với Stream Quy trình chung khi làm việc với luồng:\nTạo đối tượng Stream Gắn Stream với nguồn hoặc đích Đọc/ghi dữ liệu trong vòng lặp Đóng Stream sau khi hoàn tất Luồng ký tự trong Java Đặc điểm Xử lý dữ liệu dạng Unicode Phù hợp với: File văn bản Chuỗi Dữ liệu hiển thị cho người dùng Các lớp gốc Reader – luồng đọc ký tự Writer – luồng ghi ký tự Các luồng ký tự đọc phổ biến FileReader – đọc file văn bản BufferedReader – đọc có bộ đệm StringReader – đọc chuỗi CharArrayReader – đọc mảng ký tự Các luồng ký tự ghi phổ biến FileWriter – ghi vào file văn bản BufferedWriter – ghi có bộ đệm PrintWriter – ghi dữ liệu dạng dễ đọc StringWriter – ghi chuỗi Luồng lọc dữ liệu (Filtered Streams) Luồng lọc dùng để chuyển đổi dữ liệu từ dạng byte/ký tự sang các kiểu dữ liệu khác.\nCác luồng lọc phổ biến DataInputStream DataOutputStream Cho phép đọc/ghi các kiểu dữ liệu nguyên thủy:\nint float double boolean char Đây là cầu nối giữa luồng thô và dữ liệu có kiểu trong Java.\nLưu trạng thái đối tượng – Serialization Serialization là gì? Serialization (chuỗi hóa) là quá trình chuyển đối tượng Java thành luồng byte để:\nLưu vào file Truyền qua mạng Phục hồi lại sau này Deserialization Ngược lại, Deserialization (giải chuỗi) là quá trình:\nĐọc byte Tái tạo lại đối tượng ban đầu Đây là nền tảng cho:\nLưu dữ liệu chương trình Java RMI Truyền object qua mạng Try-with-resources (TWR) Java hỗ trợ Try-with-resources để:\nTự động đóng stream Tránh rò rỉ tài nguyên Code gọn và an toàn hơn So với try-catch truyền thống, TWR:\nÍt lỗi hơn Dễ bảo trì hơn Được khuyến khích sử dụng Các lỗi I/O thường gặp Khi làm việc với luồng, một số exception phổ biến là:\nFileNotFoundException IOException EOFException UnsupportedEncodingException FileAlreadyExistsException AccessDeniedException SocketException MalformedURLException SerializationException InvalidPathException Việc bắt và xử lý exception đúng cách là yêu cầu bắt buộc trong lập trình Java.\nLiên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), luồng nhập xuất được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Truyền dữ liệu Client – Server Java RMI Multicast UDP Không hiểu I/O Stream → không thể làm mạng đúng cách.\nKết luận Qua bài học này, ta đã:\nHiểu khái niệm luồng nhập xuất trong Java Phân biệt luồng byte và luồng ký tự Nắm được cách đọc/ghi dữ liệu với Stream Biết vai trò của Serialization và Filtered Streams Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo Khi xử lý các tác vụ mạng (như gọi API), người mới học JS hay viết code lồng nhau kiểu này:\n1 2 3 4 5 6 7 8 9 10 // Cực hình Callback Hell getData(function(a) { getMoreData(a, function(b) { getMoreData(b, function(c) { getMoreData(c, function(d) { console.log(d); }); }); }); }); ","permalink":"http://localhost:1313/blog/bai-viet-3/","summary":"Tổng quan về Input/Output Streams trong Java – nền tảng cho xử lý file, console và lập trình mạng.","title":"Bài 3: Quản lý luồng nhập xuất trong Java"},{"content":"Trong lập trình mạng, trước khi chương trình có thể gửi hoặc nhận dữ liệu, điều quan trọng nhất là xác định đúng địa chỉ kết nối mạng. Nếu xác định sai địa chỉ, chương trình sẽ không thể giao tiếp, dù phần xử lý dữ liệu có đúng đến đâu.\nBài học này giúp bạn hiểu cách Java làm việc với địa chỉ IP, tên miền (DNS) và URL. Đây là nền tảng bắt buộc trước khi đi vào Socket TCP, UDP, Web Crawler và Java RMI.\nĐịa chỉ kết nối mạng là gì? Địa chỉ kết nối mạng là thông tin dùng để xác định máy nào trong mạng cần giao tiếp và dịch vụ nào trên máy đó sẽ xử lý dữ liệu.\nTrong Internet, địa chỉ kết nối thường bao gồm:\nĐịa chỉ IP Tên miền (Domain Name) Cổng (Port) Giao thức (Protocol) DNS – Domain Name System Hình 4.1 – Mô hình hoạt động của DNS (Domain Name System)\nClient gửi yêu cầu phân giải tên miền đến DNS Server, DNS trả về địa chỉ IP tương ứng để client kết nối đến server đích.*\nCon người dễ nhớ tên miền hơn các dãy số IP.\nDNS (Domain Name System) có nhiệm vụ ánh xạ tên miền sang địa chỉ IP, giúp client tìm đúng server cần kết nối.\nVí dụ:\ngoogle.com tương ứng với nhiều địa chỉ IP khác nhau www.cs.yale.edu tương ứng với 128.36.229.30 Nhờ DNS, người dùng không cần ghi nhớ địa chỉ IP khi truy cập Internet.\nĐịa chỉ IPv4 IPv4 là dạng địa chỉ phổ biến, gồm 32 bit, thường được viết thành bốn nhóm số.\nVí dụ:\n192.168.1.1 8.8.8.8 Một số dải địa chỉ đặc biệt:\n127.x.x.x là loopback (localhost) 224.0.0.0 – 239.255.255.255 là multicast Lớp InetAddress trong Java Java cung cấp lớp InetAddress để làm việc với địa chỉ IP và DNS.\nLớp này thường được dùng để:\nPhân giải tên miền sang IP Kiểm tra loại địa chỉ Kiểm tra khả năng kết nối mạng Ví dụ minh họa:\n1 InetAddress address = InetAddress.getByName(\u0026#34;google.com\u0026#34;); URL – Uniform Resource Locator URL được dùng để xác định tài nguyên trên Internet như trang web, file hoặc dịch vụ.\nMột URL đầy đủ thường bao gồm các thành phần sau:\nGiao thức (Protocol) Tên miền (Host) Cổng (Port) Đường dẫn (Path) Chuỗi truy vấn (Query) Ví dụ một URL đầy đủ: https://www.hutech.edu.vn/admission?id=123\nURL cho biết lấy dữ liệu ở đâu và bằng cách nào.\nLớp URL trong Java Lớp URL cho phép chương trình Java:\nPhân tích các thành phần của URL Kết nối tới server Đọc dữ liệu từ Internet Ví dụ minh họa:\n1 URL url = new URL(\u0026#34;https://www.example.com\u0026#34;); Ý nghĩa của việc quản lý địa chỉ kết nối mạng Hiểu rõ cách quản lý địa chỉ mạng giúp:\nTránh kết nối sai server Chuẩn bị đúng địa chỉ cho Socket TCP/UDP Hiểu cách Web Crawler hoạt động Nắm vững mô hình Client – Server Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm địa chỉ kết nối mạng Biết vai trò của DNS và IPv4 Nắm được cách Java làm việc với InetAddress Hiểu cấu trúc và vai trò của URL Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-4/","summary":"Tìm hiểu cách Java quản lý địa chỉ mạng thông qua InetAddress, URL, URLConnection và DNS.","title":"Bài 4: Quản lý địa chỉ kết nối mạng trong Java"},{"content":"Trong lập trình mạng, TCP Socket là cơ chế quan trọng nhất để xây dựng các ứng dụng Client – Server có độ tin cậy cao.\nBài học này giúp bạn hiểu TCP là gì, vì sao cần TCP, và cách Java triển khai TCP thông qua Socket và ServerSocket.\nĐây là bước chuyển tiếp trực tiếp từ kiến thức địa chỉ mạng (IP, DNS, URL) sang giao tiếp dữ liệu thực tế giữa các chương trình.\nTCP là gì? TCP (Transmission Control Protocol) là giao thức truyền thông hướng kết nối, đảm bảo dữ liệu được truyền:\nĐúng thứ tự Đầy đủ Không bị mất mát Không bị trùng lặp Trước khi truyền dữ liệu, TCP yêu cầu thiết lập kết nối giữa hai bên, và chỉ khi kết nối thành công thì dữ liệu mới được trao đổi.\nVì sao sử dụng TCP? TCP được sử dụng khi ứng dụng yêu cầu độ tin cậy cao, ví dụ:\nỨng dụng chat Ứng dụng client–server Truyền file Game online theo lượt Hệ thống ngân hàng, thương mại điện tử TCP cung cấp các cơ chế quan trọng:\nĐảm bảo dữ liệu: gói tin bị mất sẽ được gửi lại Kiểm soát lỗi: phát hiện và sửa lỗi trong quá trình truyền Kiểm soát luồng: tránh làm quá tải phía nhận Giao tiếp hai chiều: cho phép gửi và nhận dữ liệu đồng thời Cơ chế hoạt động của TCP Quá trình giao tiếp TCP gồm ba giai đoạn chính:\nThiết lập kết nối (Bắt tay 3 bước – Three-way Handshake) Truyền dữ liệu Giải phóng kết nối Nhờ cơ chế này, TCP đảm bảo rằng hai bên luôn sẵn sàng trước khi truyền và kết thúc an toàn sau khi hoàn tất.\nMô hình Client – Server Các ứng dụng TCP thường hoạt động theo mô hình Client – Server.\nServer:\nChạy trước Lắng nghe yêu cầu kết nối Cung cấp dịch vụ Trả kết quả cho client Client:\nChạy sau Chủ động kết nối tới server Gửi yêu cầu Nhận phản hồi từ server Quá trình giao tiếp gồm:\nClient gửi yêu cầu Server xử lý Server trả kết quả cho client Socket trong Java Trong Java, Socket đại diện cho điểm cuối giao tiếp giữa client và server khi sử dụng TCP.\nSocket cho phép:\nGửi dữ liệu tới server Nhận dữ liệu từ server Giao tiếp hai chiều thông qua luồng nhập/xuất Ví dụ minh họa tạo Socket phía client:\n1 Socket socket = new Socket(\u0026#34;localhost\u0026#34;, 8080); ServerSocket trong Java ServerSocket được sử dụng ở phía server để:\nMở một cổng lắng nghe Chờ client kết nối Chấp nhận kết nối và tạo Socket giao tiếp ServerSocket đóng vai trò như cửa ngõ, cho phép các client kết nối vào server.\nVí dụ minh họa:\n1 ServerSocket server = new ServerSocket(8080); Luồng dữ liệu trong TCP Socket Sau khi kết nối TCP được thiết lập, client và server trao đổi dữ liệu thông qua các luồng:\nInputStream: dùng để đọc dữ liệu từ socket OutputStream: dùng để ghi dữ liệu vào socket Luồng dữ liệu này hoạt động tương tự như I/O Stream đã học ở bài trước,\nnhưng nguồn và đích là mạng thay vì file hay bàn phím.\nVí dụ ứng dụng: Trò chơi Oẳn Tù Tì Một bài tập tiêu biểu sử dụng TCP Socket là trò chơi Oẳn Tù Tì theo mô hình Client – Server.\nĐặc điểm Server quản lý luật chơi và điểm số Hai client gửi lựa chọn (kéo – búa – bao) Server xác định kết quả và gửi lại cho client Dữ liệu được truyền qua TCP để đảm bảo chính xác Thông qua bài tập này, sinh viên hiểu rõ:\nCách thiết lập kết nối TCP Cách trao đổi dữ liệu giữa nhiều client Cách xử lý lỗi mạng và ngoại lệ Ý nghĩa của lập trình TCP Socket Việc nắm vững TCP Socket giúp bạn:\nHiểu bản chất giao tiếp mạng Xây dựng hệ thống Client – Server thực tế Chuẩn bị cho các bài nâng cao như: Đa tuyến (Multi-thread) Socket UDP Java RMI Ứng dụng mạng phân tán Kết luận Qua bài học này, bạn đã:\nHiểu TCP là gì và vì sao cần TCP Nắm được mô hình Client – Server Biết vai trò của Socket và ServerSocket trong Java Hiểu cách dữ liệu được truyền qua TCP Chuẩn bị nền tảng cho các bài học UDP và xử lý đồng thời tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-5/","summary":"Giải thích mô hình Client–Server và cách lập trình Socket TCP trong Java – nền tảng cho giao tiếp mạng tin cậy.","title":"Bài 5: Lập trình Socket TCP trong Java"},{"content":"#Trong lập trình mạng, không phải lúc nào ứng dụng cũng cần độ tin cậy tuyệt đối như TCP.\nTrong nhiều trường hợp, điều quan trọng hơn là tốc độ truyền nhanh và độ trễ thấp.\nBài học này giới thiệu UDP Socket – cơ chế truyền dữ liệu không kết nối, được sử dụng rộng rãi trong các ứng dụng thời gian thực.\nUDP là gì? UDP (User Datagram Protocol) là giao thức truyền thông không hướng kết nối.\nĐiều này có nghĩa là:\nKhông thiết lập kết nối trước khi truyền Không đảm bảo dữ liệu đến nơi Không đảm bảo thứ tự gói tin Không tự động gửi lại gói tin bị mất UDP gửi dữ liệu theo từng datagram (gói tin độc lập).\nSo sánh TCP và UDP TCP UDP Có kết nối Không kết nối Đảm bảo dữ liệu Không đảm bảo Truyền theo luồng Truyền theo gói Độ trễ cao hơn Độ trễ thấp Phù hợp dữ liệu quan trọng Phù hợp dữ liệu thời gian thực Khi nào sử dụng UDP? UDP được sử dụng khi:\nCần truyền nhanh Có thể chấp nhận mất gói tin Dữ liệu được gửi liên tục Ví dụ ứng dụng UDP:\nTruyền video, audio trực tuyến Game online thời gian thực Chat broadcast DNS Multicast, streaming UDP Socket trong Java Java hỗ trợ UDP thông qua hai lớp chính:\nDatagramSocket: quản lý socket UDP DatagramPacket: đại diện cho gói dữ liệu UDP UDP không phân biệt client hay server rõ ràng như TCP.\nMỗi chương trình chỉ cần một DatagramSocket để gửi và nhận dữ liệu.\nDatagramPacket là gì? DatagramPacket là gói dữ liệu UDP, bao gồm:\nDữ liệu cần gửi Địa chỉ IP đích Số hiệu cổng Mỗi lần gửi hoặc nhận dữ liệu, UDP làm việc với một DatagramPacket riêng biệt.\nLuồng dữ liệu trong UDP UDP không có luồng InputStream / OutputStream như TCP.\nQuy trình truyền dữ liệu UDP:\nTạo DatagramSocket Tạo DatagramPacket chứa dữ liệu Gửi packet đi Nhận packet về Đọc dữ liệu từ packet Mỗi gói tin là độc lập, không liên quan đến các gói khác.\nĐặc điểm quan trọng của UDP Không kiểm soát lỗi Không kiểm soát luồng Không bắt tay kết nối Gửi nhanh, xử lý đơn giản Phù hợp truyền broadcast và multicast Chính vì vậy, UDP thường được dùng khi tốc độ quan trọng hơn độ chính xác tuyệt đối.\nÝ nghĩa của lập trình Socket UDP Nắm vững UDP giúp bạn:\nHiểu bản chất truyền dữ liệu không kết nối Xây dựng ứng dụng thời gian thực Phân biệt rõ TCP và UDP trong thiết kế hệ thống Chuẩn bị cho các chủ đề nâng cao như: Multicast UDP Java RMI Hệ thống phân tán Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính, UDP được sử dụng trong:\nSocket UDP Multicast Ứng dụng truyền tin nhanh Game, streaming, broadcast Hiểu UDP giúp bạn chọn đúng giao thức cho từng bài toán thực tế.\nKết luận Qua bài học này, bạn đã:\nHiểu UDP là gì và cơ chế hoạt động Phân biệt được TCP và UDP Biết vai trò của DatagramSocket và DatagramPacket Hiểu cách truyền dữ liệu không kết nối Chuẩn bị nền tảng cho bài Multicast UDP \u0026amp; Java RMI tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-6/","summary":"Giải thích giao thức UDP và cách Java lập trình Socket UDP – nền tảng cho truyền dữ liệu nhanh, không kết nối.","title":"Bài 6: Lập trình Socket UDP trong Java"},{"content":"Trong các ứng dụng mạng thực tế, đặc biệt là Server, chương trình thường phải xử lý nhiều yêu cầu cùng lúc.\nNếu chỉ sử dụng một luồng thực thi, server sẽ bị tắc nghẽn, các client phải chờ đợi và hiệu năng giảm nghiêm trọng.\nVì vậy, lập trình đa tuyến (Multithreading) và xử lý đồng thời (Concurrency) là kỹ thuật bắt buộc trong lập trình mạng.\nTuyến (Thread) là gì? Thread là một dòng điều khiển tuần tự bên trong một chương trình.\nMột chương trình (process) có thể chứa nhiều thread Các thread có thể chạy đồng thời Mỗi thread thực hiện một nhiệm vụ riêng Thread không phải là một chương trình độc lập,\nnó luôn thuộc về một process.\nProcess và Thread Process:\nCó không gian bộ nhớ riêng Chạy độc lập với process khác Tạo và chuyển đổi tốn nhiều tài nguyên Thread:\nChia sẻ bộ nhớ với các thread khác trong cùng process Tạo nhanh hơn process Chuyển đổi nhanh hơn Nhờ thread, chương trình có thể thực hiện nhiều công việc cùng lúc trong cùng một ứng dụng.\nVì sao cần lập trình đa tuyến? Lập trình đa tuyến giúp:\nTăng hiệu suất và khả năng đáp ứng Tận dụng thời gian chờ đợi (I/O, mạng, tải file) Chia nhỏ tác vụ và xử lý đồng thời Cải thiện trải nghiệm người dùng Trong lập trình mạng, đa tuyến cho phép server phục vụ nhiều client cùng lúc.\nThực thi Thread trong Java Trong Java, một thread bắt đầu chạy khi gọi phương thức start().\nKhi thread chạy, JVM thực thi mã trong phương thức run() Khi run() kết thúc, thread cũng kết thúc Một thread không thể start lại, muốn chạy lại phải tạo thread mới Thread cần có điều kiện dừng rõ ràng để tránh chạy vô hạn.\nỨng dụng đa tuyến trong lập trình mạng Ứng dụng Chat đa tuyến Một ví dụ tiêu biểu của đa tuyến trong mạng là ứng dụng chat nhiều client – một server.\nĐặc điểm:\nServer chấp nhận nhiều client kết nối cùng lúc Mỗi client được xử lý bởi một thread riêng Tin nhắn từ một client được gửi tới tất cả client khác Server ghi lại nội dung chat vào file log Thông qua ví dụ này, sinh viên hiểu rõ:\nCách server xử lý nhiều kết nối đồng thời Cách phối hợp giữa socket và thread Vai trò của đa tuyến trong ứng dụng mạng Xử lý đồng thời (Concurrency) Xử lý đồng thời xảy ra khi nhiều thread:\nChạy cùng lúc Truy cập tài nguyên chung (biến, file, bộ nhớ) Nếu không kiểm soát tốt, chương trình có thể gặp các vấn đề nghiêm trọng.\nRace Condition Race Condition xảy ra khi:\nNhiều thread cùng truy cập và thay đổi dữ liệu chung Kết quả phụ thuộc vào thứ tự thực thi không xác định Điều này có thể dẫn đến:\nDữ liệu sai lệch Kết quả không nhất quán Lỗi khó phát hiện Đồng bộ hóa (Synchronization) Để tránh race condition, Java cung cấp cơ chế đồng bộ hóa:\nĐảm bảo chỉ một thread được truy cập tài nguyên tại một thời điểm Giữ cho dữ liệu luôn nhất quán Đồng bộ hóa là nền tảng để xây dựng các ứng dụng an toàn và ổn định khi chạy đa tuyến.\nCác vấn đề thường gặp trong xử lý đồng thời Một số vấn đề phổ biến:\nRace condition: tranh chấp dữ liệu Deadlock: các thread chờ nhau vô hạn Livelock: các thread liên tục phản ứng nhưng không tiến triển Starvation: thread không bao giờ được cấp tài nguyên Những vấn đề này khiến lập trình đa tuyến trở nên phức tạp và khó debug.\nLập lịch Thread trong Java Java sử dụng cơ chế lập lịch theo độ ưu tiên:\nMỗi thread có độ ưu tiên từ MIN_PRIORITY đến MAX_PRIORITY JVM chọn thread runnable có độ ưu tiên cao hơn để chạy Thread có thể nhường CPU cho thread khác bằng cách gọi yield() Việc hiểu cơ chế lập lịch giúp lập trình viên thiết kế thread hợp lý hơn.\nÝ nghĩa của lập trình đa tuyến và xử lý đồng thời Nắm vững kiến thức bài này giúp bạn:\nXây dựng server xử lý nhiều client Viết ứng dụng mạng hiệu năng cao Tránh lỗi tranh chấp dữ liệu Chuẩn bị cho các chủ đề nâng cao như: Server đa tuyến Pooling Threads Multicast UDP Java RMI Hệ thống phân tán Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm thread và multithreading Phân biệt process và thread Biết vai trò của đa tuyến trong lập trình mạng Hiểu các vấn đề xử lý đồng thời và race condition Chuẩn bị nền tảng cho các bài học nâng cao tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-7/","summary":"Giải thích lập trình đa tuyến và xử lý đồng thời trong Java – nền tảng cho các ứng dụng mạng nhiều client và hệ thống phân tán.","title":"Bài 7: Lập trình đa tuyến và xử lý đồng thời trong Java"},{"content":"Buổi 8 gồm 2 phần lớn:\nMulticast UDP: gửi dữ liệu từ một nguồn đến nhiều máy nhận cùng lúc (1 → N). Java RMI: gọi phương thức từ xa giữa các ứng dụng Java như gọi hàm bình thường (Remote Method Invocation). Đây là các kỹ thuật thường gặp trong streaming, trò chuyện nhóm, giám sát từ xa và hệ thống phân tán.\n1) UDP Multicast Unicast, Broadcast và Multicast Trong mạng máy tính có 3 kiểu gửi dữ liệu phổ biến:\nUnicast: 1 nguồn → 1 đích\nVí dụ: bạn mở một trang web, server trả dữ liệu cho riêng bạn.\nBroadcast: 1 nguồn → tất cả máy trong mạng nội bộ\nVí dụ: một thông báo phát cho toàn bộ LAN.\nMulticast: 1 nguồn → một nhóm máy đã đăng ký nhận dữ liệu\nVí dụ: server phát stream video cho nhóm người xem cùng lúc.\nMulticast là cách truyền hiệu quả khi nhiều máy cùng cần nhận một nội dung giống nhau.\nTại sao dùng UDP Multicast? UDP Multicast thường được dùng vì:\nHiệu suất cao: gửi 1 lần nhưng nhiều máy nhận → giảm tải mạng và server. Đơn giản, nhanh: UDP là kiểu “gửi và quên”, không phải chờ xác nhận. Tối ưu trong LAN: phù hợp môi trường mạng nội bộ (Local Area Network). Rất hợp streaming: audio/video cần tốc độ và độ trễ thấp hơn là đảm bảo tuyệt đối. Ứng dụng của Multicast Multicast có thể dùng trong:\nTruyền phát multimedia trực tiếp (audio/video streaming) Trò chuyện nhóm, hội thoại nhóm Quảng bá thông tin cấu hình mạng và cập nhật trong hệ thống mạng Game nhiều người chơi (gửi trạng thái game cho nhiều người) Phát thông tin trạng thái/cảnh báo cho nhiều thiết bị Phát tán cập nhật phần mềm trong mạng nội bộ Địa chỉ Multicast IPv4 Trong IPv4:\nClass D là dải địa chỉ dành cho multicast Dải địa chỉ multicast thường gặp: 224.0.0.0 – 239.255.255.255 Một số nhóm multicast hay được nhắc:\n224.0.0.1: tất cả host trong local subnet Multicast Group là gì? Multicast hoạt động theo “nhóm”:\nMột multicast group giống như một kênh. Máy nào muốn nhận dữ liệu phải tham gia nhóm (join group). Khi rời nhóm thì không nhận dữ liệu nữa. Multicast trong Java Java hỗ trợ multicast qua lớp:\njava.net.MulticastSocket (kế thừa từ DatagramSocket) Một số thao tác quan trọng:\njoinGroup(...): tham gia nhóm multicast leaveGroup(...): rời nhóm multicast setTimeToLive(ttl): đặt TTL (thời gian sống của gói tin, qua bao nhiêu router) Quy trình gửi dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket Tham gia nhóm multicast Tạo DatagramPacket chứa dữ liệu + địa chỉ nhóm + port Gửi packet Rời nhóm Ví dụ minh họa (ngắn, chỉ để hiểu):\n1 2 3 4 5 6 7 8 9 10 11 12 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(); socket.joinGroup(group); socket.setTimeToLive(5); byte[] data = \u0026#34;Hello Multicast\u0026#34;.getBytes(); DatagramPacket packet = new DatagramPacket(data, data.length, group, 9876); socket.send(packet); socket.leaveGroup(group); socket.close(); Quy trình nhận dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket lắng nghe trên port Tham gia nhóm multicast Tạo DatagramPacket rỗng để nhận dữ liệu Gọi receive() để chờ gói tin gửi về Đọc dữ liệu từ packet Rời nhóm và đóng socket Ví dụ minh họa (ngắn):\n1 2 3 4 5 6 7 8 9 10 11 12 13 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(9876); socket.joinGroup(group); byte[] buf = new byte[1024]; DatagramPacket packet = new DatagramPacket(buf, buf.length); socket.receive(packet); String msg = new String(packet.getData(), 0, packet.getLength()); System.out.println(\u0026#34;Received: \u0026#34; + msg); socket.leaveGroup(group); socket.close(); 2) Java RMI Java RMI là gì? RMI (Remote Method Invocation) cho phép chương trình Java:\nGọi phương thức của một đối tượng nằm trên máy khác Cảm giác giống như gọi method trong cùng chương trình Nói đơn giản:\nClient gọi: remoteObject.sum(1,2) Server thực thi thật và trả kết quả về cho client RMI giúp che giấu toàn bộ chi tiết mạng phía sau, người lập trình chỉ tập trung vào logic.\nVì sao dùng Java RMI? Java RMI được sử dụng vì:\nTích hợp sẵn trong Java, dễ triển khai nếu cả client và server đều dùng Java Gọi phương thức từ xa đơn giản như gọi hàm thông thường Hỗ trợ dữ liệu phức tạp: đối tượng, mảng, class tự định nghĩa Tự động xử lý giao tiếp mạng thông qua cơ chế stub / skeleton Dựa trên TCP/IP nên tương đối ổn định và tin cậy Hạn chế của Java RMI Một số điểm hạn chế cần lưu ý:\nPhụ thuộc Java: chủ yếu phù hợp Java ↔ Java Thiết kế dịch vụ phức tạp vẫn cần tổ chức tốt (đặc biệt khi dùng callback) Quản lý phiên và kết nối không mạnh như các giải pháp hiện đại Bảo mật cần cấu hình cẩn thận trong môi trường thực tế Ý tưởng kiến trúc RMI (hiểu nhanh) Trong Java RMI có các thành phần chính:\nRemote Interface\nKhai báo các phương thức cho phép gọi từ xa\nServer Implementation\nLớp cài đặt interface, chứa logic xử lý thật\nRMI Registry\nNơi đăng ký service để client tìm thấy server\nClient\nTìm (lookup) service trong registry và gọi phương thức\nCác bước triển khai RMI (tóm tắt) Định nghĩa Remote Interface Cài đặt interface bằng một class server (remote object) Viết chương trình server: tạo object và bind vào registry Viết chương trình client: lookup registry và gọi method Chạy RMI registry, chạy server, sau đó chạy client Ví dụ ứng dụng RMI Một số ví dụ thường gặp:\nTính tổng 2 số từ xa Dịch vụ quản lý tài khoản ATM Dịch vụ giám sát nhiệt độ có callback (server gọi ngược lại client) Bài tập gợi ý theo đúng nội dung buổi 8 BT8.01: Mô phỏng streaming video\n(1 server phát, nhiều client nhận dữ liệu)\nBT8.02: Server quản lý tài khoản ATM bằng RMI\n(thêm user, đăng nhập, gửi/rút tiền, lưu lịch sử giao dịch)\nKết luận Qua bài học này, bạn đã:\nHiểu sự khác nhau giữa Unicast, Broadcast và Multicast Nắm được vì sao Multicast UDP phù hợp cho truyền dữ liệu nhóm và streaming Biết cách Java hỗ trợ multicast qua MulticastSocket Hiểu Java RMI và cơ chế gọi phương thức từ xa Chuẩn bị nền tảng cho các bài ứng dụng mạng phân tán và đồ án học phần ","permalink":"http://localhost:1313/blog/bai-viet-8/","summary":"Giải thích Multicast UDP (gửi 1-n) và Java RMI (gọi phương thức từ xa) – nền tảng cho ứng dụng nhóm và hệ phân tán.","title":"Bài 8: Multicast UDP và Java RMI"},{"content":"Sau khi hoàn thành các bài về TCP, UDP, đa tuyến và xử lý đồng thời,\nchúng ta đã có đủ nền tảng để xây dựng một ứng dụng mạng hoàn chỉnh.\nBài học này giúp bạn xâu chuỗi toàn bộ kiến thức đã học,\nhiểu rõ mỗi công nghệ dùng trong trường hợp nào,\nvà cách thiết kế một hệ thống mạng đúng tư duy kỹ sư.\nNhìn lại các mô hình giao tiếp mạng đã học Trong lập trình mạng, các ứng dụng thường được xây dựng dựa trên mô hình Client – Server.\nClient: gửi yêu cầu, nhập dữ liệu, hiển thị kết quả Server: xử lý logic, quản lý dữ liệu, trả kết quả Tùy bài toán, ta lựa chọn giao thức và mô hình phù hợp.\nSo sánh TCP, UDP và Multicast TCP – Giao tiếp tin cậy TCP phù hợp khi:\nCần đảm bảo dữ liệu đúng và đủ Cần kết nối ổn định, hai chiều Ví dụ: chat, truyền file, game theo lượt, hệ thống ngân hàng Đặc trưng:\nCó bắt tay 3 bước Có kiểm soát lỗi, kiểm soát luồng Tốn tài nguyên hơn UDP UDP – Giao tiếp nhanh, không kết nối UDP phù hợp khi:\nƯu tiên tốc độ Chấp nhận mất gói Ví dụ: game thời gian thực, streaming, cảm biến Đặc trưng:\nKhông kết nối Không đảm bảo thứ tự Ít độ trễ UDP Multicast – Truyền dữ liệu nhóm Multicast được dùng khi:\nMột nguồn → nhiều người nhận Dữ liệu giống nhau cho tất cả client Ví dụ: livestream, thông báo hệ thống, truyền trạng thái Ưu điểm:\nGiảm tải server Tiết kiệm băng thông Phù hợp mạng LAN Vai trò của đa tuyến (Multithreading) Trong thực tế, server không thể xử lý từng client một cách tuần tự.\nĐa tuyến giúp:\nNhiều client kết nối cùng lúc Không client nào bị “đóng băng” Tăng khả năng mở rộng hệ thống Ví dụ:\nServer chat: mỗi client là một thread Server TCP: mỗi socket được xử lý riêng Thiết kế một ứng dụng mạng hoàn chỉnh Khi thiết kế, cần xác định rõ:\nGiao thức: TCP hay UDP? Mô hình: 1–1, 1–n, n–n? Đồng thời hay tuần tự? Client gửi gì? Server xử lý gì? Một thiết kế tốt luôn:\nPhân tách rõ giao tiếp – xử lý – dữ liệu Dễ mở rộng Dễ bảo trì Liên hệ với đồ án học phần Các đồ án như:\nChat đa tuyến Oẳn Tù Tì client–server Streaming UDP Dịch vụ RMI Đều là sự kết hợp của các kiến thức đã học,\nkhông phải nội dung mới.\nKết luận Qua bài học này, bạn đã:\nHệ thống lại toàn bộ kiến thức lập trình mạng Hiểu rõ khi nào dùng TCP, UDP, Multicast Nắm được vai trò của đa tuyến Biết cách tư duy thiết kế một ứng dụng mạng hoàn chỉnh Đây là bước chuẩn bị quan trọng trước khi vận dụng toàn bộ kiến thức vào một hệ thống thực tế.\n","permalink":"http://localhost:1313/blog/bai-viet-9/","summary":"Tổng hợp kiến thức TCP, UDP, đa tuyến và cách thiết kế ứng dụng mạng Client–Server hoàn chỉnh.","title":"Bài 9: Tổng hợp kiến thức \u0026 thiết kế ứng dụng mạng"},{"content":"Bài cuối cùng của học phần không nhằm giới thiệu công nghệ mới,\nmà tập trung vào cách vận dụng kiến thức đã học vào thực tế.\nĐây là giai đoạn chuyển từ:\n“Biết dùng” → “Biết thiết kế” → “Biết đánh giá hệ thống”\nTư duy vận dụng kiến thức Một ứng dụng mạng hoàn chỉnh cần trả lời được các câu hỏi:\nVì sao chọn TCP mà không phải UDP? Vì sao cần đa tuyến? Server có chịu được nhiều client không? Hệ thống có mở rộng được không? Đây chính là tư duy kỹ sư, không phải chỉ “chạy được là xong”.\nĐánh giá một ứng dụng mạng Khi hoàn thiện hệ thống, cần xem xét:\n1. Tính đúng đắn Dữ liệu có truyền đúng không? Có mất gói không? Có xử lý lỗi không? 2. Tính đồng thời Nhiều client có dùng chung được không? Có bị treo server không? Có race condition không? 3. Hiệu năng Độ trễ thế nào? Server có bị quá tải không? Có tách luồng hợp lý không? Liên hệ với các mô hình phân tán Các hệ thống đã học là nền tảng cho:\nHệ thống client–server lớn Ứng dụng phân tán Microservices Cloud services Java RMI, TCP đa tuyến hay UDP Multicast\nđều là những viên gạch đầu tiên.\nTừ học phần đến thực tế Sau học phần này, bạn có thể tiếp cận:\nWebSocket REST API gRPC Message Queue (Kafka, RabbitMQ) Hệ thống realtime Tư duy lập trình mạng không thay đổi, chỉ công nghệ thay đổi.\nTổng kết toàn bộ học phần Qua toàn bộ chuỗi bài, bạn đã:\nHiểu cách dữ liệu đi qua mạng Làm việc với TCP, UDP, Multicast Xử lý đa tuyến và đồng thời Tiếp cận lập trình phân tán với RMI Có tư duy thiết kế hệ thống mạng Lời kết Lập trình mạng không chỉ là code socket,\nmà là hiểu cách các hệ thống nói chuyện với nhau.\nNếu bạn hiểu được điều đó,\nbạn đã vượt xa mức “học để qua môn”.\n","permalink":"http://localhost:1313/blog/bai-viet-10/","summary":"Vận dụng toàn bộ kiến thức lập trình mạng để xây dựng, đánh giá và hoàn thiện một ứng dụng thực tế.","title":"Bài 10: Hoàn thiện \u0026 vận dụng lập trình mạng"},{"content":"Lời mở đầu Có những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\nMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\nHọc tập Những năm đại học trôi qua nhanh hơn mình từng nghĩ. Ngày mới bước chân vào giảng đường, mình vẫn còn khá mơ hồ về ngành học, về tương lai, về chính bản thân mình sẽ trở thành ai sau bốn năm. Nhưng rồi từng môn học, từng bài tập nhóm, từng đồ án kéo mình lại gần hơn với cách một hệ thống được hình thành và vận hành.\nHệ thống thông tin không chỉ là lập trình, cũng không đơn thuần là công nghệ. Đó là câu chuyện về con người, quy trình và dữ liệu. Mình học cách đặt câu hỏi, học cách lắng nghe yêu cầu, học cách vẽ ra những sơ đồ tưởng chừng khô khan nhưng lại chứa rất nhiều suy nghĩ phía sau. Dần dần, mình nhận ra mình thích phần “hiểu vấn đề” hơn là chỉ chăm chăm vào lời giải.\nĐịnh hướng Ở thời điểm hiện tại, mình đang định hướng theo con đường Business Analyst (BA). Mình hứng thú với vai trò đứng giữa – không quá xa kỹ thuật, cũng không tách rời nghiệp vụ. Đó là nơi cần sự rõ ràng trong tư duy, sự kiên nhẫn trong giao tiếp và khả năng chuyển hóa những điều mơ hồ thành thứ có thể triển khai được.\nMình không nghĩ BA là một vị trí “nhẹ nhàng” hay “an toàn”. Ngược lại, đó là công việc đòi hỏi phải học rất nhiều, sai rất nhiều và sửa rất nhiều. Nhưng chính điều đó khiến mình thấy phù hợp. Mình muốn hiểu hệ thống trước khi xây dựng nó, muốn biết vì sao người ta see cần một chức năng, chứ không chỉ là nó được viết như thế nào.\nBlog Blog này ra đời khá tự nhiên, giống như một cuốn sổ mở rộng hơn là một trang thể hiện điều gì đó to tát. Mình viết để nhớ, để hệ thống lại những gì đã học, và đôi khi là để sắp xếp lại suy nghĩ của chính mình.\nỞ đây có thể là kiến thức về Hệ thống thông tin, về phân tích nghiệp vụ, về lập trình, hoặc đơn giản là những trải nghiệm học tập và va chạm trong quá trình làm đồ án, làm việc nhóm, và chuẩn bị bước ra môi trường thực tế. Mình không mong mọi thứ phải hoàn hảo, chỉ mong nó thật và có ích cho ai đó đang đi trên con đường tương tự.\nLời kết Mình đang ở một giai đoạn chưa thể gọi là trưởng thành, nhưng cũng không còn quá non nớt. Vẫn đang học, vẫn đang thử, vẫn đang sai và sửa mỗi ngày. Nếu có một điều mình mong giữ được lâu nhất, thì đó là sự tò mò và tinh thần học hỏi – những thứ giúp mình không đứng yên giữa rất nhiều lựa chọn ngoài kia.\nCảm ơn bạn đã ghé qua và đọc những dòng này. Hy vọng ở một thời điểm nào đó, những chia sẻ nhỏ ở đây sẽ chạm đến bạn – dù chỉ là một chút. \u0026ldquo;Học để chia sẻ, chia sẻ để học nhiều hơn.\u0026rdquo;\nLiên hệ Nếu bạn muốn gửi cho mình vài dòng trao đổi,\nbạn có thể liên hệ với mình qua Email hoặc GitHub ,Facebook dưới đây.\nCảm ơn bạn đã ghé thăm blog! ","permalink":"http://localhost:1313/about/","summary":"\u003ch2 id=\"lời-mở-đầu\"\u003eLời mở đầu\u003c/h2\u003e\n\u003cp\u003eCó những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\u003c/p\u003e\n\u003cp\u003eMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\u003c/p\u003e","title":"Giới thiệu"},{"content":"Trong lập trình mạng, trước khi kết nối, ta phải biết \u0026ldquo;địa chỉ nhà\u0026rdquo; (IP) của mình và đối phương. Java cung cấp class\nHình 1.1: Hiệu ứng Dunning–Kruger – mức độ tự tin thay đổi theo kinh nghiệm học tập\nGóc nhìn học tập: Hiệu ứng Dunning–Kruger InetAddress để làm việc này.\nĐịa chỉ IP là gì trong lập trình mạng? IP (Internet Protocol Address) là địa chỉ định danh của một thiết bị khi tham gia vào mạng máy tính.\nTrong lập trình mạng, IP đóng vai trò quan trọng trong việc:\nXác định máy gửi và máy nhận Định tuyến dữ liệu trong quá trình truyền thông Thiết lập kết nối giữa các tiến trình chạy trên những máy khác nhau Nếu không có địa chỉ IP, các máy tính sẽ không thể nhận biết và giao tiếp với nhau.\nVai trò của lớp InetAddress trong Java Lớp InetAddress đại diện cho một địa chỉ IP trong Java.\nThông qua lớp này, lập trình viên có thể:\nLấy địa chỉ IP của máy đang chạy chương trình Lấy tên máy (hostname) Phân giải tên miền sang địa chỉ IP Chuẩn bị thông tin để tạo Socket hoặc ServerSocket Hầu hết các chương trình lập trình mạng trong Java đều sử dụng InetAddress ở bước khởi tạo.\nPhân tích ý nghĩa các lệnh trong chương trình InetAddress.getLocalHost()\n→ Trả về đối tượng đại diện cho máy cục bộ (localhost).\ngetHostName()\n→ Lấy tên máy do hệ điều hành hoặc mạng gán.\ngetHostAddress()\n→ Lấy địa chỉ IP của máy dưới dạng chuỗi.\nViệc in ra hostname và IP giúp:\nKiểm tra cấu hình mạng Xác định đúng máy khi kết nối Client – Server Debug lỗi mạng Một số lưu ý khi lấy IP trong Java Khi máy không kết nối mạng, IP có thể là 127.0.0.1 Khi máy có nhiều card mạng (WiFi, LAN, VPN), IP trả về có thể không phải IP Internet Trên Server, hostname và IP thường khác máy cá nhân Ứng dụng thực tế Việc xác định IP của máy thường được sử dụng trong:\nChương trình Client – Server Thông báo IP Server cho Client kết nối Kiểm tra kết nối mạng LAN Ghi log và giám sát hệ thống Kết luận Qua bài học này, ta đã:\nHiểu vai trò của địa chỉ IP trong lập trình mạng Biết cách lấy IP bằng lớp InetAddress Chuẩn bị nền tảng cho các kỹ thuật TCP, UDP và RMI Liên hệ với học phần Lập trình Mạng máy tính Bài học này nằm trong nội dung mở đầu của học phần Lập trình Mạng máy tính (CMP180) tại Trường Đại học Công nghệ TP.HCM (HUTECH).\nTrong lộ trình môn học, sinh viên sẽ lần lượt tiếp cận các nội dung:\nKiến thức nền tảng về mạng và lập trình mạng Quản lý luồng nhập xuất (I/O) Quản lý địa chỉ và kết nối mạng Lập trình Socket TCP và UDP Xử lý đa tuyến, đa luồng Multicast UDP và Java RMI Thực hiện đồ án học phần cá nhân Mục tiêu của bài học Thông qua Bài 1, sinh viên sẽ:\nLàm quen với môi trường lập trình mạng bằng Java Hiểu được vai trò của địa chỉ IP trong giao tiếp mạng Biết cách sử dụng lớp InetAddress để lấy IP và hostname Chuẩn bị nền tảng cho các bài học tiếp theo về Socket và Server – Client ","permalink":"http://localhost:1313/blog/bai-viet-1/","summary":"GIỚI THIỆU HỌC PHẦN.","title":"Bài 1: Tổng quan khoá học"},{"content":"Trong lập trình mạng, nếu IP được xem như địa chỉ nhà của một máy tính trong mạng,\nthì Port (cổng) chính là số hiệu dùng để xác định chương trình hoặc dịch vụ cụ thể đang chạy trên máy đó.\nMột máy tính có thể chạy đồng thời nhiều ứng dụng mạng như Web Server, Database Server, Game Server hoặc Chat Server.\nMỗi ứng dụng bắt buộc phải gắn với một Port riêng để hệ điều hành có thể phân biệt và định tuyến dữ liệu chính xác.\nPort nằm ở đâu trong mô hình TCP/IP? Trong bộ giao thức TCP/IP, Port thuộc về Transport Layer (Tầng giao vận) và được sử dụng bởi hai giao thức chính là TCP và UDP.\nĐịa chỉ IP xác định máy nào sẽ nhận dữ liệu Port xác định ứng dụng nào trên máy đó sẽ xử lý dữ liệu Sự kết hợp giữa IP + Port tạo thành một Socket, là điểm cuối (endpoint) của quá trình giao tiếp mạng.\nCác loại Port phổ biến Port được đánh số từ 0 đến 65535 và được chia thành ba nhóm chính:\nInternet và các End Devices Trước khi tìm hiểu về Port, cần hiểu Internet được cấu thành từ hàng tỷ thiết bị đầu cuối (End Devices) như máy tính, điện thoại, máy chủ và các thiết bị IoT.\nCác thiết bị này kết nối với nhau thông qua nhiều lớp mạng khác nhau, và mỗi thiết bị khi tham gia giao tiếp mạng đều cần có địa chỉ IP và Port để định danh. Hình 2.1: Sơ đồ minh họa Internet và các thiết bị đầu cuối (End Devices) kết nối thông qua các mạng truy cập và mạng lõi.\nTrong quá trình giao tiếp mạng, một thiết bị không chỉ cần địa chỉ IP để xác định vị trí trong mạng, mà còn cần Port để xác định chính xác ứng dụng hoặc dịch vụ đang lắng nghe trên thiết bị đó.\nDo đó, Port đóng vai trò như “điểm tiếp nhận” (endpoint) cho các tiến trình mạng chạy trên cùng một máy.\nMô hình các tầng giao thức TCP/IP Để hiểu rõ Port hoạt động ở đâu và vì sao Server cần Port, ta cần nắm được mô hình giao thức TCP/IP – nền tảng của mọi ứng dụng mạng hiện nay.\nHình 2.2: Mô hình các tầng giao thức TCP/IP và các giao thức tiêu biểu tương ứng với từng tầng.\nTrong mô hình TCP/IP, địa chỉ IP hoạt động ở tầng Internet, giúp xác định thiết bị trong mạng.\nTrong khi đó, Port hoạt động ở tầng Transport (TCP/UDP), giúp xác định chính xác ứng dụng hoặc dịch vụ đang giao tiếp trên thiết bị đó.\nWell-known Ports (0 – 1023) Được dùng cho các dịch vụ chuẩn:\nPort 80: HTTP Port 443: HTTPS Port 21: FTP Port 25: SMTP Registered Ports (1024 – 49151) Thường dùng cho các ứng dụng phổ biến:\nPort 3306: MySQL Port 8080: Web Server thay thế port 80 Dynamic / Private Ports (49152 – 65535) Do hệ điều hành cấp phát tạm thời cho Client khi giao tiếp mạng.\nVì sao Server thường dùng cổng 8080? Cổng 8080 rất phổ biến trong quá trình phát triển và học tập vì:\nTránh xung đột với cổng 80 đang được hệ điều hành chiếm dụng Không cần quyền Administrator khi mở Server Phù hợp cho các Web Server thử nghiệm như: Apache Tomcat Spring Boot Node.js Lỗi thường gặp: “Address already in use” Lỗi này xảy ra khi Server cố gắng mở một Port đã bị chương trình khác chiếm dụng.\nNguyên nhân phổ biến:\nServer cũ chưa được tắt Port đang được dùng bởi dịch vụ khác Chạy nhiều Server cùng lúc Cách khắc phục:\nĐổi sang Port khác (ví dụ: 8080 → 9090) Kiểm tra Port đang sử dụng trong hệ điều hành Đảm bảo chỉ có một Server chạy tại một thời điểm Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), khái niệm Port sẽ được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Xây dựng mô hình Client – Server Java RMI và Multicast Việc hiểu rõ Port là nền tảng bắt buộc trước khi triển khai các ứng dụng mạng thực tế.\nKết luận Qua bài học này, ta đã:\nHiểu được Port là gì và vai trò của Port trong lập trình mạng Nắm được mối quan hệ giữa IP, Port và Socket Giải thích được lý do Server thường sử dụng cổng 8080 Chuẩn bị kiến thức nền cho các bài học tiếp theo về TCP và UDP ","permalink":"http://localhost:1313/blog/bai-viet-2/","summary":"MẠNG MÁY TÍNH \u0026amp; INTERNET.","title":"Bài 2: Kiến thức nền tảng?"},{"content":"Trong lập trình Java, luồng nhập xuất (Input / Output Streams) đóng vai trò trung gian giúp chương trình đọc và ghi dữ liệu từ nhiều nguồn khác nhau như bàn phím, file, console, bộ nhớ và sau này là socket mạng.\nHiểu rõ cơ chế luồng nhập xuất là bước nền bắt buộc trước khi đi vào lập trình Socket TCP, UDP hay Java RMI.\nLuồng (Stream) là gì? Luồng (Stream) là dòng dữ liệu di chuyển\ntừ nguồn → chương trình hoặc từ chương trình → đích.\nKhi Java đọc hoặc ghi dữ liệu, dữ liệu không đi trực tiếp mà luôn được đóng gói và truyền qua luồng.\nLuồng nhập xuất là gì? Luồng nhập xuất là cơ chế cho phép chương trình:\nNhận dữ liệu từ bên ngoài (Input) Ghi dữ liệu ra bên ngoài (Output) Luồng có thể kết nối với nhiều nguồn và đích khác nhau:\nFile Bàn phím Màn hình (console) Bộ nhớ Kết nối mạng (TCP / UDP) Dữ liệu trong luồng tồn tại dưới những dạng nào? Trong Java, dữ liệu trong luồng tồn tại dưới hai dạng chính:\nLuồng byte Luồng ký tự Việc chọn đúng loại luồng ảnh hưởng trực tiếp đến hiệu năng và tính chính xác của chương trình.\nLuồng byte trong Java Đặc điểm Dữ liệu được xử lý dưới dạng nhị phân Phù hợp với: File nhị phân Ảnh, video Socket mạng Dữ liệu phức tạp Các lớp gốc InputStream – luồng đọc byte OutputStream – luồng ghi byte Cả hai đều là lớp trừu tượng (abstract).\nCác luồng byte đọc phổ biến FileInputStream – đọc byte từ file ByteArrayInputStream – đọc từ mảng byte PipedInputStream – đọc từ luồng pipe Các luồng byte ghi phổ biến FileOutputStream – ghi byte vào file ByteArrayOutputStream – ghi vào mảng byte PipedOutputStream – ghi vào luồng pipe Mô hình đọc/ghi dữ liệu với Stream Quy trình chung khi làm việc với luồng:\nTạo đối tượng Stream Gắn Stream với nguồn hoặc đích Đọc/ghi dữ liệu trong vòng lặp Đóng Stream sau khi hoàn tất Luồng ký tự trong Java Đặc điểm Xử lý dữ liệu dạng Unicode Phù hợp với: File văn bản Chuỗi Dữ liệu hiển thị cho người dùng Các lớp gốc Reader – luồng đọc ký tự Writer – luồng ghi ký tự Các luồng ký tự đọc phổ biến FileReader – đọc file văn bản BufferedReader – đọc có bộ đệm StringReader – đọc chuỗi CharArrayReader – đọc mảng ký tự Các luồng ký tự ghi phổ biến FileWriter – ghi vào file văn bản BufferedWriter – ghi có bộ đệm PrintWriter – ghi dữ liệu dạng dễ đọc StringWriter – ghi chuỗi Luồng lọc dữ liệu (Filtered Streams) Luồng lọc dùng để chuyển đổi dữ liệu từ dạng byte/ký tự sang các kiểu dữ liệu khác.\nCác luồng lọc phổ biến DataInputStream DataOutputStream Cho phép đọc/ghi các kiểu dữ liệu nguyên thủy:\nint float double boolean char Đây là cầu nối giữa luồng thô và dữ liệu có kiểu trong Java.\nLưu trạng thái đối tượng – Serialization Serialization là gì? Serialization (chuỗi hóa) là quá trình chuyển đối tượng Java thành luồng byte để:\nLưu vào file Truyền qua mạng Phục hồi lại sau này Deserialization Ngược lại, Deserialization (giải chuỗi) là quá trình:\nĐọc byte Tái tạo lại đối tượng ban đầu Đây là nền tảng cho:\nLưu dữ liệu chương trình Java RMI Truyền object qua mạng Try-with-resources (TWR) Java hỗ trợ Try-with-resources để:\nTự động đóng stream Tránh rò rỉ tài nguyên Code gọn và an toàn hơn So với try-catch truyền thống, TWR:\nÍt lỗi hơn Dễ bảo trì hơn Được khuyến khích sử dụng Các lỗi I/O thường gặp Khi làm việc với luồng, một số exception phổ biến là:\nFileNotFoundException IOException EOFException UnsupportedEncodingException FileAlreadyExistsException AccessDeniedException SocketException MalformedURLException SerializationException InvalidPathException Việc bắt và xử lý exception đúng cách là yêu cầu bắt buộc trong lập trình Java.\nLiên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), luồng nhập xuất được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Truyền dữ liệu Client – Server Java RMI Multicast UDP Không hiểu I/O Stream → không thể làm mạng đúng cách.\nKết luận Qua bài học này, ta đã:\nHiểu khái niệm luồng nhập xuất trong Java Phân biệt luồng byte và luồng ký tự Nắm được cách đọc/ghi dữ liệu với Stream Biết vai trò của Serialization và Filtered Streams Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo Khi xử lý các tác vụ mạng (như gọi API), người mới học JS hay viết code lồng nhau kiểu này:\n1 2 3 4 5 6 7 8 9 10 // Cực hình Callback Hell getData(function(a) { getMoreData(a, function(b) { getMoreData(b, function(c) { getMoreData(c, function(d) { console.log(d); }); }); }); }); ","permalink":"http://localhost:1313/blog/bai-viet-3/","summary":"Tổng quan về Input/Output Streams trong Java – nền tảng cho xử lý file, console và lập trình mạng.","title":"Bài 3: Quản lý luồng nhập xuất trong Java"},{"content":"Trong lập trình mạng, trước khi chương trình có thể gửi hoặc nhận dữ liệu, điều quan trọng nhất là xác định đúng địa chỉ kết nối mạng. Nếu xác định sai địa chỉ, chương trình sẽ không thể giao tiếp, dù phần xử lý dữ liệu có đúng đến đâu.\nBài học này giúp bạn hiểu cách Java làm việc với địa chỉ IP, tên miền (DNS) và URL. Đây là nền tảng bắt buộc trước khi đi vào Socket TCP, UDP, Web Crawler và Java RMI.\nĐịa chỉ kết nối mạng là gì? Địa chỉ kết nối mạng là thông tin dùng để xác định máy nào trong mạng cần giao tiếp và dịch vụ nào trên máy đó sẽ xử lý dữ liệu.\nTrong Internet, địa chỉ kết nối thường bao gồm:\nĐịa chỉ IP Tên miền (Domain Name) Cổng (Port) Giao thức (Protocol) DNS – Domain Name System Hình 4.1 – Mô hình hoạt động của DNS (Domain Name System)\nClient gửi yêu cầu phân giải tên miền đến DNS Server, DNS trả về địa chỉ IP tương ứng để client kết nối đến server đích.*\nCon người dễ nhớ tên miền hơn các dãy số IP.\nDNS (Domain Name System) có nhiệm vụ ánh xạ tên miền sang địa chỉ IP, giúp client tìm đúng server cần kết nối.\nVí dụ:\ngoogle.com tương ứng với nhiều địa chỉ IP khác nhau www.cs.yale.edu tương ứng với 128.36.229.30 Nhờ DNS, người dùng không cần ghi nhớ địa chỉ IP khi truy cập Internet. Địa chỉ IPv4 IPv4 là dạng địa chỉ phổ biến, gồm 32 bit, thường được viết thành bốn nhóm số.\nVí dụ:\n192.168.1.1 8.8.8.8 Một số dải địa chỉ đặc biệt:\n127.x.x.x là loopback (localhost) 224.0.0.0 – 239.255.255.255 là multicast Lớp InetAddress trong Java Java cung cấp lớp InetAddress để làm việc với địa chỉ IP và DNS.\nLớp này thường được dùng để:\nPhân giải tên miền sang IP Kiểm tra loại địa chỉ Kiểm tra khả năng kết nối mạng Ví dụ minh họa:\n1 InetAddress address = InetAddress.getByName(\u0026#34;google.com\u0026#34;); URL – Uniform Resource Locator URL được dùng để xác định tài nguyên trên Internet như trang web, file hoặc dịch vụ.\nMột URL đầy đủ thường bao gồm các thành phần sau:\nGiao thức (Protocol) Tên miền (Host) Cổng (Port) Đường dẫn (Path) Chuỗi truy vấn (Query) Ví dụ một URL đầy đủ: https://www.hutech.edu.vn/admission?id=123\nURL cho biết lấy dữ liệu ở đâu và bằng cách nào.\nLớp URL trong Java Lớp URL cho phép chương trình Java:\nPhân tích các thành phần của URL Kết nối tới server Đọc dữ liệu từ Internet Ví dụ minh họa:\n1 URL url = new URL(\u0026#34;https://www.example.com\u0026#34;); Ý nghĩa của việc quản lý địa chỉ kết nối mạng Hiểu rõ cách quản lý địa chỉ mạng giúp:\nTránh kết nối sai server Chuẩn bị đúng địa chỉ cho Socket TCP/UDP Hiểu cách Web Crawler hoạt động Nắm vững mô hình Client – Server Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm địa chỉ kết nối mạng Biết vai trò của DNS và IPv4 Nắm được cách Java làm việc với InetAddress Hiểu cấu trúc và vai trò của URL Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-4/","summary":"Tìm hiểu cách Java quản lý địa chỉ mạng thông qua InetAddress, URL, URLConnection và DNS.","title":"Bài 4: Quản lý địa chỉ kết nối mạng trong Java"},{"content":"Trong lập trình mạng, TCP Socket là cơ chế quan trọng nhất để xây dựng các ứng dụng Client – Server có độ tin cậy cao.\nBài học này giúp bạn hiểu TCP là gì, vì sao cần TCP, và cách Java triển khai TCP thông qua Socket và ServerSocket.\nĐây là bước chuyển tiếp trực tiếp từ kiến thức địa chỉ mạng (IP, DNS, URL) sang giao tiếp dữ liệu thực tế giữa các chương trình.\nTCP là gì? TCP (Transmission Control Protocol) là giao thức truyền thông hướng kết nối, đảm bảo dữ liệu được truyền:\nĐúng thứ tự Đầy đủ Không bị mất mát Không bị trùng lặp Trước khi truyền dữ liệu, TCP yêu cầu thiết lập kết nối giữa hai bên, và chỉ khi kết nối thành công thì dữ liệu mới được trao đổi.\nVì sao sử dụng TCP? TCP được sử dụng khi ứng dụng yêu cầu độ tin cậy cao, ví dụ:\nỨng dụng chat Ứng dụng client–server Truyền file Game online theo lượt Hệ thống ngân hàng, thương mại điện tử TCP cung cấp các cơ chế quan trọng:\nĐảm bảo dữ liệu: gói tin bị mất sẽ được gửi lại Kiểm soát lỗi: phát hiện và sửa lỗi trong quá trình truyền Kiểm soát luồng: tránh làm quá tải phía nhận Giao tiếp hai chiều: cho phép gửi và nhận dữ liệu đồng thời Cơ chế hoạt động của TCP Quá trình giao tiếp TCP gồm ba giai đoạn chính:\nThiết lập kết nối (Bắt tay 3 bước – Three-way Handshake) Truyền dữ liệu Giải phóng kết nối Nhờ cơ chế này, TCP đảm bảo rằng hai bên luôn sẵn sàng trước khi truyền và kết thúc an toàn sau khi hoàn tất.\nMô hình Client – Server Các ứng dụng TCP thường hoạt động theo mô hình Client – Server.\nServer:\nChạy trước Lắng nghe yêu cầu kết nối Cung cấp dịch vụ Trả kết quả cho client Client:\nChạy sau Chủ động kết nối tới server Gửi yêu cầu Nhận phản hồi từ server Quá trình giao tiếp gồm:\nClient gửi yêu cầu Server xử lý Server trả kết quả cho client Socket trong Java Trong Java, Socket đại diện cho điểm cuối giao tiếp giữa client và server khi sử dụng TCP.\nSocket cho phép:\nGửi dữ liệu tới server Nhận dữ liệu từ server Giao tiếp hai chiều thông qua luồng nhập/xuất Ví dụ minh họa tạo Socket phía client:\n1 Socket socket = new Socket(\u0026#34;localhost\u0026#34;, 8080); ServerSocket trong Java ServerSocket được sử dụng ở phía server để:\nMở một cổng lắng nghe Chờ client kết nối Chấp nhận kết nối và tạo Socket giao tiếp ServerSocket đóng vai trò như cửa ngõ, cho phép các client kết nối vào server.\nVí dụ minh họa:\n1 ServerSocket server = new ServerSocket(8080); Luồng dữ liệu trong TCP Socket Sau khi kết nối TCP được thiết lập, client và server trao đổi dữ liệu thông qua các luồng:\nInputStream: dùng để đọc dữ liệu từ socket OutputStream: dùng để ghi dữ liệu vào socket Luồng dữ liệu này hoạt động tương tự như I/O Stream đã học ở bài trước,\nnhưng nguồn và đích là mạng thay vì file hay bàn phím.\nVí dụ ứng dụng: Trò chơi Oẳn Tù Tì Một bài tập tiêu biểu sử dụng TCP Socket là trò chơi Oẳn Tù Tì theo mô hình Client – Server.\nĐặc điểm Server quản lý luật chơi và điểm số Hai client gửi lựa chọn (kéo – búa – bao) Server xác định kết quả và gửi lại cho client Dữ liệu được truyền qua TCP để đảm bảo chính xác Thông qua bài tập này, sinh viên hiểu rõ:\nCách thiết lập kết nối TCP Cách trao đổi dữ liệu giữa nhiều client Cách xử lý lỗi mạng và ngoại lệ Ý nghĩa của lập trình TCP Socket Việc nắm vững TCP Socket giúp bạn:\nHiểu bản chất giao tiếp mạng Xây dựng hệ thống Client – Server thực tế Chuẩn bị cho các bài nâng cao như: Đa tuyến (Multi-thread) Socket UDP Java RMI Ứng dụng mạng phân tán Kết luận Qua bài học này, bạn đã:\nHiểu TCP là gì và vì sao cần TCP Nắm được mô hình Client – Server Biết vai trò của Socket và ServerSocket trong Java Hiểu cách dữ liệu được truyền qua TCP Chuẩn bị nền tảng cho các bài học UDP và xử lý đồng thời tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-5/","summary":"Giải thích mô hình Client–Server và cách lập trình Socket TCP trong Java – nền tảng cho giao tiếp mạng tin cậy.","title":"Bài 5: Lập trình Socket TCP trong Java"},{"content":"#Trong lập trình mạng, không phải lúc nào ứng dụng cũng cần độ tin cậy tuyệt đối như TCP.\nTrong nhiều trường hợp, điều quan trọng hơn là tốc độ truyền nhanh và độ trễ thấp.\nBài học này giới thiệu UDP Socket – cơ chế truyền dữ liệu không kết nối, được sử dụng rộng rãi trong các ứng dụng thời gian thực.\nUDP là gì? UDP (User Datagram Protocol) là giao thức truyền thông không hướng kết nối.\nĐiều này có nghĩa là:\nKhông thiết lập kết nối trước khi truyền Không đảm bảo dữ liệu đến nơi Không đảm bảo thứ tự gói tin Không tự động gửi lại gói tin bị mất UDP gửi dữ liệu theo từng datagram (gói tin độc lập).\nSo sánh TCP và UDP TCP UDP Có kết nối Không kết nối Đảm bảo dữ liệu Không đảm bảo Truyền theo luồng Truyền theo gói Độ trễ cao hơn Độ trễ thấp Phù hợp dữ liệu quan trọng Phù hợp dữ liệu thời gian thực Khi nào sử dụng UDP? UDP được sử dụng khi:\nCần truyền nhanh Có thể chấp nhận mất gói tin Dữ liệu được gửi liên tục Ví dụ ứng dụng UDP:\nTruyền video, audio trực tuyến Game online thời gian thực Chat broadcast DNS Multicast, streaming UDP Socket trong Java Java hỗ trợ UDP thông qua hai lớp chính:\nDatagramSocket: quản lý socket UDP DatagramPacket: đại diện cho gói dữ liệu UDP UDP không phân biệt client hay server rõ ràng như TCP.\nMỗi chương trình chỉ cần một DatagramSocket để gửi và nhận dữ liệu.\nDatagramPacket là gì? DatagramPacket là gói dữ liệu UDP, bao gồm:\nDữ liệu cần gửi Địa chỉ IP đích Số hiệu cổng Mỗi lần gửi hoặc nhận dữ liệu, UDP làm việc với một DatagramPacket riêng biệt.\nLuồng dữ liệu trong UDP UDP không có luồng InputStream / OutputStream như TCP.\nQuy trình truyền dữ liệu UDP:\nTạo DatagramSocket Tạo DatagramPacket chứa dữ liệu Gửi packet đi Nhận packet về Đọc dữ liệu từ packet Mỗi gói tin là độc lập, không liên quan đến các gói khác.\nĐặc điểm quan trọng của UDP Không kiểm soát lỗi Không kiểm soát luồng Không bắt tay kết nối Gửi nhanh, xử lý đơn giản Phù hợp truyền broadcast và multicast Chính vì vậy, UDP thường được dùng khi tốc độ quan trọng hơn độ chính xác tuyệt đối.\nÝ nghĩa của lập trình Socket UDP Nắm vững UDP giúp bạn:\nHiểu bản chất truyền dữ liệu không kết nối Xây dựng ứng dụng thời gian thực Phân biệt rõ TCP và UDP trong thiết kế hệ thống Chuẩn bị cho các chủ đề nâng cao như: Multicast UDP Java RMI Hệ thống phân tán Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính, UDP được sử dụng trong:\nSocket UDP Multicast Ứng dụng truyền tin nhanh Game, streaming, broadcast Hiểu UDP giúp bạn chọn đúng giao thức cho từng bài toán thực tế.\nKết luận Qua bài học này, bạn đã:\nHiểu UDP là gì và cơ chế hoạt động Phân biệt được TCP và UDP Biết vai trò của DatagramSocket và DatagramPacket Hiểu cách truyền dữ liệu không kết nối Chuẩn bị nền tảng cho bài Multicast UDP \u0026amp; Java RMI tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-6/","summary":"Giải thích giao thức UDP và cách Java lập trình Socket UDP – nền tảng cho truyền dữ liệu nhanh, không kết nối.","title":"Bài 6: Lập trình Socket UDP trong Java"},{"content":"Trong các ứng dụng mạng thực tế, đặc biệt là Server, chương trình thường phải xử lý nhiều yêu cầu cùng lúc.\nNếu chỉ sử dụng một luồng thực thi, server sẽ bị tắc nghẽn, các client phải chờ đợi và hiệu năng giảm nghiêm trọng.\nVì vậy, lập trình đa tuyến (Multithreading) và xử lý đồng thời (Concurrency) là kỹ thuật bắt buộc trong lập trình mạng.\nTuyến (Thread) là gì? Thread là một dòng điều khiển tuần tự bên trong một chương trình.\nMột chương trình (process) có thể chứa nhiều thread Các thread có thể chạy đồng thời Mỗi thread thực hiện một nhiệm vụ riêng Thread không phải là một chương trình độc lập,\nnó luôn thuộc về một process.\nProcess và Thread Process:\nCó không gian bộ nhớ riêng Chạy độc lập với process khác Tạo và chuyển đổi tốn nhiều tài nguyên Thread:\nChia sẻ bộ nhớ với các thread khác trong cùng process Tạo nhanh hơn process Chuyển đổi nhanh hơn Nhờ thread, chương trình có thể thực hiện nhiều công việc cùng lúc trong cùng một ứng dụng.\nVì sao cần lập trình đa tuyến? Lập trình đa tuyến giúp:\nTăng hiệu suất và khả năng đáp ứng Tận dụng thời gian chờ đợi (I/O, mạng, tải file) Chia nhỏ tác vụ và xử lý đồng thời Cải thiện trải nghiệm người dùng Trong lập trình mạng, đa tuyến cho phép server phục vụ nhiều client cùng lúc.\nThực thi Thread trong Java Trong Java, một thread bắt đầu chạy khi gọi phương thức start().\nKhi thread chạy, JVM thực thi mã trong phương thức run() Khi run() kết thúc, thread cũng kết thúc Một thread không thể start lại, muốn chạy lại phải tạo thread mới Thread cần có điều kiện dừng rõ ràng để tránh chạy vô hạn.\nỨng dụng đa tuyến trong lập trình mạng Ứng dụng Chat đa tuyến Một ví dụ tiêu biểu của đa tuyến trong mạng là ứng dụng chat nhiều client – một server.\nĐặc điểm:\nServer chấp nhận nhiều client kết nối cùng lúc Mỗi client được xử lý bởi một thread riêng Tin nhắn từ một client được gửi tới tất cả client khác Server ghi lại nội dung chat vào file log Thông qua ví dụ này, sinh viên hiểu rõ:\nCách server xử lý nhiều kết nối đồng thời Cách phối hợp giữa socket và thread Vai trò của đa tuyến trong ứng dụng mạng Xử lý đồng thời (Concurrency) Xử lý đồng thời xảy ra khi nhiều thread:\nChạy cùng lúc Truy cập tài nguyên chung (biến, file, bộ nhớ) Nếu không kiểm soát tốt, chương trình có thể gặp các vấn đề nghiêm trọng.\nRace Condition Race Condition xảy ra khi:\nNhiều thread cùng truy cập và thay đổi dữ liệu chung Kết quả phụ thuộc vào thứ tự thực thi không xác định Điều này có thể dẫn đến:\nDữ liệu sai lệch Kết quả không nhất quán Lỗi khó phát hiện Đồng bộ hóa (Synchronization) Để tránh race condition, Java cung cấp cơ chế đồng bộ hóa:\nĐảm bảo chỉ một thread được truy cập tài nguyên tại một thời điểm Giữ cho dữ liệu luôn nhất quán Đồng bộ hóa là nền tảng để xây dựng các ứng dụng an toàn và ổn định khi chạy đa tuyến.\nCác vấn đề thường gặp trong xử lý đồng thời Một số vấn đề phổ biến:\nRace condition: tranh chấp dữ liệu Deadlock: các thread chờ nhau vô hạn Livelock: các thread liên tục phản ứng nhưng không tiến triển Starvation: thread không bao giờ được cấp tài nguyên Những vấn đề này khiến lập trình đa tuyến trở nên phức tạp và khó debug.\nLập lịch Thread trong Java Java sử dụng cơ chế lập lịch theo độ ưu tiên:\nMỗi thread có độ ưu tiên từ MIN_PRIORITY đến MAX_PRIORITY JVM chọn thread runnable có độ ưu tiên cao hơn để chạy Thread có thể nhường CPU cho thread khác bằng cách gọi yield() Việc hiểu cơ chế lập lịch giúp lập trình viên thiết kế thread hợp lý hơn.\nÝ nghĩa của lập trình đa tuyến và xử lý đồng thời Nắm vững kiến thức bài này giúp bạn:\nXây dựng server xử lý nhiều client Viết ứng dụng mạng hiệu năng cao Tránh lỗi tranh chấp dữ liệu Chuẩn bị cho các chủ đề nâng cao như: Server đa tuyến Pooling Threads Multicast UDP Java RMI Hệ thống phân tán Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm thread và multithreading Phân biệt process và thread Biết vai trò của đa tuyến trong lập trình mạng Hiểu các vấn đề xử lý đồng thời và race condition Chuẩn bị nền tảng cho các bài học nâng cao tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-7/","summary":"Giải thích lập trình đa tuyến và xử lý đồng thời trong Java – nền tảng cho các ứng dụng mạng nhiều client và hệ thống phân tán.","title":"Bài 7: Lập trình đa tuyến và xử lý đồng thời trong Java"},{"content":"Buổi 8 gồm 2 phần lớn:\nMulticast UDP: gửi dữ liệu từ một nguồn đến nhiều máy nhận cùng lúc (1 → N). Java RMI: gọi phương thức từ xa giữa các ứng dụng Java như gọi hàm bình thường (Remote Method Invocation). Đây là các kỹ thuật thường gặp trong streaming, trò chuyện nhóm, giám sát từ xa và hệ thống phân tán.\n1) UDP Multicast Unicast, Broadcast và Multicast Trong mạng máy tính có 3 kiểu gửi dữ liệu phổ biến:\nUnicast: 1 nguồn → 1 đích\nVí dụ: bạn mở một trang web, server trả dữ liệu cho riêng bạn.\nBroadcast: 1 nguồn → tất cả máy trong mạng nội bộ\nVí dụ: một thông báo phát cho toàn bộ LAN.\nMulticast: 1 nguồn → một nhóm máy đã đăng ký nhận dữ liệu\nVí dụ: server phát stream video cho nhóm người xem cùng lúc.\nMulticast là cách truyền hiệu quả khi nhiều máy cùng cần nhận một nội dung giống nhau.\nTại sao dùng UDP Multicast? UDP Multicast thường được dùng vì:\nHiệu suất cao: gửi 1 lần nhưng nhiều máy nhận → giảm tải mạng và server. Đơn giản, nhanh: UDP là kiểu “gửi và quên”, không phải chờ xác nhận. Tối ưu trong LAN: phù hợp môi trường mạng nội bộ (Local Area Network). Rất hợp streaming: audio/video cần tốc độ và độ trễ thấp hơn là đảm bảo tuyệt đối. Ứng dụng của Multicast Multicast có thể dùng trong:\nTruyền phát multimedia trực tiếp (audio/video streaming) Trò chuyện nhóm, hội thoại nhóm Quảng bá thông tin cấu hình mạng và cập nhật trong hệ thống mạng Game nhiều người chơi (gửi trạng thái game cho nhiều người) Phát thông tin trạng thái/cảnh báo cho nhiều thiết bị Phát tán cập nhật phần mềm trong mạng nội bộ Địa chỉ Multicast IPv4 Trong IPv4:\nClass D là dải địa chỉ dành cho multicast Dải địa chỉ multicast thường gặp: 224.0.0.0 – 239.255.255.255 Một số nhóm multicast hay được nhắc:\n224.0.0.1: tất cả host trong local subnet Multicast Group là gì? Multicast hoạt động theo “nhóm”:\nMột multicast group giống như một kênh. Máy nào muốn nhận dữ liệu phải tham gia nhóm (join group). Khi rời nhóm thì không nhận dữ liệu nữa. Multicast trong Java Java hỗ trợ multicast qua lớp:\njava.net.MulticastSocket (kế thừa từ DatagramSocket) Một số thao tác quan trọng:\njoinGroup(...): tham gia nhóm multicast leaveGroup(...): rời nhóm multicast setTimeToLive(ttl): đặt TTL (thời gian sống của gói tin, qua bao nhiêu router) Quy trình gửi dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket Tham gia nhóm multicast Tạo DatagramPacket chứa dữ liệu + địa chỉ nhóm + port Gửi packet Rời nhóm Ví dụ minh họa (ngắn, chỉ để hiểu):\n1 2 3 4 5 6 7 8 9 10 11 12 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(); socket.joinGroup(group); socket.setTimeToLive(5); byte[] data = \u0026#34;Hello Multicast\u0026#34;.getBytes(); DatagramPacket packet = new DatagramPacket(data, data.length, group, 9876); socket.send(packet); socket.leaveGroup(group); socket.close(); Quy trình nhận dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket lắng nghe trên port Tham gia nhóm multicast Tạo DatagramPacket rỗng để nhận dữ liệu Gọi receive() để chờ gói tin gửi về Đọc dữ liệu từ packet Rời nhóm và đóng socket Ví dụ minh họa (ngắn):\n1 2 3 4 5 6 7 8 9 10 11 12 13 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(9876); socket.joinGroup(group); byte[] buf = new byte[1024]; DatagramPacket packet = new DatagramPacket(buf, buf.length); socket.receive(packet); String msg = new String(packet.getData(), 0, packet.getLength()); System.out.println(\u0026#34;Received: \u0026#34; + msg); socket.leaveGroup(group); socket.close(); 2) Java RMI Java RMI là gì? RMI (Remote Method Invocation) cho phép chương trình Java:\nGọi phương thức của một đối tượng nằm trên máy khác Cảm giác giống như gọi method trong cùng chương trình Nói đơn giản:\nClient gọi: remoteObject.sum(1,2) Server thực thi thật và trả kết quả về cho client RMI giúp che giấu toàn bộ chi tiết mạng phía sau, người lập trình chỉ tập trung vào logic.\nVì sao dùng Java RMI? Java RMI được sử dụng vì:\nTích hợp sẵn trong Java, dễ triển khai nếu cả client và server đều dùng Java Gọi phương thức từ xa đơn giản như gọi hàm thông thường Hỗ trợ dữ liệu phức tạp: đối tượng, mảng, class tự định nghĩa Tự động xử lý giao tiếp mạng thông qua cơ chế stub / skeleton Dựa trên TCP/IP nên tương đối ổn định và tin cậy Hạn chế của Java RMI Một số điểm hạn chế cần lưu ý:\nPhụ thuộc Java: chủ yếu phù hợp Java ↔ Java Thiết kế dịch vụ phức tạp vẫn cần tổ chức tốt (đặc biệt khi dùng callback) Quản lý phiên và kết nối không mạnh như các giải pháp hiện đại Bảo mật cần cấu hình cẩn thận trong môi trường thực tế Ý tưởng kiến trúc RMI (hiểu nhanh) Trong Java RMI có các thành phần chính:\nRemote Interface\nKhai báo các phương thức cho phép gọi từ xa\nServer Implementation\nLớp cài đặt interface, chứa logic xử lý thật\nRMI Registry\nNơi đăng ký service để client tìm thấy server\nClient\nTìm (lookup) service trong registry và gọi phương thức\nCác bước triển khai RMI (tóm tắt) Định nghĩa Remote Interface Cài đặt interface bằng một class server (remote object) Viết chương trình server: tạo object và bind vào registry Viết chương trình client: lookup registry và gọi method Chạy RMI registry, chạy server, sau đó chạy client Ví dụ ứng dụng RMI Một số ví dụ thường gặp:\nTính tổng 2 số từ xa Dịch vụ quản lý tài khoản ATM Dịch vụ giám sát nhiệt độ có callback (server gọi ngược lại client) Bài tập gợi ý theo đúng nội dung buổi 8 BT8.01: Mô phỏng streaming video\n(1 server phát, nhiều client nhận dữ liệu)\nBT8.02: Server quản lý tài khoản ATM bằng RMI\n(thêm user, đăng nhập, gửi/rút tiền, lưu lịch sử giao dịch)\nKết luận Qua bài học này, bạn đã:\nHiểu sự khác nhau giữa Unicast, Broadcast và Multicast Nắm được vì sao Multicast UDP phù hợp cho truyền dữ liệu nhóm và streaming Biết cách Java hỗ trợ multicast qua MulticastSocket Hiểu Java RMI và cơ chế gọi phương thức từ xa Chuẩn bị nền tảng cho các bài ứng dụng mạng phân tán và đồ án học phần ","permalink":"http://localhost:1313/blog/bai-viet-8/","summary":"Giải thích Multicast UDP (gửi 1-n) và Java RMI (gọi phương thức từ xa) – nền tảng cho ứng dụng nhóm và hệ phân tán.","title":"Bài 8: Multicast UDP và Java RMI"},{"content":"Sau khi hoàn thành các bài về TCP, UDP, đa tuyến và xử lý đồng thời,\nchúng ta đã có đủ nền tảng để xây dựng một ứng dụng mạng hoàn chỉnh.\nBài học này giúp bạn xâu chuỗi toàn bộ kiến thức đã học,\nhiểu rõ mỗi công nghệ dùng trong trường hợp nào,\nvà cách thiết kế một hệ thống mạng đúng tư duy kỹ sư.\nNhìn lại các mô hình giao tiếp mạng đã học Trong lập trình mạng, các ứng dụng thường được xây dựng dựa trên mô hình Client – Server.\nClient: gửi yêu cầu, nhập dữ liệu, hiển thị kết quả Server: xử lý logic, quản lý dữ liệu, trả kết quả Tùy bài toán, ta lựa chọn giao thức và mô hình phù hợp.\nSo sánh TCP, UDP và Multicast TCP – Giao tiếp tin cậy TCP phù hợp khi:\nCần đảm bảo dữ liệu đúng và đủ Cần kết nối ổn định, hai chiều Ví dụ: chat, truyền file, game theo lượt, hệ thống ngân hàng Đặc trưng:\nCó bắt tay 3 bước Có kiểm soát lỗi, kiểm soát luồng Tốn tài nguyên hơn UDP UDP – Giao tiếp nhanh, không kết nối UDP phù hợp khi:\nƯu tiên tốc độ Chấp nhận mất gói Ví dụ: game thời gian thực, streaming, cảm biến Đặc trưng:\nKhông kết nối Không đảm bảo thứ tự Ít độ trễ UDP Multicast – Truyền dữ liệu nhóm Multicast được dùng khi:\nMột nguồn → nhiều người nhận Dữ liệu giống nhau cho tất cả client Ví dụ: livestream, thông báo hệ thống, truyền trạng thái Ưu điểm:\nGiảm tải server Tiết kiệm băng thông Phù hợp mạng LAN Vai trò của đa tuyến (Multithreading) Trong thực tế, server không thể xử lý từng client một cách tuần tự.\nĐa tuyến giúp:\nNhiều client kết nối cùng lúc Không client nào bị “đóng băng” Tăng khả năng mở rộng hệ thống Ví dụ:\nServer chat: mỗi client là một thread Server TCP: mỗi socket được xử lý riêng Thiết kế một ứng dụng mạng hoàn chỉnh Khi thiết kế, cần xác định rõ:\nGiao thức: TCP hay UDP? Mô hình: 1–1, 1–n, n–n? Đồng thời hay tuần tự? Client gửi gì? Server xử lý gì? Một thiết kế tốt luôn:\nPhân tách rõ giao tiếp – xử lý – dữ liệu Dễ mở rộng Dễ bảo trì Liên hệ với đồ án học phần Các đồ án như:\nChat đa tuyến Oẳn Tù Tì client–server Streaming UDP Dịch vụ RMI Đều là sự kết hợp của các kiến thức đã học,\nkhông phải nội dung mới.\nKết luận Qua bài học này, bạn đã:\nHệ thống lại toàn bộ kiến thức lập trình mạng Hiểu rõ khi nào dùng TCP, UDP, Multicast Nắm được vai trò của đa tuyến Biết cách tư duy thiết kế một ứng dụng mạng hoàn chỉnh Đây là bước chuẩn bị quan trọng trước khi vận dụng toàn bộ kiến thức vào một hệ thống thực tế.\n","permalink":"http://localhost:1313/blog/bai-viet-9/","summary":"Tổng hợp kiến thức TCP, UDP, đa tuyến và cách thiết kế ứng dụng mạng Client–Server hoàn chỉnh.","title":"Bài 9: Tổng hợp kiến thức \u0026 thiết kế ứng dụng mạng"},{"content":"Bài cuối cùng của học phần không nhằm giới thiệu công nghệ mới,\nmà tập trung vào cách vận dụng kiến thức đã học vào thực tế.\nĐây là giai đoạn chuyển từ:\n“Biết dùng” → “Biết thiết kế” → “Biết đánh giá hệ thống”\nTư duy vận dụng kiến thức Một ứng dụng mạng hoàn chỉnh cần trả lời được các câu hỏi:\nVì sao chọn TCP mà không phải UDP? Vì sao cần đa tuyến? Server có chịu được nhiều client không? Hệ thống có mở rộng được không? Đây chính là tư duy kỹ sư, không phải chỉ “chạy được là xong”.\nĐánh giá một ứng dụng mạng Khi hoàn thiện hệ thống, cần xem xét:\n1. Tính đúng đắn Dữ liệu có truyền đúng không? Có mất gói không? Có xử lý lỗi không? 2. Tính đồng thời Nhiều client có dùng chung được không? Có bị treo server không? Có race condition không? 3. Hiệu năng Độ trễ thế nào? Server có bị quá tải không? Có tách luồng hợp lý không? Liên hệ với các mô hình phân tán Các hệ thống đã học là nền tảng cho:\nHệ thống client–server lớn Ứng dụng phân tán Microservices Cloud services Java RMI, TCP đa tuyến hay UDP Multicast\nđều là những viên gạch đầu tiên.\nTừ học phần đến thực tế Sau học phần này, bạn có thể tiếp cận:\nWebSocket REST API gRPC Message Queue (Kafka, RabbitMQ) Hệ thống realtime Tư duy lập trình mạng không thay đổi, chỉ công nghệ thay đổi.\nTổng kết toàn bộ học phần Qua toàn bộ chuỗi bài, bạn đã:\nHiểu cách dữ liệu đi qua mạng Làm việc với TCP, UDP, Multicast Xử lý đa tuyến và đồng thời Tiếp cận lập trình phân tán với RMI Có tư duy thiết kế hệ thống mạng Lời kết Lập trình mạng không chỉ là code socket,\nmà là hiểu cách các hệ thống nói chuyện với nhau.\nNếu bạn hiểu được điều đó,\nbạn đã vượt xa mức “học để qua môn”.\n","permalink":"http://localhost:1313/blog/bai-viet-10/","summary":"Vận dụng toàn bộ kiến thức lập trình mạng để xây dựng, đánh giá và hoàn thiện một ứng dụng thực tế.","title":"Bài 10: Hoàn thiện \u0026 vận dụng lập trình mạng"},{"content":"Lời mở đầu Có những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\nMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\nHọc tập Những năm đại học trôi qua nhanh hơn mình từng nghĩ. Ngày mới bước chân vào giảng đường, mình vẫn còn khá mơ hồ về ngành học, về tương lai, về chính bản thân mình sẽ trở thành ai sau bốn năm. Nhưng rồi từng môn học, từng bài tập nhóm, từng đồ án kéo mình lại gần hơn với cách một hệ thống được hình thành và vận hành.\nHệ thống thông tin không chỉ là lập trình, cũng không đơn thuần là công nghệ. Đó là câu chuyện về con người, quy trình và dữ liệu. Mình học cách đặt câu hỏi, học cách lắng nghe yêu cầu, học cách vẽ ra những sơ đồ tưởng chừng khô khan nhưng lại chứa rất nhiều suy nghĩ phía sau. Dần dần, mình nhận ra mình thích phần “hiểu vấn đề” hơn là chỉ chăm chăm vào lời giải.\nĐịnh hướng Ở thời điểm hiện tại, mình đang định hướng theo con đường Business Analyst (BA). Mình hứng thú với vai trò đứng giữa – không quá xa kỹ thuật, cũng không tách rời nghiệp vụ. Đó là nơi cần sự rõ ràng trong tư duy, sự kiên nhẫn trong giao tiếp và khả năng chuyển hóa những điều mơ hồ thành thứ có thể triển khai được.\nMình không nghĩ BA là một vị trí “nhẹ nhàng” hay “an toàn”. Ngược lại, đó là công việc đòi hỏi phải học rất nhiều, sai rất nhiều và sửa rất nhiều. Nhưng chính điều đó khiến mình thấy phù hợp. Mình muốn hiểu hệ thống trước khi xây dựng nó, muốn biết vì sao người ta see cần một chức năng, chứ không chỉ là nó được viết như thế nào.\nBlog Blog này ra đời khá tự nhiên, giống như một cuốn sổ mở rộng hơn là một trang thể hiện điều gì đó to tát. Mình viết để nhớ, để hệ thống lại những gì đã học, và đôi khi là để sắp xếp lại suy nghĩ của chính mình.\nỞ đây có thể là kiến thức về Hệ thống thông tin, về phân tích nghiệp vụ, về lập trình, hoặc đơn giản là những trải nghiệm học tập và va chạm trong quá trình làm đồ án, làm việc nhóm, và chuẩn bị bước ra môi trường thực tế. Mình không mong mọi thứ phải hoàn hảo, chỉ mong nó thật và có ích cho ai đó đang đi trên con đường tương tự.\nLời kết Mình đang ở một giai đoạn chưa thể gọi là trưởng thành, nhưng cũng không còn quá non nớt. Vẫn đang học, vẫn đang thử, vẫn đang sai và sửa mỗi ngày. Nếu có một điều mình mong giữ được lâu nhất, thì đó là sự tò mò và tinh thần học hỏi – những thứ giúp mình không đứng yên giữa rất nhiều lựa chọn ngoài kia.\nCảm ơn bạn đã ghé qua và đọc những dòng này. Hy vọng ở một thời điểm nào đó, những chia sẻ nhỏ ở đây sẽ chạm đến bạn – dù chỉ là một chút. \u0026ldquo;Học để chia sẻ, chia sẻ để học nhiều hơn.\u0026rdquo;\nLiên hệ Nếu bạn muốn gửi cho mình vài dòng trao đổi,\nbạn có thể liên hệ với mình qua Email hoặc GitHub ,Facebook dưới đây.\nCảm ơn bạn đã ghé thăm blog! ","permalink":"http://localhost:1313/about/","summary":"\u003ch2 id=\"lời-mở-đầu\"\u003eLời mở đầu\u003c/h2\u003e\n\u003cp\u003eCó những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\u003c/p\u003e\n\u003cp\u003eMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\u003c/p\u003e","title":"Giới thiệu"},{"content":"Trong lập trình mạng, trước khi kết nối, ta phải biết \u0026ldquo;địa chỉ nhà\u0026rdquo; (IP) của mình và đối phương. Java cung cấp class\nHình 1.1: Hiệu ứng Dunning–Kruger – mức độ tự tin thay đổi theo kinh nghiệm học tập\nGóc nhìn học tập: Hiệu ứng Dunning–Kruger InetAddress để làm việc này.\nĐịa chỉ IP là gì trong lập trình mạng? IP (Internet Protocol Address) là địa chỉ định danh của một thiết bị khi tham gia vào mạng máy tính.\nTrong lập trình mạng, IP đóng vai trò quan trọng trong việc:\nXác định máy gửi và máy nhận Định tuyến dữ liệu trong quá trình truyền thông Thiết lập kết nối giữa các tiến trình chạy trên những máy khác nhau Nếu không có địa chỉ IP, các máy tính sẽ không thể nhận biết và giao tiếp với nhau.\nVai trò của lớp InetAddress trong Java Lớp InetAddress đại diện cho một địa chỉ IP trong Java.\nThông qua lớp này, lập trình viên có thể:\nLấy địa chỉ IP của máy đang chạy chương trình Lấy tên máy (hostname) Phân giải tên miền sang địa chỉ IP Chuẩn bị thông tin để tạo Socket hoặc ServerSocket Hầu hết các chương trình lập trình mạng trong Java đều sử dụng InetAddress ở bước khởi tạo.\nPhân tích ý nghĩa các lệnh trong chương trình InetAddress.getLocalHost()\n→ Trả về đối tượng đại diện cho máy cục bộ (localhost).\ngetHostName()\n→ Lấy tên máy do hệ điều hành hoặc mạng gán.\ngetHostAddress()\n→ Lấy địa chỉ IP của máy dưới dạng chuỗi.\nViệc in ra hostname và IP giúp:\nKiểm tra cấu hình mạng Xác định đúng máy khi kết nối Client – Server Debug lỗi mạng Một số lưu ý khi lấy IP trong Java Khi máy không kết nối mạng, IP có thể là 127.0.0.1 Khi máy có nhiều card mạng (WiFi, LAN, VPN), IP trả về có thể không phải IP Internet Trên Server, hostname và IP thường khác máy cá nhân Ứng dụng thực tế Việc xác định IP của máy thường được sử dụng trong:\nChương trình Client – Server Thông báo IP Server cho Client kết nối Kiểm tra kết nối mạng LAN Ghi log và giám sát hệ thống Kết luận Qua bài học này, ta đã:\nHiểu vai trò của địa chỉ IP trong lập trình mạng Biết cách lấy IP bằng lớp InetAddress Chuẩn bị nền tảng cho các kỹ thuật TCP, UDP và RMI Liên hệ với học phần Lập trình Mạng máy tính Bài học này nằm trong nội dung mở đầu của học phần Lập trình Mạng máy tính (CMP180) tại Trường Đại học Công nghệ TP.HCM (HUTECH).\nTrong lộ trình môn học, sinh viên sẽ lần lượt tiếp cận các nội dung:\nKiến thức nền tảng về mạng và lập trình mạng Quản lý luồng nhập xuất (I/O) Quản lý địa chỉ và kết nối mạng Lập trình Socket TCP và UDP Xử lý đa tuyến, đa luồng Multicast UDP và Java RMI Thực hiện đồ án học phần cá nhân Mục tiêu của bài học Thông qua Bài 1, sinh viên sẽ:\nLàm quen với môi trường lập trình mạng bằng Java Hiểu được vai trò của địa chỉ IP trong giao tiếp mạng Biết cách sử dụng lớp InetAddress để lấy IP và hostname Chuẩn bị nền tảng cho các bài học tiếp theo về Socket và Server – Client ","permalink":"http://localhost:1313/blog/bai-viet-1/","summary":"GIỚI THIỆU HỌC PHẦN.","title":"Bài 1: Tổng quan khoá học"},{"content":"Trong lập trình mạng, nếu IP được xem như địa chỉ nhà của một máy tính trong mạng,\nthì Port (cổng) chính là số hiệu dùng để xác định chương trình hoặc dịch vụ cụ thể đang chạy trên máy đó.\nMột máy tính có thể chạy đồng thời nhiều ứng dụng mạng như Web Server, Database Server, Game Server hoặc Chat Server.\nMỗi ứng dụng bắt buộc phải gắn với một Port riêng để hệ điều hành có thể phân biệt và định tuyến dữ liệu chính xác.\nPort nằm ở đâu trong mô hình TCP/IP? Trong bộ giao thức TCP/IP, Port thuộc về Transport Layer (Tầng giao vận) và được sử dụng bởi hai giao thức chính là TCP và UDP.\nĐịa chỉ IP xác định máy nào sẽ nhận dữ liệu Port xác định ứng dụng nào trên máy đó sẽ xử lý dữ liệu Sự kết hợp giữa IP + Port tạo thành một Socket, là điểm cuối (endpoint) của quá trình giao tiếp mạng.\nCác loại Port phổ biến Port được đánh số từ 0 đến 65535 và được chia thành ba nhóm chính:\nInternet và các End Devices Trước khi tìm hiểu về Port, cần hiểu Internet được cấu thành từ hàng tỷ thiết bị đầu cuối (End Devices) như máy tính, điện thoại, máy chủ và các thiết bị IoT.\nCác thiết bị này kết nối với nhau thông qua nhiều lớp mạng khác nhau, và mỗi thiết bị khi tham gia giao tiếp mạng đều cần có địa chỉ IP và Port để định danh. Hình 2.1: Sơ đồ minh họa Internet và các thiết bị đầu cuối (End Devices) kết nối thông qua các mạng truy cập và mạng lõi.\nTrong quá trình giao tiếp mạng, một thiết bị không chỉ cần địa chỉ IP để xác định vị trí trong mạng, mà còn cần Port để xác định chính xác ứng dụng hoặc dịch vụ đang lắng nghe trên thiết bị đó.\nDo đó, Port đóng vai trò như “điểm tiếp nhận” (endpoint) cho các tiến trình mạng chạy trên cùng một máy.\nMô hình các tầng giao thức TCP/IP Để hiểu rõ Port hoạt động ở đâu và vì sao Server cần Port, ta cần nắm được mô hình giao thức TCP/IP – nền tảng của mọi ứng dụng mạng hiện nay.\nHình 2.2: Mô hình các tầng giao thức TCP/IP và các giao thức tiêu biểu tương ứng với từng tầng.\nTrong mô hình TCP/IP, địa chỉ IP hoạt động ở tầng Internet, giúp xác định thiết bị trong mạng.\nTrong khi đó, Port hoạt động ở tầng Transport (TCP/UDP), giúp xác định chính xác ứng dụng hoặc dịch vụ đang giao tiếp trên thiết bị đó.\nWell-known Ports (0 – 1023) Được dùng cho các dịch vụ chuẩn:\nPort 80: HTTP Port 443: HTTPS Port 21: FTP Port 25: SMTP Registered Ports (1024 – 49151) Thường dùng cho các ứng dụng phổ biến:\nPort 3306: MySQL Port 8080: Web Server thay thế port 80 Dynamic / Private Ports (49152 – 65535) Do hệ điều hành cấp phát tạm thời cho Client khi giao tiếp mạng.\nVì sao Server thường dùng cổng 8080? Cổng 8080 rất phổ biến trong quá trình phát triển và học tập vì:\nTránh xung đột với cổng 80 đang được hệ điều hành chiếm dụng Không cần quyền Administrator khi mở Server Phù hợp cho các Web Server thử nghiệm như: Apache Tomcat Spring Boot Node.js Lỗi thường gặp: “Address already in use” Lỗi này xảy ra khi Server cố gắng mở một Port đã bị chương trình khác chiếm dụng.\nNguyên nhân phổ biến:\nServer cũ chưa được tắt Port đang được dùng bởi dịch vụ khác Chạy nhiều Server cùng lúc Cách khắc phục:\nĐổi sang Port khác (ví dụ: 8080 → 9090) Kiểm tra Port đang sử dụng trong hệ điều hành Đảm bảo chỉ có một Server chạy tại một thời điểm Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), khái niệm Port sẽ được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Xây dựng mô hình Client – Server Java RMI và Multicast Việc hiểu rõ Port là nền tảng bắt buộc trước khi triển khai các ứng dụng mạng thực tế.\nKết luận Qua bài học này, ta đã:\nHiểu được Port là gì và vai trò của Port trong lập trình mạng Nắm được mối quan hệ giữa IP, Port và Socket Giải thích được lý do Server thường sử dụng cổng 8080 Chuẩn bị kiến thức nền cho các bài học tiếp theo về TCP và UDP ","permalink":"http://localhost:1313/blog/bai-viet-2/","summary":"MẠNG MÁY TÍNH \u0026amp; INTERNET.","title":"Bài 2: Kiến thức nền tảng?"},{"content":"Trong lập trình Java, luồng nhập xuất (Input / Output Streams) đóng vai trò trung gian giúp chương trình đọc và ghi dữ liệu từ nhiều nguồn khác nhau như bàn phím, file, console, bộ nhớ và sau này là socket mạng.\nHiểu rõ cơ chế luồng nhập xuất là bước nền bắt buộc trước khi đi vào lập trình Socket TCP, UDP hay Java RMI.\nLuồng (Stream) là gì? Luồng (Stream) là dòng dữ liệu di chuyển\ntừ nguồn → chương trình hoặc từ chương trình → đích.\nKhi Java đọc hoặc ghi dữ liệu, dữ liệu không đi trực tiếp mà luôn được đóng gói và truyền qua luồng.\nLuồng nhập xuất là gì? Luồng nhập xuất là cơ chế cho phép chương trình:\nNhận dữ liệu từ bên ngoài (Input) Ghi dữ liệu ra bên ngoài (Output) Luồng có thể kết nối với nhiều nguồn và đích khác nhau:\nFile Bàn phím Màn hình (console) Bộ nhớ Kết nối mạng (TCP / UDP) Dữ liệu trong luồng tồn tại dưới những dạng nào? Trong Java, dữ liệu trong luồng tồn tại dưới hai dạng chính:\nLuồng byte Luồng ký tự Việc chọn đúng loại luồng ảnh hưởng trực tiếp đến hiệu năng và tính chính xác của chương trình.\nLuồng byte trong Java Đặc điểm Dữ liệu được xử lý dưới dạng nhị phân Phù hợp với: File nhị phân Ảnh, video Socket mạng Dữ liệu phức tạp Các lớp gốc InputStream – luồng đọc byte OutputStream – luồng ghi byte Cả hai đều là lớp trừu tượng (abstract).\nCác luồng byte đọc phổ biến FileInputStream – đọc byte từ file ByteArrayInputStream – đọc từ mảng byte PipedInputStream – đọc từ luồng pipe Các luồng byte ghi phổ biến FileOutputStream – ghi byte vào file ByteArrayOutputStream – ghi vào mảng byte PipedOutputStream – ghi vào luồng pipe Mô hình đọc/ghi dữ liệu với Stream Quy trình chung khi làm việc với luồng:\nTạo đối tượng Stream Gắn Stream với nguồn hoặc đích Đọc/ghi dữ liệu trong vòng lặp Đóng Stream sau khi hoàn tất Luồng ký tự trong Java Đặc điểm Xử lý dữ liệu dạng Unicode Phù hợp với: File văn bản Chuỗi Dữ liệu hiển thị cho người dùng Các lớp gốc Reader – luồng đọc ký tự Writer – luồng ghi ký tự Các luồng ký tự đọc phổ biến FileReader – đọc file văn bản BufferedReader – đọc có bộ đệm StringReader – đọc chuỗi CharArrayReader – đọc mảng ký tự Các luồng ký tự ghi phổ biến FileWriter – ghi vào file văn bản BufferedWriter – ghi có bộ đệm PrintWriter – ghi dữ liệu dạng dễ đọc StringWriter – ghi chuỗi Luồng lọc dữ liệu (Filtered Streams) Luồng lọc dùng để chuyển đổi dữ liệu từ dạng byte/ký tự sang các kiểu dữ liệu khác.\nCác luồng lọc phổ biến DataInputStream DataOutputStream Cho phép đọc/ghi các kiểu dữ liệu nguyên thủy:\nint float double boolean char Đây là cầu nối giữa luồng thô và dữ liệu có kiểu trong Java.\nLưu trạng thái đối tượng – Serialization Serialization là gì? Serialization (chuỗi hóa) là quá trình chuyển đối tượng Java thành luồng byte để:\nLưu vào file Truyền qua mạng Phục hồi lại sau này Deserialization Ngược lại, Deserialization (giải chuỗi) là quá trình:\nĐọc byte Tái tạo lại đối tượng ban đầu Đây là nền tảng cho:\nLưu dữ liệu chương trình Java RMI Truyền object qua mạng Try-with-resources (TWR) Java hỗ trợ Try-with-resources để:\nTự động đóng stream Tránh rò rỉ tài nguyên Code gọn và an toàn hơn So với try-catch truyền thống, TWR:\nÍt lỗi hơn Dễ bảo trì hơn Được khuyến khích sử dụng Các lỗi I/O thường gặp Khi làm việc với luồng, một số exception phổ biến là:\nFileNotFoundException IOException EOFException UnsupportedEncodingException FileAlreadyExistsException AccessDeniedException SocketException MalformedURLException SerializationException InvalidPathException Việc bắt và xử lý exception đúng cách là yêu cầu bắt buộc trong lập trình Java.\nLiên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), luồng nhập xuất được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Truyền dữ liệu Client – Server Java RMI Multicast UDP Không hiểu I/O Stream → không thể làm mạng đúng cách.\nKết luận Qua bài học này, ta đã:\nHiểu khái niệm luồng nhập xuất trong Java Phân biệt luồng byte và luồng ký tự Nắm được cách đọc/ghi dữ liệu với Stream Biết vai trò của Serialization và Filtered Streams Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo Khi xử lý các tác vụ mạng (như gọi API), người mới học JS hay viết code lồng nhau kiểu này:\n1 2 3 4 5 6 7 8 9 10 // Cực hình Callback Hell getData(function(a) { getMoreData(a, function(b) { getMoreData(b, function(c) { getMoreData(c, function(d) { console.log(d); }); }); }); }); ","permalink":"http://localhost:1313/blog/bai-viet-3/","summary":"Tổng quan về Input/Output Streams trong Java – nền tảng cho xử lý file, console và lập trình mạng.","title":"Bài 3: Quản lý luồng nhập xuất trong Java"},{"content":"Trong lập trình mạng, trước khi chương trình có thể gửi hoặc nhận dữ liệu, điều quan trọng nhất là xác định đúng địa chỉ kết nối mạng. Nếu xác định sai địa chỉ, chương trình sẽ không thể giao tiếp, dù phần xử lý dữ liệu có đúng đến đâu.\nBài học này giúp bạn hiểu cách Java làm việc với địa chỉ IP, tên miền (DNS) và URL. Đây là nền tảng bắt buộc trước khi đi vào Socket TCP, UDP, Web Crawler và Java RMI.\nĐịa chỉ kết nối mạng là gì? Địa chỉ kết nối mạng là thông tin dùng để xác định máy nào trong mạng cần giao tiếp và dịch vụ nào trên máy đó sẽ xử lý dữ liệu.\nTrong Internet, địa chỉ kết nối thường bao gồm:\nĐịa chỉ IP Tên miền (Domain Name) Cổng (Port) Giao thức (Protocol) DNS – Domain Name System Hình 4.1 – Mô hình hoạt động của DNS (Domain Name System)\nClient gửi yêu cầu phân giải tên miền đến DNS Server, DNS trả về địa chỉ IP tương ứng để client kết nối đến server đích.*\nCon người dễ nhớ tên miền hơn các dãy số IP.\nDNS (Domain Name System) có nhiệm vụ ánh xạ tên miền sang địa chỉ IP, giúp client tìm đúng server cần kết nối.\nVí dụ:\ngoogle.com tương ứng với nhiều địa chỉ IP khác nhau www.cs.yale.edu tương ứng với 128.36.229.30 Nhờ DNS, người dùng không cần ghi nhớ địa chỉ IP khi truy cập Internet. ****\nĐịa chỉ IPv4 IPv4 là dạng địa chỉ phổ biến, gồm 32 bit, thường được viết thành bốn nhóm số.\nVí dụ:\n192.168.1.1 8.8.8.8 Một số dải địa chỉ đặc biệt:\n127.x.x.x là loopback (localhost) 224.0.0.0 – 239.255.255.255 là multicast Lớp InetAddress trong Java Java cung cấp lớp InetAddress để làm việc với địa chỉ IP và DNS.\nLớp này thường được dùng để:\nPhân giải tên miền sang IP Kiểm tra loại địa chỉ Kiểm tra khả năng kết nối mạng Ví dụ minh họa:\n1 InetAddress address = InetAddress.getByName(\u0026#34;google.com\u0026#34;); URL – Uniform Resource Locator URL được dùng để xác định tài nguyên trên Internet như trang web, file hoặc dịch vụ.\nMột URL đầy đủ thường bao gồm các thành phần sau:\nGiao thức (Protocol) Tên miền (Host) Cổng (Port) Đường dẫn (Path) Chuỗi truy vấn (Query) Ví dụ một URL đầy đủ: https://www.hutech.edu.vn/admission?id=123\nURL cho biết lấy dữ liệu ở đâu và bằng cách nào.\nLớp URL trong Java Lớp URL cho phép chương trình Java:\nPhân tích các thành phần của URL Kết nối tới server Đọc dữ liệu từ Internet Ví dụ minh họa:\n1 URL url = new URL(\u0026#34;https://www.example.com\u0026#34;); Ý nghĩa của việc quản lý địa chỉ kết nối mạng Hiểu rõ cách quản lý địa chỉ mạng giúp:\nTránh kết nối sai server Chuẩn bị đúng địa chỉ cho Socket TCP/UDP Hiểu cách Web Crawler hoạt động Nắm vững mô hình Client – Server Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm địa chỉ kết nối mạng Biết vai trò của DNS và IPv4 Nắm được cách Java làm việc với InetAddress Hiểu cấu trúc và vai trò của URL Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-4/","summary":"Tìm hiểu cách Java quản lý địa chỉ mạng thông qua InetAddress, URL, URLConnection và DNS.","title":"Bài 4: Quản lý địa chỉ kết nối mạng trong Java"},{"content":"Trong lập trình mạng, TCP Socket là cơ chế quan trọng nhất để xây dựng các ứng dụng Client – Server có độ tin cậy cao.\nBài học này giúp bạn hiểu TCP là gì, vì sao cần TCP, và cách Java triển khai TCP thông qua Socket và ServerSocket.\nĐây là bước chuyển tiếp trực tiếp từ kiến thức địa chỉ mạng (IP, DNS, URL) sang giao tiếp dữ liệu thực tế giữa các chương trình.\nTCP là gì? TCP (Transmission Control Protocol) là giao thức truyền thông hướng kết nối, đảm bảo dữ liệu được truyền:\nĐúng thứ tự Đầy đủ Không bị mất mát Không bị trùng lặp Trước khi truyền dữ liệu, TCP yêu cầu thiết lập kết nối giữa hai bên, và chỉ khi kết nối thành công thì dữ liệu mới được trao đổi.\nVì sao sử dụng TCP? TCP được sử dụng khi ứng dụng yêu cầu độ tin cậy cao, ví dụ:\nỨng dụng chat Ứng dụng client–server Truyền file Game online theo lượt Hệ thống ngân hàng, thương mại điện tử TCP cung cấp các cơ chế quan trọng:\nĐảm bảo dữ liệu: gói tin bị mất sẽ được gửi lại Kiểm soát lỗi: phát hiện và sửa lỗi trong quá trình truyền Kiểm soát luồng: tránh làm quá tải phía nhận Giao tiếp hai chiều: cho phép gửi và nhận dữ liệu đồng thời Cơ chế hoạt động của TCP Quá trình giao tiếp TCP gồm ba giai đoạn chính:\nThiết lập kết nối (Bắt tay 3 bước – Three-way Handshake) Truyền dữ liệu Giải phóng kết nối Nhờ cơ chế này, TCP đảm bảo rằng hai bên luôn sẵn sàng trước khi truyền và kết thúc an toàn sau khi hoàn tất.\nMô hình Client – Server Các ứng dụng TCP thường hoạt động theo mô hình Client – Server.\nServer:\nChạy trước Lắng nghe yêu cầu kết nối Cung cấp dịch vụ Trả kết quả cho client Client:\nChạy sau Chủ động kết nối tới server Gửi yêu cầu Nhận phản hồi từ server Quá trình giao tiếp gồm:\nClient gửi yêu cầu Server xử lý Server trả kết quả cho client Socket trong Java Trong Java, Socket đại diện cho điểm cuối giao tiếp giữa client và server khi sử dụng TCP.\nSocket cho phép:\nGửi dữ liệu tới server Nhận dữ liệu từ server Giao tiếp hai chiều thông qua luồng nhập/xuất Ví dụ minh họa tạo Socket phía client:\n1 Socket socket = new Socket(\u0026#34;localhost\u0026#34;, 8080); ServerSocket trong Java ServerSocket được sử dụng ở phía server để:\nMở một cổng lắng nghe Chờ client kết nối Chấp nhận kết nối và tạo Socket giao tiếp ServerSocket đóng vai trò như cửa ngõ, cho phép các client kết nối vào server.\nVí dụ minh họa:\n1 ServerSocket server = new ServerSocket(8080); Luồng dữ liệu trong TCP Socket Sau khi kết nối TCP được thiết lập, client và server trao đổi dữ liệu thông qua các luồng:\nInputStream: dùng để đọc dữ liệu từ socket OutputStream: dùng để ghi dữ liệu vào socket Luồng dữ liệu này hoạt động tương tự như I/O Stream đã học ở bài trước,\nnhưng nguồn và đích là mạng thay vì file hay bàn phím.\nVí dụ ứng dụng: Trò chơi Oẳn Tù Tì Một bài tập tiêu biểu sử dụng TCP Socket là trò chơi Oẳn Tù Tì theo mô hình Client – Server.\nĐặc điểm Server quản lý luật chơi và điểm số Hai client gửi lựa chọn (kéo – búa – bao) Server xác định kết quả và gửi lại cho client Dữ liệu được truyền qua TCP để đảm bảo chính xác Thông qua bài tập này, sinh viên hiểu rõ:\nCách thiết lập kết nối TCP Cách trao đổi dữ liệu giữa nhiều client Cách xử lý lỗi mạng và ngoại lệ Ý nghĩa của lập trình TCP Socket Việc nắm vững TCP Socket giúp bạn:\nHiểu bản chất giao tiếp mạng Xây dựng hệ thống Client – Server thực tế Chuẩn bị cho các bài nâng cao như: Đa tuyến (Multi-thread) Socket UDP Java RMI Ứng dụng mạng phân tán Kết luận Qua bài học này, bạn đã:\nHiểu TCP là gì và vì sao cần TCP Nắm được mô hình Client – Server Biết vai trò của Socket và ServerSocket trong Java Hiểu cách dữ liệu được truyền qua TCP Chuẩn bị nền tảng cho các bài học UDP và xử lý đồng thời tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-5/","summary":"Giải thích mô hình Client–Server và cách lập trình Socket TCP trong Java – nền tảng cho giao tiếp mạng tin cậy.","title":"Bài 5: Lập trình Socket TCP trong Java"},{"content":"#Trong lập trình mạng, không phải lúc nào ứng dụng cũng cần độ tin cậy tuyệt đối như TCP.\nTrong nhiều trường hợp, điều quan trọng hơn là tốc độ truyền nhanh và độ trễ thấp.\nBài học này giới thiệu UDP Socket – cơ chế truyền dữ liệu không kết nối, được sử dụng rộng rãi trong các ứng dụng thời gian thực.\nUDP là gì? UDP (User Datagram Protocol) là giao thức truyền thông không hướng kết nối.\nĐiều này có nghĩa là:\nKhông thiết lập kết nối trước khi truyền Không đảm bảo dữ liệu đến nơi Không đảm bảo thứ tự gói tin Không tự động gửi lại gói tin bị mất UDP gửi dữ liệu theo từng datagram (gói tin độc lập).\nSo sánh TCP và UDP TCP UDP Có kết nối Không kết nối Đảm bảo dữ liệu Không đảm bảo Truyền theo luồng Truyền theo gói Độ trễ cao hơn Độ trễ thấp Phù hợp dữ liệu quan trọng Phù hợp dữ liệu thời gian thực Khi nào sử dụng UDP? UDP được sử dụng khi:\nCần truyền nhanh Có thể chấp nhận mất gói tin Dữ liệu được gửi liên tục Ví dụ ứng dụng UDP:\nTruyền video, audio trực tuyến Game online thời gian thực Chat broadcast DNS Multicast, streaming UDP Socket trong Java Java hỗ trợ UDP thông qua hai lớp chính:\nDatagramSocket: quản lý socket UDP DatagramPacket: đại diện cho gói dữ liệu UDP UDP không phân biệt client hay server rõ ràng như TCP.\nMỗi chương trình chỉ cần một DatagramSocket để gửi và nhận dữ liệu.\nDatagramPacket là gì? DatagramPacket là gói dữ liệu UDP, bao gồm:\nDữ liệu cần gửi Địa chỉ IP đích Số hiệu cổng Mỗi lần gửi hoặc nhận dữ liệu, UDP làm việc với một DatagramPacket riêng biệt.\nLuồng dữ liệu trong UDP UDP không có luồng InputStream / OutputStream như TCP.\nQuy trình truyền dữ liệu UDP:\nTạo DatagramSocket Tạo DatagramPacket chứa dữ liệu Gửi packet đi Nhận packet về Đọc dữ liệu từ packet Mỗi gói tin là độc lập, không liên quan đến các gói khác.\nĐặc điểm quan trọng của UDP Không kiểm soát lỗi Không kiểm soát luồng Không bắt tay kết nối Gửi nhanh, xử lý đơn giản Phù hợp truyền broadcast và multicast Chính vì vậy, UDP thường được dùng khi tốc độ quan trọng hơn độ chính xác tuyệt đối.\nÝ nghĩa của lập trình Socket UDP Nắm vững UDP giúp bạn:\nHiểu bản chất truyền dữ liệu không kết nối Xây dựng ứng dụng thời gian thực Phân biệt rõ TCP và UDP trong thiết kế hệ thống Chuẩn bị cho các chủ đề nâng cao như: Multicast UDP Java RMI Hệ thống phân tán Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính, UDP được sử dụng trong:\nSocket UDP Multicast Ứng dụng truyền tin nhanh Game, streaming, broadcast Hiểu UDP giúp bạn chọn đúng giao thức cho từng bài toán thực tế.\nKết luận Qua bài học này, bạn đã:\nHiểu UDP là gì và cơ chế hoạt động Phân biệt được TCP và UDP Biết vai trò của DatagramSocket và DatagramPacket Hiểu cách truyền dữ liệu không kết nối Chuẩn bị nền tảng cho bài Multicast UDP \u0026amp; Java RMI tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-6/","summary":"Giải thích giao thức UDP và cách Java lập trình Socket UDP – nền tảng cho truyền dữ liệu nhanh, không kết nối.","title":"Bài 6: Lập trình Socket UDP trong Java"},{"content":"Trong các ứng dụng mạng thực tế, đặc biệt là Server, chương trình thường phải xử lý nhiều yêu cầu cùng lúc.\nNếu chỉ sử dụng một luồng thực thi, server sẽ bị tắc nghẽn, các client phải chờ đợi và hiệu năng giảm nghiêm trọng.\nVì vậy, lập trình đa tuyến (Multithreading) và xử lý đồng thời (Concurrency) là kỹ thuật bắt buộc trong lập trình mạng.\nTuyến (Thread) là gì? Thread là một dòng điều khiển tuần tự bên trong một chương trình.\nMột chương trình (process) có thể chứa nhiều thread Các thread có thể chạy đồng thời Mỗi thread thực hiện một nhiệm vụ riêng Thread không phải là một chương trình độc lập,\nnó luôn thuộc về một process.\nProcess và Thread Process:\nCó không gian bộ nhớ riêng Chạy độc lập với process khác Tạo và chuyển đổi tốn nhiều tài nguyên Thread:\nChia sẻ bộ nhớ với các thread khác trong cùng process Tạo nhanh hơn process Chuyển đổi nhanh hơn Nhờ thread, chương trình có thể thực hiện nhiều công việc cùng lúc trong cùng một ứng dụng.\nVì sao cần lập trình đa tuyến? Lập trình đa tuyến giúp:\nTăng hiệu suất và khả năng đáp ứng Tận dụng thời gian chờ đợi (I/O, mạng, tải file) Chia nhỏ tác vụ và xử lý đồng thời Cải thiện trải nghiệm người dùng Trong lập trình mạng, đa tuyến cho phép server phục vụ nhiều client cùng lúc.\nThực thi Thread trong Java Trong Java, một thread bắt đầu chạy khi gọi phương thức start().\nKhi thread chạy, JVM thực thi mã trong phương thức run() Khi run() kết thúc, thread cũng kết thúc Một thread không thể start lại, muốn chạy lại phải tạo thread mới Thread cần có điều kiện dừng rõ ràng để tránh chạy vô hạn.\nỨng dụng đa tuyến trong lập trình mạng Ứng dụng Chat đa tuyến Một ví dụ tiêu biểu của đa tuyến trong mạng là ứng dụng chat nhiều client – một server.\nĐặc điểm:\nServer chấp nhận nhiều client kết nối cùng lúc Mỗi client được xử lý bởi một thread riêng Tin nhắn từ một client được gửi tới tất cả client khác Server ghi lại nội dung chat vào file log Thông qua ví dụ này, sinh viên hiểu rõ:\nCách server xử lý nhiều kết nối đồng thời Cách phối hợp giữa socket và thread Vai trò của đa tuyến trong ứng dụng mạng Xử lý đồng thời (Concurrency) Xử lý đồng thời xảy ra khi nhiều thread:\nChạy cùng lúc Truy cập tài nguyên chung (biến, file, bộ nhớ) Nếu không kiểm soát tốt, chương trình có thể gặp các vấn đề nghiêm trọng.\nRace Condition Race Condition xảy ra khi:\nNhiều thread cùng truy cập và thay đổi dữ liệu chung Kết quả phụ thuộc vào thứ tự thực thi không xác định Điều này có thể dẫn đến:\nDữ liệu sai lệch Kết quả không nhất quán Lỗi khó phát hiện Đồng bộ hóa (Synchronization) Để tránh race condition, Java cung cấp cơ chế đồng bộ hóa:\nĐảm bảo chỉ một thread được truy cập tài nguyên tại một thời điểm Giữ cho dữ liệu luôn nhất quán Đồng bộ hóa là nền tảng để xây dựng các ứng dụng an toàn và ổn định khi chạy đa tuyến.\nCác vấn đề thường gặp trong xử lý đồng thời Một số vấn đề phổ biến:\nRace condition: tranh chấp dữ liệu Deadlock: các thread chờ nhau vô hạn Livelock: các thread liên tục phản ứng nhưng không tiến triển Starvation: thread không bao giờ được cấp tài nguyên Những vấn đề này khiến lập trình đa tuyến trở nên phức tạp và khó debug.\nLập lịch Thread trong Java Java sử dụng cơ chế lập lịch theo độ ưu tiên:\nMỗi thread có độ ưu tiên từ MIN_PRIORITY đến MAX_PRIORITY JVM chọn thread runnable có độ ưu tiên cao hơn để chạy Thread có thể nhường CPU cho thread khác bằng cách gọi yield() Việc hiểu cơ chế lập lịch giúp lập trình viên thiết kế thread hợp lý hơn.\nÝ nghĩa của lập trình đa tuyến và xử lý đồng thời Nắm vững kiến thức bài này giúp bạn:\nXây dựng server xử lý nhiều client Viết ứng dụng mạng hiệu năng cao Tránh lỗi tranh chấp dữ liệu Chuẩn bị cho các chủ đề nâng cao như: Server đa tuyến Pooling Threads Multicast UDP Java RMI Hệ thống phân tán Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm thread và multithreading Phân biệt process và thread Biết vai trò của đa tuyến trong lập trình mạng Hiểu các vấn đề xử lý đồng thời và race condition Chuẩn bị nền tảng cho các bài học nâng cao tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-7/","summary":"Giải thích lập trình đa tuyến và xử lý đồng thời trong Java – nền tảng cho các ứng dụng mạng nhiều client và hệ thống phân tán.","title":"Bài 7: Lập trình đa tuyến và xử lý đồng thời trong Java"},{"content":"Buổi 8 gồm 2 phần lớn:\nMulticast UDP: gửi dữ liệu từ một nguồn đến nhiều máy nhận cùng lúc (1 → N). Java RMI: gọi phương thức từ xa giữa các ứng dụng Java như gọi hàm bình thường (Remote Method Invocation). Đây là các kỹ thuật thường gặp trong streaming, trò chuyện nhóm, giám sát từ xa và hệ thống phân tán.\n1) UDP Multicast Unicast, Broadcast và Multicast Trong mạng máy tính có 3 kiểu gửi dữ liệu phổ biến:\nUnicast: 1 nguồn → 1 đích\nVí dụ: bạn mở một trang web, server trả dữ liệu cho riêng bạn.\nBroadcast: 1 nguồn → tất cả máy trong mạng nội bộ\nVí dụ: một thông báo phát cho toàn bộ LAN.\nMulticast: 1 nguồn → một nhóm máy đã đăng ký nhận dữ liệu\nVí dụ: server phát stream video cho nhóm người xem cùng lúc.\nMulticast là cách truyền hiệu quả khi nhiều máy cùng cần nhận một nội dung giống nhau.\nTại sao dùng UDP Multicast? UDP Multicast thường được dùng vì:\nHiệu suất cao: gửi 1 lần nhưng nhiều máy nhận → giảm tải mạng và server. Đơn giản, nhanh: UDP là kiểu “gửi và quên”, không phải chờ xác nhận. Tối ưu trong LAN: phù hợp môi trường mạng nội bộ (Local Area Network). Rất hợp streaming: audio/video cần tốc độ và độ trễ thấp hơn là đảm bảo tuyệt đối. Ứng dụng của Multicast Multicast có thể dùng trong:\nTruyền phát multimedia trực tiếp (audio/video streaming) Trò chuyện nhóm, hội thoại nhóm Quảng bá thông tin cấu hình mạng và cập nhật trong hệ thống mạng Game nhiều người chơi (gửi trạng thái game cho nhiều người) Phát thông tin trạng thái/cảnh báo cho nhiều thiết bị Phát tán cập nhật phần mềm trong mạng nội bộ Địa chỉ Multicast IPv4 Trong IPv4:\nClass D là dải địa chỉ dành cho multicast Dải địa chỉ multicast thường gặp: 224.0.0.0 – 239.255.255.255 Một số nhóm multicast hay được nhắc:\n224.0.0.1: tất cả host trong local subnet Multicast Group là gì? Multicast hoạt động theo “nhóm”:\nMột multicast group giống như một kênh. Máy nào muốn nhận dữ liệu phải tham gia nhóm (join group). Khi rời nhóm thì không nhận dữ liệu nữa. Multicast trong Java Java hỗ trợ multicast qua lớp:\njava.net.MulticastSocket (kế thừa từ DatagramSocket) Một số thao tác quan trọng:\njoinGroup(...): tham gia nhóm multicast leaveGroup(...): rời nhóm multicast setTimeToLive(ttl): đặt TTL (thời gian sống của gói tin, qua bao nhiêu router) Quy trình gửi dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket Tham gia nhóm multicast Tạo DatagramPacket chứa dữ liệu + địa chỉ nhóm + port Gửi packet Rời nhóm Ví dụ minh họa (ngắn, chỉ để hiểu):\n1 2 3 4 5 6 7 8 9 10 11 12 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(); socket.joinGroup(group); socket.setTimeToLive(5); byte[] data = \u0026#34;Hello Multicast\u0026#34;.getBytes(); DatagramPacket packet = new DatagramPacket(data, data.length, group, 9876); socket.send(packet); socket.leaveGroup(group); socket.close(); Quy trình nhận dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket lắng nghe trên port Tham gia nhóm multicast Tạo DatagramPacket rỗng để nhận dữ liệu Gọi receive() để chờ gói tin gửi về Đọc dữ liệu từ packet Rời nhóm và đóng socket Ví dụ minh họa (ngắn):\n1 2 3 4 5 6 7 8 9 10 11 12 13 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(9876); socket.joinGroup(group); byte[] buf = new byte[1024]; DatagramPacket packet = new DatagramPacket(buf, buf.length); socket.receive(packet); String msg = new String(packet.getData(), 0, packet.getLength()); System.out.println(\u0026#34;Received: \u0026#34; + msg); socket.leaveGroup(group); socket.close(); 2) Java RMI Java RMI là gì? RMI (Remote Method Invocation) cho phép chương trình Java:\nGọi phương thức của một đối tượng nằm trên máy khác Cảm giác giống như gọi method trong cùng chương trình Nói đơn giản:\nClient gọi: remoteObject.sum(1,2) Server thực thi thật và trả kết quả về cho client RMI giúp che giấu toàn bộ chi tiết mạng phía sau, người lập trình chỉ tập trung vào logic.\nVì sao dùng Java RMI? Java RMI được sử dụng vì:\nTích hợp sẵn trong Java, dễ triển khai nếu cả client và server đều dùng Java Gọi phương thức từ xa đơn giản như gọi hàm thông thường Hỗ trợ dữ liệu phức tạp: đối tượng, mảng, class tự định nghĩa Tự động xử lý giao tiếp mạng thông qua cơ chế stub / skeleton Dựa trên TCP/IP nên tương đối ổn định và tin cậy Hạn chế của Java RMI Một số điểm hạn chế cần lưu ý:\nPhụ thuộc Java: chủ yếu phù hợp Java ↔ Java Thiết kế dịch vụ phức tạp vẫn cần tổ chức tốt (đặc biệt khi dùng callback) Quản lý phiên và kết nối không mạnh như các giải pháp hiện đại Bảo mật cần cấu hình cẩn thận trong môi trường thực tế Ý tưởng kiến trúc RMI (hiểu nhanh) Trong Java RMI có các thành phần chính:\nRemote Interface\nKhai báo các phương thức cho phép gọi từ xa\nServer Implementation\nLớp cài đặt interface, chứa logic xử lý thật\nRMI Registry\nNơi đăng ký service để client tìm thấy server\nClient\nTìm (lookup) service trong registry và gọi phương thức\nCác bước triển khai RMI (tóm tắt) Định nghĩa Remote Interface Cài đặt interface bằng một class server (remote object) Viết chương trình server: tạo object và bind vào registry Viết chương trình client: lookup registry và gọi method Chạy RMI registry, chạy server, sau đó chạy client Ví dụ ứng dụng RMI Một số ví dụ thường gặp:\nTính tổng 2 số từ xa Dịch vụ quản lý tài khoản ATM Dịch vụ giám sát nhiệt độ có callback (server gọi ngược lại client) Bài tập gợi ý theo đúng nội dung buổi 8 BT8.01: Mô phỏng streaming video\n(1 server phát, nhiều client nhận dữ liệu)\nBT8.02: Server quản lý tài khoản ATM bằng RMI\n(thêm user, đăng nhập, gửi/rút tiền, lưu lịch sử giao dịch)\nKết luận Qua bài học này, bạn đã:\nHiểu sự khác nhau giữa Unicast, Broadcast và Multicast Nắm được vì sao Multicast UDP phù hợp cho truyền dữ liệu nhóm và streaming Biết cách Java hỗ trợ multicast qua MulticastSocket Hiểu Java RMI và cơ chế gọi phương thức từ xa Chuẩn bị nền tảng cho các bài ứng dụng mạng phân tán và đồ án học phần ","permalink":"http://localhost:1313/blog/bai-viet-8/","summary":"Giải thích Multicast UDP (gửi 1-n) và Java RMI (gọi phương thức từ xa) – nền tảng cho ứng dụng nhóm và hệ phân tán.","title":"Bài 8: Multicast UDP và Java RMI"},{"content":"Sau khi hoàn thành các bài về TCP, UDP, đa tuyến và xử lý đồng thời,\nchúng ta đã có đủ nền tảng để xây dựng một ứng dụng mạng hoàn chỉnh.\nBài học này giúp bạn xâu chuỗi toàn bộ kiến thức đã học,\nhiểu rõ mỗi công nghệ dùng trong trường hợp nào,\nvà cách thiết kế một hệ thống mạng đúng tư duy kỹ sư.\nNhìn lại các mô hình giao tiếp mạng đã học Trong lập trình mạng, các ứng dụng thường được xây dựng dựa trên mô hình Client – Server.\nClient: gửi yêu cầu, nhập dữ liệu, hiển thị kết quả Server: xử lý logic, quản lý dữ liệu, trả kết quả Tùy bài toán, ta lựa chọn giao thức và mô hình phù hợp.\nSo sánh TCP, UDP và Multicast TCP – Giao tiếp tin cậy TCP phù hợp khi:\nCần đảm bảo dữ liệu đúng và đủ Cần kết nối ổn định, hai chiều Ví dụ: chat, truyền file, game theo lượt, hệ thống ngân hàng Đặc trưng:\nCó bắt tay 3 bước Có kiểm soát lỗi, kiểm soát luồng Tốn tài nguyên hơn UDP UDP – Giao tiếp nhanh, không kết nối UDP phù hợp khi:\nƯu tiên tốc độ Chấp nhận mất gói Ví dụ: game thời gian thực, streaming, cảm biến Đặc trưng:\nKhông kết nối Không đảm bảo thứ tự Ít độ trễ UDP Multicast – Truyền dữ liệu nhóm Multicast được dùng khi:\nMột nguồn → nhiều người nhận Dữ liệu giống nhau cho tất cả client Ví dụ: livestream, thông báo hệ thống, truyền trạng thái Ưu điểm:\nGiảm tải server Tiết kiệm băng thông Phù hợp mạng LAN Vai trò của đa tuyến (Multithreading) Trong thực tế, server không thể xử lý từng client một cách tuần tự.\nĐa tuyến giúp:\nNhiều client kết nối cùng lúc Không client nào bị “đóng băng” Tăng khả năng mở rộng hệ thống Ví dụ:\nServer chat: mỗi client là một thread Server TCP: mỗi socket được xử lý riêng Thiết kế một ứng dụng mạng hoàn chỉnh Khi thiết kế, cần xác định rõ:\nGiao thức: TCP hay UDP? Mô hình: 1–1, 1–n, n–n? Đồng thời hay tuần tự? Client gửi gì? Server xử lý gì? Một thiết kế tốt luôn:\nPhân tách rõ giao tiếp – xử lý – dữ liệu Dễ mở rộng Dễ bảo trì Liên hệ với đồ án học phần Các đồ án như:\nChat đa tuyến Oẳn Tù Tì client–server Streaming UDP Dịch vụ RMI Đều là sự kết hợp của các kiến thức đã học,\nkhông phải nội dung mới.\nKết luận Qua bài học này, bạn đã:\nHệ thống lại toàn bộ kiến thức lập trình mạng Hiểu rõ khi nào dùng TCP, UDP, Multicast Nắm được vai trò của đa tuyến Biết cách tư duy thiết kế một ứng dụng mạng hoàn chỉnh Đây là bước chuẩn bị quan trọng trước khi vận dụng toàn bộ kiến thức vào một hệ thống thực tế.\n","permalink":"http://localhost:1313/blog/bai-viet-9/","summary":"Tổng hợp kiến thức TCP, UDP, đa tuyến và cách thiết kế ứng dụng mạng Client–Server hoàn chỉnh.","title":"Bài 9: Tổng hợp kiến thức \u0026 thiết kế ứng dụng mạng"},{"content":"Bài cuối cùng của học phần không nhằm giới thiệu công nghệ mới,\nmà tập trung vào cách vận dụng kiến thức đã học vào thực tế.\nĐây là giai đoạn chuyển từ:\n“Biết dùng” → “Biết thiết kế” → “Biết đánh giá hệ thống”\nTư duy vận dụng kiến thức Một ứng dụng mạng hoàn chỉnh cần trả lời được các câu hỏi:\nVì sao chọn TCP mà không phải UDP? Vì sao cần đa tuyến? Server có chịu được nhiều client không? Hệ thống có mở rộng được không? Đây chính là tư duy kỹ sư, không phải chỉ “chạy được là xong”.\nĐánh giá một ứng dụng mạng Khi hoàn thiện hệ thống, cần xem xét:\n1. Tính đúng đắn Dữ liệu có truyền đúng không? Có mất gói không? Có xử lý lỗi không? 2. Tính đồng thời Nhiều client có dùng chung được không? Có bị treo server không? Có race condition không? 3. Hiệu năng Độ trễ thế nào? Server có bị quá tải không? Có tách luồng hợp lý không? Liên hệ với các mô hình phân tán Các hệ thống đã học là nền tảng cho:\nHệ thống client–server lớn Ứng dụng phân tán Microservices Cloud services Java RMI, TCP đa tuyến hay UDP Multicast\nđều là những viên gạch đầu tiên.\nTừ học phần đến thực tế Sau học phần này, bạn có thể tiếp cận:\nWebSocket REST API gRPC Message Queue (Kafka, RabbitMQ) Hệ thống realtime Tư duy lập trình mạng không thay đổi, chỉ công nghệ thay đổi.\nTổng kết toàn bộ học phần Qua toàn bộ chuỗi bài, bạn đã:\nHiểu cách dữ liệu đi qua mạng Làm việc với TCP, UDP, Multicast Xử lý đa tuyến và đồng thời Tiếp cận lập trình phân tán với RMI Có tư duy thiết kế hệ thống mạng Lời kết Lập trình mạng không chỉ là code socket,\nmà là hiểu cách các hệ thống nói chuyện với nhau.\nNếu bạn hiểu được điều đó,\nbạn đã vượt xa mức “học để qua môn”.\n","permalink":"http://localhost:1313/blog/bai-viet-10/","summary":"Vận dụng toàn bộ kiến thức lập trình mạng để xây dựng, đánh giá và hoàn thiện một ứng dụng thực tế.","title":"Bài 10: Hoàn thiện \u0026 vận dụng lập trình mạng"},{"content":"Lời mở đầu Có những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\nMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\nHọc tập Những năm đại học trôi qua nhanh hơn mình từng nghĩ. Ngày mới bước chân vào giảng đường, mình vẫn còn khá mơ hồ về ngành học, về tương lai, về chính bản thân mình sẽ trở thành ai sau bốn năm. Nhưng rồi từng môn học, từng bài tập nhóm, từng đồ án kéo mình lại gần hơn với cách một hệ thống được hình thành và vận hành.\nHệ thống thông tin không chỉ là lập trình, cũng không đơn thuần là công nghệ. Đó là câu chuyện về con người, quy trình và dữ liệu. Mình học cách đặt câu hỏi, học cách lắng nghe yêu cầu, học cách vẽ ra những sơ đồ tưởng chừng khô khan nhưng lại chứa rất nhiều suy nghĩ phía sau. Dần dần, mình nhận ra mình thích phần “hiểu vấn đề” hơn là chỉ chăm chăm vào lời giải.\nĐịnh hướng Ở thời điểm hiện tại, mình đang định hướng theo con đường Business Analyst (BA). Mình hứng thú với vai trò đứng giữa – không quá xa kỹ thuật, cũng không tách rời nghiệp vụ. Đó là nơi cần sự rõ ràng trong tư duy, sự kiên nhẫn trong giao tiếp và khả năng chuyển hóa những điều mơ hồ thành thứ có thể triển khai được.\nMình không nghĩ BA là một vị trí “nhẹ nhàng” hay “an toàn”. Ngược lại, đó là công việc đòi hỏi phải học rất nhiều, sai rất nhiều và sửa rất nhiều. Nhưng chính điều đó khiến mình thấy phù hợp. Mình muốn hiểu hệ thống trước khi xây dựng nó, muốn biết vì sao người ta see cần một chức năng, chứ không chỉ là nó được viết như thế nào.\nBlog Blog này ra đời khá tự nhiên, giống như một cuốn sổ mở rộng hơn là một trang thể hiện điều gì đó to tát. Mình viết để nhớ, để hệ thống lại những gì đã học, và đôi khi là để sắp xếp lại suy nghĩ của chính mình.\nỞ đây có thể là kiến thức về Hệ thống thông tin, về phân tích nghiệp vụ, về lập trình, hoặc đơn giản là những trải nghiệm học tập và va chạm trong quá trình làm đồ án, làm việc nhóm, và chuẩn bị bước ra môi trường thực tế. Mình không mong mọi thứ phải hoàn hảo, chỉ mong nó thật và có ích cho ai đó đang đi trên con đường tương tự.\nLời kết Mình đang ở một giai đoạn chưa thể gọi là trưởng thành, nhưng cũng không còn quá non nớt. Vẫn đang học, vẫn đang thử, vẫn đang sai và sửa mỗi ngày. Nếu có một điều mình mong giữ được lâu nhất, thì đó là sự tò mò và tinh thần học hỏi – những thứ giúp mình không đứng yên giữa rất nhiều lựa chọn ngoài kia.\nCảm ơn bạn đã ghé qua và đọc những dòng này. Hy vọng ở một thời điểm nào đó, những chia sẻ nhỏ ở đây sẽ chạm đến bạn – dù chỉ là một chút. \u0026ldquo;Học để chia sẻ, chia sẻ để học nhiều hơn.\u0026rdquo;\nLiên hệ Nếu bạn muốn gửi cho mình vài dòng trao đổi,\nbạn có thể liên hệ với mình qua Email hoặc GitHub ,Facebook dưới đây.\nCảm ơn bạn đã ghé thăm blog! ","permalink":"http://localhost:1313/about/","summary":"\u003ch2 id=\"lời-mở-đầu\"\u003eLời mở đầu\u003c/h2\u003e\n\u003cp\u003eCó những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\u003c/p\u003e\n\u003cp\u003eMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\u003c/p\u003e","title":"Giới thiệu"},{"content":"Trong lập trình mạng, trước khi kết nối, ta phải biết \u0026ldquo;địa chỉ nhà\u0026rdquo; (IP) của mình và đối phương. Java cung cấp class\nHình 1.1: Hiệu ứng Dunning–Kruger – mức độ tự tin thay đổi theo kinh nghiệm học tập\nGóc nhìn học tập: Hiệu ứng Dunning–Kruger InetAddress để làm việc này.\nĐịa chỉ IP là gì trong lập trình mạng? IP (Internet Protocol Address) là địa chỉ định danh của một thiết bị khi tham gia vào mạng máy tính.\nTrong lập trình mạng, IP đóng vai trò quan trọng trong việc:\nXác định máy gửi và máy nhận Định tuyến dữ liệu trong quá trình truyền thông Thiết lập kết nối giữa các tiến trình chạy trên những máy khác nhau Nếu không có địa chỉ IP, các máy tính sẽ không thể nhận biết và giao tiếp với nhau.\nVai trò của lớp InetAddress trong Java Lớp InetAddress đại diện cho một địa chỉ IP trong Java.\nThông qua lớp này, lập trình viên có thể:\nLấy địa chỉ IP của máy đang chạy chương trình Lấy tên máy (hostname) Phân giải tên miền sang địa chỉ IP Chuẩn bị thông tin để tạo Socket hoặc ServerSocket Hầu hết các chương trình lập trình mạng trong Java đều sử dụng InetAddress ở bước khởi tạo.\nPhân tích ý nghĩa các lệnh trong chương trình InetAddress.getLocalHost()\n→ Trả về đối tượng đại diện cho máy cục bộ (localhost).\ngetHostName()\n→ Lấy tên máy do hệ điều hành hoặc mạng gán.\ngetHostAddress()\n→ Lấy địa chỉ IP của máy dưới dạng chuỗi.\nViệc in ra hostname và IP giúp:\nKiểm tra cấu hình mạng Xác định đúng máy khi kết nối Client – Server Debug lỗi mạng Một số lưu ý khi lấy IP trong Java Khi máy không kết nối mạng, IP có thể là 127.0.0.1 Khi máy có nhiều card mạng (WiFi, LAN, VPN), IP trả về có thể không phải IP Internet Trên Server, hostname và IP thường khác máy cá nhân Ứng dụng thực tế Việc xác định IP của máy thường được sử dụng trong:\nChương trình Client – Server Thông báo IP Server cho Client kết nối Kiểm tra kết nối mạng LAN Ghi log và giám sát hệ thống Kết luận Qua bài học này, ta đã:\nHiểu vai trò của địa chỉ IP trong lập trình mạng Biết cách lấy IP bằng lớp InetAddress Chuẩn bị nền tảng cho các kỹ thuật TCP, UDP và RMI Liên hệ với học phần Lập trình Mạng máy tính Bài học này nằm trong nội dung mở đầu của học phần Lập trình Mạng máy tính (CMP180) tại Trường Đại học Công nghệ TP.HCM (HUTECH).\nTrong lộ trình môn học, sinh viên sẽ lần lượt tiếp cận các nội dung:\nKiến thức nền tảng về mạng và lập trình mạng Quản lý luồng nhập xuất (I/O) Quản lý địa chỉ và kết nối mạng Lập trình Socket TCP và UDP Xử lý đa tuyến, đa luồng Multicast UDP và Java RMI Thực hiện đồ án học phần cá nhân Mục tiêu của bài học Thông qua Bài 1, sinh viên sẽ:\nLàm quen với môi trường lập trình mạng bằng Java Hiểu được vai trò của địa chỉ IP trong giao tiếp mạng Biết cách sử dụng lớp InetAddress để lấy IP và hostname Chuẩn bị nền tảng cho các bài học tiếp theo về Socket và Server – Client ","permalink":"http://localhost:1313/blog/bai-viet-1/","summary":"GIỚI THIỆU HỌC PHẦN.","title":"Bài 1: Tổng quan khoá học"},{"content":"Trong lập trình mạng, nếu IP được xem như địa chỉ nhà của một máy tính trong mạng,\nthì Port (cổng) chính là số hiệu dùng để xác định chương trình hoặc dịch vụ cụ thể đang chạy trên máy đó.\nMột máy tính có thể chạy đồng thời nhiều ứng dụng mạng như Web Server, Database Server, Game Server hoặc Chat Server.\nMỗi ứng dụng bắt buộc phải gắn với một Port riêng để hệ điều hành có thể phân biệt và định tuyến dữ liệu chính xác.\nPort nằm ở đâu trong mô hình TCP/IP? Trong bộ giao thức TCP/IP, Port thuộc về Transport Layer (Tầng giao vận) và được sử dụng bởi hai giao thức chính là TCP và UDP.\nĐịa chỉ IP xác định máy nào sẽ nhận dữ liệu Port xác định ứng dụng nào trên máy đó sẽ xử lý dữ liệu Sự kết hợp giữa IP + Port tạo thành một Socket, là điểm cuối (endpoint) của quá trình giao tiếp mạng.\nCác loại Port phổ biến Port được đánh số từ 0 đến 65535 và được chia thành ba nhóm chính:\nInternet và các End Devices Trước khi tìm hiểu về Port, cần hiểu Internet được cấu thành từ hàng tỷ thiết bị đầu cuối (End Devices) như máy tính, điện thoại, máy chủ và các thiết bị IoT.\nCác thiết bị này kết nối với nhau thông qua nhiều lớp mạng khác nhau, và mỗi thiết bị khi tham gia giao tiếp mạng đều cần có địa chỉ IP và Port để định danh. Hình 2.1: Sơ đồ minh họa Internet và các thiết bị đầu cuối (End Devices) kết nối thông qua các mạng truy cập và mạng lõi.\nTrong quá trình giao tiếp mạng, một thiết bị không chỉ cần địa chỉ IP để xác định vị trí trong mạng, mà còn cần Port để xác định chính xác ứng dụng hoặc dịch vụ đang lắng nghe trên thiết bị đó.\nDo đó, Port đóng vai trò như “điểm tiếp nhận” (endpoint) cho các tiến trình mạng chạy trên cùng một máy.\nMô hình các tầng giao thức TCP/IP Để hiểu rõ Port hoạt động ở đâu và vì sao Server cần Port, ta cần nắm được mô hình giao thức TCP/IP – nền tảng của mọi ứng dụng mạng hiện nay.\nHình 2.2: Mô hình các tầng giao thức TCP/IP và các giao thức tiêu biểu tương ứng với từng tầng.\nTrong mô hình TCP/IP, địa chỉ IP hoạt động ở tầng Internet, giúp xác định thiết bị trong mạng.\nTrong khi đó, Port hoạt động ở tầng Transport (TCP/UDP), giúp xác định chính xác ứng dụng hoặc dịch vụ đang giao tiếp trên thiết bị đó.\nWell-known Ports (0 – 1023) Được dùng cho các dịch vụ chuẩn:\nPort 80: HTTP Port 443: HTTPS Port 21: FTP Port 25: SMTP Registered Ports (1024 – 49151) Thường dùng cho các ứng dụng phổ biến:\nPort 3306: MySQL Port 8080: Web Server thay thế port 80 Dynamic / Private Ports (49152 – 65535) Do hệ điều hành cấp phát tạm thời cho Client khi giao tiếp mạng.\nVì sao Server thường dùng cổng 8080? Cổng 8080 rất phổ biến trong quá trình phát triển và học tập vì:\nTránh xung đột với cổng 80 đang được hệ điều hành chiếm dụng Không cần quyền Administrator khi mở Server Phù hợp cho các Web Server thử nghiệm như: Apache Tomcat Spring Boot Node.js Lỗi thường gặp: “Address already in use” Lỗi này xảy ra khi Server cố gắng mở một Port đã bị chương trình khác chiếm dụng.\nNguyên nhân phổ biến:\nServer cũ chưa được tắt Port đang được dùng bởi dịch vụ khác Chạy nhiều Server cùng lúc Cách khắc phục:\nĐổi sang Port khác (ví dụ: 8080 → 9090) Kiểm tra Port đang sử dụng trong hệ điều hành Đảm bảo chỉ có một Server chạy tại một thời điểm Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), khái niệm Port sẽ được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Xây dựng mô hình Client – Server Java RMI và Multicast Việc hiểu rõ Port là nền tảng bắt buộc trước khi triển khai các ứng dụng mạng thực tế.\nKết luận Qua bài học này, ta đã:\nHiểu được Port là gì và vai trò của Port trong lập trình mạng Nắm được mối quan hệ giữa IP, Port và Socket Giải thích được lý do Server thường sử dụng cổng 8080 Chuẩn bị kiến thức nền cho các bài học tiếp theo về TCP và UDP ","permalink":"http://localhost:1313/blog/bai-viet-2/","summary":"MẠNG MÁY TÍNH \u0026amp; INTERNET.","title":"Bài 2: Kiến thức nền tảng?"},{"content":"Trong lập trình Java, luồng nhập xuất (Input / Output Streams) đóng vai trò trung gian giúp chương trình đọc và ghi dữ liệu từ nhiều nguồn khác nhau như bàn phím, file, console, bộ nhớ và sau này là socket mạng.\nHiểu rõ cơ chế luồng nhập xuất là bước nền bắt buộc trước khi đi vào lập trình Socket TCP, UDP hay Java RMI.\nLuồng (Stream) là gì? Luồng (Stream) là dòng dữ liệu di chuyển\ntừ nguồn → chương trình hoặc từ chương trình → đích.\nKhi Java đọc hoặc ghi dữ liệu, dữ liệu không đi trực tiếp mà luôn được đóng gói và truyền qua luồng.\nLuồng nhập xuất là gì? Luồng nhập xuất là cơ chế cho phép chương trình:\nNhận dữ liệu từ bên ngoài (Input) Ghi dữ liệu ra bên ngoài (Output) Luồng có thể kết nối với nhiều nguồn và đích khác nhau:\nFile Bàn phím Màn hình (console) Bộ nhớ Kết nối mạng (TCP / UDP) Dữ liệu trong luồng tồn tại dưới những dạng nào? Trong Java, dữ liệu trong luồng tồn tại dưới hai dạng chính:\nLuồng byte Luồng ký tự Việc chọn đúng loại luồng ảnh hưởng trực tiếp đến hiệu năng và tính chính xác của chương trình.\nLuồng byte trong Java Đặc điểm Dữ liệu được xử lý dưới dạng nhị phân Phù hợp với: File nhị phân Ảnh, video Socket mạng Dữ liệu phức tạp Các lớp gốc InputStream – luồng đọc byte OutputStream – luồng ghi byte Cả hai đều là lớp trừu tượng (abstract).\nCác luồng byte đọc phổ biến FileInputStream – đọc byte từ file ByteArrayInputStream – đọc từ mảng byte PipedInputStream – đọc từ luồng pipe Các luồng byte ghi phổ biến FileOutputStream – ghi byte vào file ByteArrayOutputStream – ghi vào mảng byte PipedOutputStream – ghi vào luồng pipe Mô hình đọc/ghi dữ liệu với Stream Quy trình chung khi làm việc với luồng:\nTạo đối tượng Stream Gắn Stream với nguồn hoặc đích Đọc/ghi dữ liệu trong vòng lặp Đóng Stream sau khi hoàn tất Luồng ký tự trong Java Đặc điểm Xử lý dữ liệu dạng Unicode Phù hợp với: File văn bản Chuỗi Dữ liệu hiển thị cho người dùng Các lớp gốc Reader – luồng đọc ký tự Writer – luồng ghi ký tự Các luồng ký tự đọc phổ biến FileReader – đọc file văn bản BufferedReader – đọc có bộ đệm StringReader – đọc chuỗi CharArrayReader – đọc mảng ký tự Các luồng ký tự ghi phổ biến FileWriter – ghi vào file văn bản BufferedWriter – ghi có bộ đệm PrintWriter – ghi dữ liệu dạng dễ đọc StringWriter – ghi chuỗi Luồng lọc dữ liệu (Filtered Streams) Luồng lọc dùng để chuyển đổi dữ liệu từ dạng byte/ký tự sang các kiểu dữ liệu khác.\nCác luồng lọc phổ biến DataInputStream DataOutputStream Cho phép đọc/ghi các kiểu dữ liệu nguyên thủy:\nint float double boolean char Đây là cầu nối giữa luồng thô và dữ liệu có kiểu trong Java.\nLưu trạng thái đối tượng – Serialization Serialization là gì? Serialization (chuỗi hóa) là quá trình chuyển đối tượng Java thành luồng byte để:\nLưu vào file Truyền qua mạng Phục hồi lại sau này Deserialization Ngược lại, Deserialization (giải chuỗi) là quá trình:\nĐọc byte Tái tạo lại đối tượng ban đầu Đây là nền tảng cho:\nLưu dữ liệu chương trình Java RMI Truyền object qua mạng Try-with-resources (TWR) Java hỗ trợ Try-with-resources để:\nTự động đóng stream Tránh rò rỉ tài nguyên Code gọn và an toàn hơn So với try-catch truyền thống, TWR:\nÍt lỗi hơn Dễ bảo trì hơn Được khuyến khích sử dụng Các lỗi I/O thường gặp Khi làm việc với luồng, một số exception phổ biến là:\nFileNotFoundException IOException EOFException UnsupportedEncodingException FileAlreadyExistsException AccessDeniedException SocketException MalformedURLException SerializationException InvalidPathException Việc bắt và xử lý exception đúng cách là yêu cầu bắt buộc trong lập trình Java.\nLiên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), luồng nhập xuất được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Truyền dữ liệu Client – Server Java RMI Multicast UDP Không hiểu I/O Stream → không thể làm mạng đúng cách.\nKết luận Qua bài học này, ta đã:\nHiểu khái niệm luồng nhập xuất trong Java Phân biệt luồng byte và luồng ký tự Nắm được cách đọc/ghi dữ liệu với Stream Biết vai trò của Serialization và Filtered Streams Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo Khi xử lý các tác vụ mạng (như gọi API), người mới học JS hay viết code lồng nhau kiểu này:\n1 2 3 4 5 6 7 8 9 10 // Cực hình Callback Hell getData(function(a) { getMoreData(a, function(b) { getMoreData(b, function(c) { getMoreData(c, function(d) { console.log(d); }); }); }); }); ","permalink":"http://localhost:1313/blog/bai-viet-3/","summary":"Tổng quan về Input/Output Streams trong Java – nền tảng cho xử lý file, console và lập trình mạng.","title":"Bài 3: Quản lý luồng nhập xuất trong Java"},{"content":"Trong lập trình mạng, trước khi chương trình có thể gửi hoặc nhận dữ liệu, điều quan trọng nhất là xác định đúng địa chỉ kết nối mạng. Nếu xác định sai địa chỉ, chương trình sẽ không thể giao tiếp, dù phần xử lý dữ liệu có đúng đến đâu.\nBài học này giúp bạn hiểu cách Java làm việc với địa chỉ IP, tên miền (DNS) và URL. Đây là nền tảng bắt buộc trước khi đi vào Socket TCP, UDP, Web Crawler và Java RMI.\nĐịa chỉ kết nối mạng là gì? Địa chỉ kết nối mạng là thông tin dùng để xác định máy nào trong mạng cần giao tiếp và dịch vụ nào trên máy đó sẽ xử lý dữ liệu.\nTrong Internet, địa chỉ kết nối thường bao gồm:\nĐịa chỉ IP Tên miền (Domain Name) Cổng (Port) Giao thức (Protocol) DNS – Domain Name System Hình 4.1 – Mô hình hoạt động của DNS (Domain Name System)\nClient gửi yêu cầu phân giải tên miền đến DNS Server, DNS trả về địa chỉ IP tương ứng để client kết nối đến server đích.*\nCon người dễ nhớ tên miền hơn các dãy số IP.\nDNS (Domain Name System) có nhiệm vụ ánh xạ tên miền sang địa chỉ IP, giúp client tìm đúng server cần kết nối.\nVí dụ:\ngoogle.com tương ứng với nhiều địa chỉ IP khác nhau www.cs.yale.edu tương ứng với 128.36.229.30 Nhờ DNS, người dùng không cần ghi nhớ địa chỉ IP khi truy cập Internet. Địa chỉ IPv4 IPv4 là dạng địa chỉ phổ biến, gồm 32 bit, thường được viết thành bốn nhóm số.\nVí dụ:\n192.168.1.1 8.8.8.8 Một số dải địa chỉ đặc biệt:\n127.x.x.x là loopback (localhost) 224.0.0.0 – 239.255.255.255 là multicast Lớp InetAddress trong Java Java cung cấp lớp InetAddress để làm việc với địa chỉ IP và DNS.\nLớp này thường được dùng để:\nPhân giải tên miền sang IP Kiểm tra loại địa chỉ Kiểm tra khả năng kết nối mạng Ví dụ minh họa:\n1 InetAddress address = InetAddress.getByName(\u0026#34;google.com\u0026#34;); URL – Uniform Resource Locator URL được dùng để xác định tài nguyên trên Internet như trang web, file hoặc dịch vụ.\nMột URL đầy đủ thường bao gồm các thành phần sau:\nGiao thức (Protocol) Tên miền (Host) Cổng (Port) Đường dẫn (Path) Chuỗi truy vấn (Query) Ví dụ một URL đầy đủ: https://www.hutech.edu.vn/admission?id=123\nURL cho biết lấy dữ liệu ở đâu và bằng cách nào.\nLớp URL trong Java Lớp URL cho phép chương trình Java:\nPhân tích các thành phần của URL Kết nối tới server Đọc dữ liệu từ Internet Ví dụ minh họa:\n1 URL url = new URL(\u0026#34;https://www.example.com\u0026#34;); Ý nghĩa của việc quản lý địa chỉ kết nối mạng Hiểu rõ cách quản lý địa chỉ mạng giúp:\nTránh kết nối sai server Chuẩn bị đúng địa chỉ cho Socket TCP/UDP Hiểu cách Web Crawler hoạt động Nắm vững mô hình Client – Server Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm địa chỉ kết nối mạng Biết vai trò của DNS và IPv4 Nắm được cách Java làm việc với InetAddress Hiểu cấu trúc và vai trò của URL Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-4/","summary":"Tìm hiểu cách Java quản lý địa chỉ mạng thông qua InetAddress, URL, URLConnection và DNS.","title":"Bài 4: Quản lý địa chỉ kết nối mạng trong Java"},{"content":"Trong lập trình mạng, TCP Socket là cơ chế quan trọng nhất để xây dựng các ứng dụng Client – Server có độ tin cậy cao.\nBài học này giúp bạn hiểu TCP là gì, vì sao cần TCP, và cách Java triển khai TCP thông qua Socket và ServerSocket.\nĐây là bước chuyển tiếp trực tiếp từ kiến thức địa chỉ mạng (IP, DNS, URL) sang giao tiếp dữ liệu thực tế giữa các chương trình.\nTCP là gì? TCP (Transmission Control Protocol) là giao thức truyền thông hướng kết nối, đảm bảo dữ liệu được truyền:\nĐúng thứ tự Đầy đủ Không bị mất mát Không bị trùng lặp Trước khi truyền dữ liệu, TCP yêu cầu thiết lập kết nối giữa hai bên, và chỉ khi kết nối thành công thì dữ liệu mới được trao đổi.\nVì sao sử dụng TCP? TCP được sử dụng khi ứng dụng yêu cầu độ tin cậy cao, ví dụ:\nỨng dụng chat Ứng dụng client–server Truyền file Game online theo lượt Hệ thống ngân hàng, thương mại điện tử TCP cung cấp các cơ chế quan trọng:\nĐảm bảo dữ liệu: gói tin bị mất sẽ được gửi lại Kiểm soát lỗi: phát hiện và sửa lỗi trong quá trình truyền Kiểm soát luồng: tránh làm quá tải phía nhận Giao tiếp hai chiều: cho phép gửi và nhận dữ liệu đồng thời Cơ chế hoạt động của TCP Quá trình giao tiếp TCP gồm ba giai đoạn chính:\nThiết lập kết nối (Bắt tay 3 bước – Three-way Handshake) Truyền dữ liệu Giải phóng kết nối Nhờ cơ chế này, TCP đảm bảo rằng hai bên luôn sẵn sàng trước khi truyền và kết thúc an toàn sau khi hoàn tất.\nMô hình Client – Server Các ứng dụng TCP thường hoạt động theo mô hình Client – Server.\nServer:\nChạy trước Lắng nghe yêu cầu kết nối Cung cấp dịch vụ Trả kết quả cho client Client:\nChạy sau Chủ động kết nối tới server Gửi yêu cầu Nhận phản hồi từ server Quá trình giao tiếp gồm:\nClient gửi yêu cầu Server xử lý Server trả kết quả cho client Socket trong Java Trong Java, Socket đại diện cho điểm cuối giao tiếp giữa client và server khi sử dụng TCP.\nSocket cho phép:\nGửi dữ liệu tới server Nhận dữ liệu từ server Giao tiếp hai chiều thông qua luồng nhập/xuất Ví dụ minh họa tạo Socket phía client:\n1 Socket socket = new Socket(\u0026#34;localhost\u0026#34;, 8080); ServerSocket trong Java ServerSocket được sử dụng ở phía server để:\nMở một cổng lắng nghe Chờ client kết nối Chấp nhận kết nối và tạo Socket giao tiếp ServerSocket đóng vai trò như cửa ngõ, cho phép các client kết nối vào server.\nVí dụ minh họa:\n1 ServerSocket server = new ServerSocket(8080); Luồng dữ liệu trong TCP Socket Sau khi kết nối TCP được thiết lập, client và server trao đổi dữ liệu thông qua các luồng:\nInputStream: dùng để đọc dữ liệu từ socket OutputStream: dùng để ghi dữ liệu vào socket Luồng dữ liệu này hoạt động tương tự như I/O Stream đã học ở bài trước,\nnhưng nguồn và đích là mạng thay vì file hay bàn phím.\nVí dụ ứng dụng: Trò chơi Oẳn Tù Tì Một bài tập tiêu biểu sử dụng TCP Socket là trò chơi Oẳn Tù Tì theo mô hình Client – Server.\nĐặc điểm Server quản lý luật chơi và điểm số Hai client gửi lựa chọn (kéo – búa – bao) Server xác định kết quả và gửi lại cho client Dữ liệu được truyền qua TCP để đảm bảo chính xác Thông qua bài tập này, sinh viên hiểu rõ:\nCách thiết lập kết nối TCP Cách trao đổi dữ liệu giữa nhiều client Cách xử lý lỗi mạng và ngoại lệ Ý nghĩa của lập trình TCP Socket Việc nắm vững TCP Socket giúp bạn:\nHiểu bản chất giao tiếp mạng Xây dựng hệ thống Client – Server thực tế Chuẩn bị cho các bài nâng cao như: Đa tuyến (Multi-thread) Socket UDP Java RMI Ứng dụng mạng phân tán Kết luận Qua bài học này, bạn đã:\nHiểu TCP là gì và vì sao cần TCP Nắm được mô hình Client – Server Biết vai trò của Socket và ServerSocket trong Java Hiểu cách dữ liệu được truyền qua TCP Chuẩn bị nền tảng cho các bài học UDP và xử lý đồng thời tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-5/","summary":"Giải thích mô hình Client–Server và cách lập trình Socket TCP trong Java – nền tảng cho giao tiếp mạng tin cậy.","title":"Bài 5: Lập trình Socket TCP trong Java"},{"content":"#Trong lập trình mạng, không phải lúc nào ứng dụng cũng cần độ tin cậy tuyệt đối như TCP.\nTrong nhiều trường hợp, điều quan trọng hơn là tốc độ truyền nhanh và độ trễ thấp.\nBài học này giới thiệu UDP Socket – cơ chế truyền dữ liệu không kết nối, được sử dụng rộng rãi trong các ứng dụng thời gian thực.\nUDP là gì? UDP (User Datagram Protocol) là giao thức truyền thông không hướng kết nối.\nĐiều này có nghĩa là:\nKhông thiết lập kết nối trước khi truyền Không đảm bảo dữ liệu đến nơi Không đảm bảo thứ tự gói tin Không tự động gửi lại gói tin bị mất UDP gửi dữ liệu theo từng datagram (gói tin độc lập).\nSo sánh TCP và UDP TCP UDP Có kết nối Không kết nối Đảm bảo dữ liệu Không đảm bảo Truyền theo luồng Truyền theo gói Độ trễ cao hơn Độ trễ thấp Phù hợp dữ liệu quan trọng Phù hợp dữ liệu thời gian thực Khi nào sử dụng UDP? UDP được sử dụng khi:\nCần truyền nhanh Có thể chấp nhận mất gói tin Dữ liệu được gửi liên tục Ví dụ ứng dụng UDP:\nTruyền video, audio trực tuyến Game online thời gian thực Chat broadcast DNS Multicast, streaming UDP Socket trong Java Java hỗ trợ UDP thông qua hai lớp chính:\nDatagramSocket: quản lý socket UDP DatagramPacket: đại diện cho gói dữ liệu UDP UDP không phân biệt client hay server rõ ràng như TCP.\nMỗi chương trình chỉ cần một DatagramSocket để gửi và nhận dữ liệu.\nDatagramPacket là gì? DatagramPacket là gói dữ liệu UDP, bao gồm:\nDữ liệu cần gửi Địa chỉ IP đích Số hiệu cổng Mỗi lần gửi hoặc nhận dữ liệu, UDP làm việc với một DatagramPacket riêng biệt.\nLuồng dữ liệu trong UDP UDP không có luồng InputStream / OutputStream như TCP.\nQuy trình truyền dữ liệu UDP:\nTạo DatagramSocket Tạo DatagramPacket chứa dữ liệu Gửi packet đi Nhận packet về Đọc dữ liệu từ packet Mỗi gói tin là độc lập, không liên quan đến các gói khác.\nĐặc điểm quan trọng của UDP Không kiểm soát lỗi Không kiểm soát luồng Không bắt tay kết nối Gửi nhanh, xử lý đơn giản Phù hợp truyền broadcast và multicast Chính vì vậy, UDP thường được dùng khi tốc độ quan trọng hơn độ chính xác tuyệt đối.\nÝ nghĩa của lập trình Socket UDP Nắm vững UDP giúp bạn:\nHiểu bản chất truyền dữ liệu không kết nối Xây dựng ứng dụng thời gian thực Phân biệt rõ TCP và UDP trong thiết kế hệ thống Chuẩn bị cho các chủ đề nâng cao như: Multicast UDP Java RMI Hệ thống phân tán Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính, UDP được sử dụng trong:\nSocket UDP Multicast Ứng dụng truyền tin nhanh Game, streaming, broadcast Hiểu UDP giúp bạn chọn đúng giao thức cho từng bài toán thực tế.\nKết luận Qua bài học này, bạn đã:\nHiểu UDP là gì và cơ chế hoạt động Phân biệt được TCP và UDP Biết vai trò của DatagramSocket và DatagramPacket Hiểu cách truyền dữ liệu không kết nối Chuẩn bị nền tảng cho bài Multicast UDP \u0026amp; Java RMI tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-6/","summary":"Giải thích giao thức UDP và cách Java lập trình Socket UDP – nền tảng cho truyền dữ liệu nhanh, không kết nối.","title":"Bài 6: Lập trình Socket UDP trong Java"},{"content":"Trong các ứng dụng mạng thực tế, đặc biệt là Server, chương trình thường phải xử lý nhiều yêu cầu cùng lúc.\nNếu chỉ sử dụng một luồng thực thi, server sẽ bị tắc nghẽn, các client phải chờ đợi và hiệu năng giảm nghiêm trọng.\nVì vậy, lập trình đa tuyến (Multithreading) và xử lý đồng thời (Concurrency) là kỹ thuật bắt buộc trong lập trình mạng.\nTuyến (Thread) là gì? Thread là một dòng điều khiển tuần tự bên trong một chương trình.\nMột chương trình (process) có thể chứa nhiều thread Các thread có thể chạy đồng thời Mỗi thread thực hiện một nhiệm vụ riêng Thread không phải là một chương trình độc lập,\nnó luôn thuộc về một process.\nProcess và Thread Process:\nCó không gian bộ nhớ riêng Chạy độc lập với process khác Tạo và chuyển đổi tốn nhiều tài nguyên Thread:\nChia sẻ bộ nhớ với các thread khác trong cùng process Tạo nhanh hơn process Chuyển đổi nhanh hơn Nhờ thread, chương trình có thể thực hiện nhiều công việc cùng lúc trong cùng một ứng dụng.\nVì sao cần lập trình đa tuyến? Lập trình đa tuyến giúp:\nTăng hiệu suất và khả năng đáp ứng Tận dụng thời gian chờ đợi (I/O, mạng, tải file) Chia nhỏ tác vụ và xử lý đồng thời Cải thiện trải nghiệm người dùng Trong lập trình mạng, đa tuyến cho phép server phục vụ nhiều client cùng lúc.\nThực thi Thread trong Java Trong Java, một thread bắt đầu chạy khi gọi phương thức start().\nKhi thread chạy, JVM thực thi mã trong phương thức run() Khi run() kết thúc, thread cũng kết thúc Một thread không thể start lại, muốn chạy lại phải tạo thread mới Thread cần có điều kiện dừng rõ ràng để tránh chạy vô hạn.\nỨng dụng đa tuyến trong lập trình mạng Ứng dụng Chat đa tuyến Một ví dụ tiêu biểu của đa tuyến trong mạng là ứng dụng chat nhiều client – một server.\nĐặc điểm:\nServer chấp nhận nhiều client kết nối cùng lúc Mỗi client được xử lý bởi một thread riêng Tin nhắn từ một client được gửi tới tất cả client khác Server ghi lại nội dung chat vào file log Thông qua ví dụ này, sinh viên hiểu rõ:\nCách server xử lý nhiều kết nối đồng thời Cách phối hợp giữa socket và thread Vai trò của đa tuyến trong ứng dụng mạng Xử lý đồng thời (Concurrency) Xử lý đồng thời xảy ra khi nhiều thread:\nChạy cùng lúc Truy cập tài nguyên chung (biến, file, bộ nhớ) Nếu không kiểm soát tốt, chương trình có thể gặp các vấn đề nghiêm trọng.\nRace Condition Race Condition xảy ra khi:\nNhiều thread cùng truy cập và thay đổi dữ liệu chung Kết quả phụ thuộc vào thứ tự thực thi không xác định Điều này có thể dẫn đến:\nDữ liệu sai lệch Kết quả không nhất quán Lỗi khó phát hiện Đồng bộ hóa (Synchronization) Để tránh race condition, Java cung cấp cơ chế đồng bộ hóa:\nĐảm bảo chỉ một thread được truy cập tài nguyên tại một thời điểm Giữ cho dữ liệu luôn nhất quán Đồng bộ hóa là nền tảng để xây dựng các ứng dụng an toàn và ổn định khi chạy đa tuyến.\nCác vấn đề thường gặp trong xử lý đồng thời Một số vấn đề phổ biến:\nRace condition: tranh chấp dữ liệu Deadlock: các thread chờ nhau vô hạn Livelock: các thread liên tục phản ứng nhưng không tiến triển Starvation: thread không bao giờ được cấp tài nguyên Những vấn đề này khiến lập trình đa tuyến trở nên phức tạp và khó debug.\nLập lịch Thread trong Java Java sử dụng cơ chế lập lịch theo độ ưu tiên:\nMỗi thread có độ ưu tiên từ MIN_PRIORITY đến MAX_PRIORITY JVM chọn thread runnable có độ ưu tiên cao hơn để chạy Thread có thể nhường CPU cho thread khác bằng cách gọi yield() Việc hiểu cơ chế lập lịch giúp lập trình viên thiết kế thread hợp lý hơn.\nÝ nghĩa của lập trình đa tuyến và xử lý đồng thời Nắm vững kiến thức bài này giúp bạn:\nXây dựng server xử lý nhiều client Viết ứng dụng mạng hiệu năng cao Tránh lỗi tranh chấp dữ liệu Chuẩn bị cho các chủ đề nâng cao như: Server đa tuyến Pooling Threads Multicast UDP Java RMI Hệ thống phân tán Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm thread và multithreading Phân biệt process và thread Biết vai trò của đa tuyến trong lập trình mạng Hiểu các vấn đề xử lý đồng thời và race condition Chuẩn bị nền tảng cho các bài học nâng cao tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-7/","summary":"Giải thích lập trình đa tuyến và xử lý đồng thời trong Java – nền tảng cho các ứng dụng mạng nhiều client và hệ thống phân tán.","title":"Bài 7: Lập trình đa tuyến và xử lý đồng thời trong Java"},{"content":"Buổi 8 gồm 2 phần lớn:\nMulticast UDP: gửi dữ liệu từ một nguồn đến nhiều máy nhận cùng lúc (1 → N). Java RMI: gọi phương thức từ xa giữa các ứng dụng Java như gọi hàm bình thường (Remote Method Invocation). Đây là các kỹ thuật thường gặp trong streaming, trò chuyện nhóm, giám sát từ xa và hệ thống phân tán.\n1) UDP Multicast Unicast, Broadcast và Multicast Trong mạng máy tính có 3 kiểu gửi dữ liệu phổ biến:\nUnicast: 1 nguồn → 1 đích\nVí dụ: bạn mở một trang web, server trả dữ liệu cho riêng bạn.\nBroadcast: 1 nguồn → tất cả máy trong mạng nội bộ\nVí dụ: một thông báo phát cho toàn bộ LAN.\nMulticast: 1 nguồn → một nhóm máy đã đăng ký nhận dữ liệu\nVí dụ: server phát stream video cho nhóm người xem cùng lúc.\nMulticast là cách truyền hiệu quả khi nhiều máy cùng cần nhận một nội dung giống nhau.\nTại sao dùng UDP Multicast? UDP Multicast thường được dùng vì:\nHiệu suất cao: gửi 1 lần nhưng nhiều máy nhận → giảm tải mạng và server. Đơn giản, nhanh: UDP là kiểu “gửi và quên”, không phải chờ xác nhận. Tối ưu trong LAN: phù hợp môi trường mạng nội bộ (Local Area Network). Rất hợp streaming: audio/video cần tốc độ và độ trễ thấp hơn là đảm bảo tuyệt đối. Ứng dụng của Multicast Multicast có thể dùng trong:\nTruyền phát multimedia trực tiếp (audio/video streaming) Trò chuyện nhóm, hội thoại nhóm Quảng bá thông tin cấu hình mạng và cập nhật trong hệ thống mạng Game nhiều người chơi (gửi trạng thái game cho nhiều người) Phát thông tin trạng thái/cảnh báo cho nhiều thiết bị Phát tán cập nhật phần mềm trong mạng nội bộ Địa chỉ Multicast IPv4 Trong IPv4:\nClass D là dải địa chỉ dành cho multicast Dải địa chỉ multicast thường gặp: 224.0.0.0 – 239.255.255.255 Một số nhóm multicast hay được nhắc:\n224.0.0.1: tất cả host trong local subnet Multicast Group là gì? Multicast hoạt động theo “nhóm”:\nMột multicast group giống như một kênh. Máy nào muốn nhận dữ liệu phải tham gia nhóm (join group). Khi rời nhóm thì không nhận dữ liệu nữa. Multicast trong Java Java hỗ trợ multicast qua lớp:\njava.net.MulticastSocket (kế thừa từ DatagramSocket) Một số thao tác quan trọng:\njoinGroup(...): tham gia nhóm multicast leaveGroup(...): rời nhóm multicast setTimeToLive(ttl): đặt TTL (thời gian sống của gói tin, qua bao nhiêu router) Quy trình gửi dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket Tham gia nhóm multicast Tạo DatagramPacket chứa dữ liệu + địa chỉ nhóm + port Gửi packet Rời nhóm Ví dụ minh họa (ngắn, chỉ để hiểu):\n1 2 3 4 5 6 7 8 9 10 11 12 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(); socket.joinGroup(group); socket.setTimeToLive(5); byte[] data = \u0026#34;Hello Multicast\u0026#34;.getBytes(); DatagramPacket packet = new DatagramPacket(data, data.length, group, 9876); socket.send(packet); socket.leaveGroup(group); socket.close(); Quy trình nhận dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket lắng nghe trên port Tham gia nhóm multicast Tạo DatagramPacket rỗng để nhận dữ liệu Gọi receive() để chờ gói tin gửi về Đọc dữ liệu từ packet Rời nhóm và đóng socket Ví dụ minh họa (ngắn):\n1 2 3 4 5 6 7 8 9 10 11 12 13 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(9876); socket.joinGroup(group); byte[] buf = new byte[1024]; DatagramPacket packet = new DatagramPacket(buf, buf.length); socket.receive(packet); String msg = new String(packet.getData(), 0, packet.getLength()); System.out.println(\u0026#34;Received: \u0026#34; + msg); socket.leaveGroup(group); socket.close(); 2) Java RMI Java RMI là gì? RMI (Remote Method Invocation) cho phép chương trình Java:\nGọi phương thức của một đối tượng nằm trên máy khác Cảm giác giống như gọi method trong cùng chương trình Nói đơn giản:\nClient gọi: remoteObject.sum(1,2) Server thực thi thật và trả kết quả về cho client RMI giúp che giấu toàn bộ chi tiết mạng phía sau, người lập trình chỉ tập trung vào logic.\nVì sao dùng Java RMI? Java RMI được sử dụng vì:\nTích hợp sẵn trong Java, dễ triển khai nếu cả client và server đều dùng Java Gọi phương thức từ xa đơn giản như gọi hàm thông thường Hỗ trợ dữ liệu phức tạp: đối tượng, mảng, class tự định nghĩa Tự động xử lý giao tiếp mạng thông qua cơ chế stub / skeleton Dựa trên TCP/IP nên tương đối ổn định và tin cậy Hạn chế của Java RMI Một số điểm hạn chế cần lưu ý:\nPhụ thuộc Java: chủ yếu phù hợp Java ↔ Java Thiết kế dịch vụ phức tạp vẫn cần tổ chức tốt (đặc biệt khi dùng callback) Quản lý phiên và kết nối không mạnh như các giải pháp hiện đại Bảo mật cần cấu hình cẩn thận trong môi trường thực tế Ý tưởng kiến trúc RMI (hiểu nhanh) Trong Java RMI có các thành phần chính:\nRemote Interface\nKhai báo các phương thức cho phép gọi từ xa\nServer Implementation\nLớp cài đặt interface, chứa logic xử lý thật\nRMI Registry\nNơi đăng ký service để client tìm thấy server\nClient\nTìm (lookup) service trong registry và gọi phương thức\nCác bước triển khai RMI (tóm tắt) Định nghĩa Remote Interface Cài đặt interface bằng một class server (remote object) Viết chương trình server: tạo object và bind vào registry Viết chương trình client: lookup registry và gọi method Chạy RMI registry, chạy server, sau đó chạy client Ví dụ ứng dụng RMI Một số ví dụ thường gặp:\nTính tổng 2 số từ xa Dịch vụ quản lý tài khoản ATM Dịch vụ giám sát nhiệt độ có callback (server gọi ngược lại client) Bài tập gợi ý theo đúng nội dung buổi 8 BT8.01: Mô phỏng streaming video\n(1 server phát, nhiều client nhận dữ liệu)\nBT8.02: Server quản lý tài khoản ATM bằng RMI\n(thêm user, đăng nhập, gửi/rút tiền, lưu lịch sử giao dịch)\nKết luận Qua bài học này, bạn đã:\nHiểu sự khác nhau giữa Unicast, Broadcast và Multicast Nắm được vì sao Multicast UDP phù hợp cho truyền dữ liệu nhóm và streaming Biết cách Java hỗ trợ multicast qua MulticastSocket Hiểu Java RMI và cơ chế gọi phương thức từ xa Chuẩn bị nền tảng cho các bài ứng dụng mạng phân tán và đồ án học phần ","permalink":"http://localhost:1313/blog/bai-viet-8/","summary":"Giải thích Multicast UDP (gửi 1-n) và Java RMI (gọi phương thức từ xa) – nền tảng cho ứng dụng nhóm và hệ phân tán.","title":"Bài 8: Multicast UDP và Java RMI"},{"content":"Sau khi hoàn thành các bài về TCP, UDP, đa tuyến và xử lý đồng thời,\nchúng ta đã có đủ nền tảng để xây dựng một ứng dụng mạng hoàn chỉnh.\nBài học này giúp bạn xâu chuỗi toàn bộ kiến thức đã học,\nhiểu rõ mỗi công nghệ dùng trong trường hợp nào,\nvà cách thiết kế một hệ thống mạng đúng tư duy kỹ sư.\nNhìn lại các mô hình giao tiếp mạng đã học Trong lập trình mạng, các ứng dụng thường được xây dựng dựa trên mô hình Client – Server.\nClient: gửi yêu cầu, nhập dữ liệu, hiển thị kết quả Server: xử lý logic, quản lý dữ liệu, trả kết quả Tùy bài toán, ta lựa chọn giao thức và mô hình phù hợp.\nSo sánh TCP, UDP và Multicast TCP – Giao tiếp tin cậy TCP phù hợp khi:\nCần đảm bảo dữ liệu đúng và đủ Cần kết nối ổn định, hai chiều Ví dụ: chat, truyền file, game theo lượt, hệ thống ngân hàng Đặc trưng:\nCó bắt tay 3 bước Có kiểm soát lỗi, kiểm soát luồng Tốn tài nguyên hơn UDP UDP – Giao tiếp nhanh, không kết nối UDP phù hợp khi:\nƯu tiên tốc độ Chấp nhận mất gói Ví dụ: game thời gian thực, streaming, cảm biến Đặc trưng:\nKhông kết nối Không đảm bảo thứ tự Ít độ trễ UDP Multicast – Truyền dữ liệu nhóm Multicast được dùng khi:\nMột nguồn → nhiều người nhận Dữ liệu giống nhau cho tất cả client Ví dụ: livestream, thông báo hệ thống, truyền trạng thái Ưu điểm:\nGiảm tải server Tiết kiệm băng thông Phù hợp mạng LAN Vai trò của đa tuyến (Multithreading) Trong thực tế, server không thể xử lý từng client một cách tuần tự.\nĐa tuyến giúp:\nNhiều client kết nối cùng lúc Không client nào bị “đóng băng” Tăng khả năng mở rộng hệ thống Ví dụ:\nServer chat: mỗi client là một thread Server TCP: mỗi socket được xử lý riêng Thiết kế một ứng dụng mạng hoàn chỉnh Khi thiết kế, cần xác định rõ:\nGiao thức: TCP hay UDP? Mô hình: 1–1, 1–n, n–n? Đồng thời hay tuần tự? Client gửi gì? Server xử lý gì? Một thiết kế tốt luôn:\nPhân tách rõ giao tiếp – xử lý – dữ liệu Dễ mở rộng Dễ bảo trì Liên hệ với đồ án học phần Các đồ án như:\nChat đa tuyến Oẳn Tù Tì client–server Streaming UDP Dịch vụ RMI Đều là sự kết hợp của các kiến thức đã học,\nkhông phải nội dung mới.\nKết luận Qua bài học này, bạn đã:\nHệ thống lại toàn bộ kiến thức lập trình mạng Hiểu rõ khi nào dùng TCP, UDP, Multicast Nắm được vai trò của đa tuyến Biết cách tư duy thiết kế một ứng dụng mạng hoàn chỉnh Đây là bước chuẩn bị quan trọng trước khi vận dụng toàn bộ kiến thức vào một hệ thống thực tế.\n","permalink":"http://localhost:1313/blog/bai-viet-9/","summary":"Tổng hợp kiến thức TCP, UDP, đa tuyến và cách thiết kế ứng dụng mạng Client–Server hoàn chỉnh.","title":"Bài 9: Tổng hợp kiến thức \u0026 thiết kế ứng dụng mạng"},{"content":"Bài cuối cùng của học phần không nhằm giới thiệu công nghệ mới,\nmà tập trung vào cách vận dụng kiến thức đã học vào thực tế.\nĐây là giai đoạn chuyển từ:\n“Biết dùng” → “Biết thiết kế” → “Biết đánh giá hệ thống”\nTư duy vận dụng kiến thức Một ứng dụng mạng hoàn chỉnh cần trả lời được các câu hỏi:\nVì sao chọn TCP mà không phải UDP? Vì sao cần đa tuyến? Server có chịu được nhiều client không? Hệ thống có mở rộng được không? Đây chính là tư duy kỹ sư, không phải chỉ “chạy được là xong”.\nĐánh giá một ứng dụng mạng Khi hoàn thiện hệ thống, cần xem xét:\n1. Tính đúng đắn Dữ liệu có truyền đúng không? Có mất gói không? Có xử lý lỗi không? 2. Tính đồng thời Nhiều client có dùng chung được không? Có bị treo server không? Có race condition không? 3. Hiệu năng Độ trễ thế nào? Server có bị quá tải không? Có tách luồng hợp lý không? Liên hệ với các mô hình phân tán Các hệ thống đã học là nền tảng cho:\nHệ thống client–server lớn Ứng dụng phân tán Microservices Cloud services Java RMI, TCP đa tuyến hay UDP Multicast\nđều là những viên gạch đầu tiên.\nTừ học phần đến thực tế Sau học phần này, bạn có thể tiếp cận:\nWebSocket REST API gRPC Message Queue (Kafka, RabbitMQ) Hệ thống realtime Tư duy lập trình mạng không thay đổi, chỉ công nghệ thay đổi.\nTổng kết toàn bộ học phần Qua toàn bộ chuỗi bài, bạn đã:\nHiểu cách dữ liệu đi qua mạng Làm việc với TCP, UDP, Multicast Xử lý đa tuyến và đồng thời Tiếp cận lập trình phân tán với RMI Có tư duy thiết kế hệ thống mạng Lời kết Lập trình mạng không chỉ là code socket,\nmà là hiểu cách các hệ thống nói chuyện với nhau.\nNếu bạn hiểu được điều đó,\nbạn đã vượt xa mức “học để qua môn”.\n","permalink":"http://localhost:1313/blog/bai-viet-10/","summary":"Vận dụng toàn bộ kiến thức lập trình mạng để xây dựng, đánh giá và hoàn thiện một ứng dụng thực tế.","title":"Bài 10: Hoàn thiện \u0026 vận dụng lập trình mạng"},{"content":"Lời mở đầu Có những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\nMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\nHọc tập Những năm đại học trôi qua nhanh hơn mình từng nghĩ. Ngày mới bước chân vào giảng đường, mình vẫn còn khá mơ hồ về ngành học, về tương lai, về chính bản thân mình sẽ trở thành ai sau bốn năm. Nhưng rồi từng môn học, từng bài tập nhóm, từng đồ án kéo mình lại gần hơn với cách một hệ thống được hình thành và vận hành.\nHệ thống thông tin không chỉ là lập trình, cũng không đơn thuần là công nghệ. Đó là câu chuyện về con người, quy trình và dữ liệu. Mình học cách đặt câu hỏi, học cách lắng nghe yêu cầu, học cách vẽ ra những sơ đồ tưởng chừng khô khan nhưng lại chứa rất nhiều suy nghĩ phía sau. Dần dần, mình nhận ra mình thích phần “hiểu vấn đề” hơn là chỉ chăm chăm vào lời giải.\nĐịnh hướng Ở thời điểm hiện tại, mình đang định hướng theo con đường Business Analyst (BA). Mình hứng thú với vai trò đứng giữa – không quá xa kỹ thuật, cũng không tách rời nghiệp vụ. Đó là nơi cần sự rõ ràng trong tư duy, sự kiên nhẫn trong giao tiếp và khả năng chuyển hóa những điều mơ hồ thành thứ có thể triển khai được.\nMình không nghĩ BA là một vị trí “nhẹ nhàng” hay “an toàn”. Ngược lại, đó là công việc đòi hỏi phải học rất nhiều, sai rất nhiều và sửa rất nhiều. Nhưng chính điều đó khiến mình thấy phù hợp. Mình muốn hiểu hệ thống trước khi xây dựng nó, muốn biết vì sao người ta see cần một chức năng, chứ không chỉ là nó được viết như thế nào.\nBlog Blog này ra đời khá tự nhiên, giống như một cuốn sổ mở rộng hơn là một trang thể hiện điều gì đó to tát. Mình viết để nhớ, để hệ thống lại những gì đã học, và đôi khi là để sắp xếp lại suy nghĩ của chính mình.\nỞ đây có thể là kiến thức về Hệ thống thông tin, về phân tích nghiệp vụ, về lập trình, hoặc đơn giản là những trải nghiệm học tập và va chạm trong quá trình làm đồ án, làm việc nhóm, và chuẩn bị bước ra môi trường thực tế. Mình không mong mọi thứ phải hoàn hảo, chỉ mong nó thật và có ích cho ai đó đang đi trên con đường tương tự.\nLời kết Mình đang ở một giai đoạn chưa thể gọi là trưởng thành, nhưng cũng không còn quá non nớt. Vẫn đang học, vẫn đang thử, vẫn đang sai và sửa mỗi ngày. Nếu có một điều mình mong giữ được lâu nhất, thì đó là sự tò mò và tinh thần học hỏi – những thứ giúp mình không đứng yên giữa rất nhiều lựa chọn ngoài kia.\nCảm ơn bạn đã ghé qua và đọc những dòng này. Hy vọng ở một thời điểm nào đó, những chia sẻ nhỏ ở đây sẽ chạm đến bạn – dù chỉ là một chút. \u0026ldquo;Học để chia sẻ, chia sẻ để học nhiều hơn.\u0026rdquo;\nLiên hệ Nếu bạn muốn gửi cho mình vài dòng trao đổi,\nbạn có thể liên hệ với mình qua Email hoặc GitHub ,Facebook dưới đây.\nCảm ơn bạn đã ghé thăm blog! ","permalink":"http://localhost:1313/about/","summary":"\u003ch2 id=\"lời-mở-đầu\"\u003eLời mở đầu\u003c/h2\u003e\n\u003cp\u003eCó những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\u003c/p\u003e\n\u003cp\u003eMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\u003c/p\u003e","title":"Giới thiệu"},{"content":"Trong lập trình mạng, trước khi kết nối, ta phải biết \u0026ldquo;địa chỉ nhà\u0026rdquo; (IP) của mình và đối phương. Java cung cấp class\nHình 1.1: Hiệu ứng Dunning–Kruger – mức độ tự tin thay đổi theo kinh nghiệm học tập\nGóc nhìn học tập: Hiệu ứng Dunning–Kruger InetAddress để làm việc này.\nĐịa chỉ IP là gì trong lập trình mạng? IP (Internet Protocol Address) là địa chỉ định danh của một thiết bị khi tham gia vào mạng máy tính.\nTrong lập trình mạng, IP đóng vai trò quan trọng trong việc:\nXác định máy gửi và máy nhận Định tuyến dữ liệu trong quá trình truyền thông Thiết lập kết nối giữa các tiến trình chạy trên những máy khác nhau Nếu không có địa chỉ IP, các máy tính sẽ không thể nhận biết và giao tiếp với nhau.\nVai trò của lớp InetAddress trong Java Lớp InetAddress đại diện cho một địa chỉ IP trong Java.\nThông qua lớp này, lập trình viên có thể:\nLấy địa chỉ IP của máy đang chạy chương trình Lấy tên máy (hostname) Phân giải tên miền sang địa chỉ IP Chuẩn bị thông tin để tạo Socket hoặc ServerSocket Hầu hết các chương trình lập trình mạng trong Java đều sử dụng InetAddress ở bước khởi tạo.\nPhân tích ý nghĩa các lệnh trong chương trình InetAddress.getLocalHost()\n→ Trả về đối tượng đại diện cho máy cục bộ (localhost).\ngetHostName()\n→ Lấy tên máy do hệ điều hành hoặc mạng gán.\ngetHostAddress()\n→ Lấy địa chỉ IP của máy dưới dạng chuỗi.\nViệc in ra hostname và IP giúp:\nKiểm tra cấu hình mạng Xác định đúng máy khi kết nối Client – Server Debug lỗi mạng Một số lưu ý khi lấy IP trong Java Khi máy không kết nối mạng, IP có thể là 127.0.0.1 Khi máy có nhiều card mạng (WiFi, LAN, VPN), IP trả về có thể không phải IP Internet Trên Server, hostname và IP thường khác máy cá nhân Ứng dụng thực tế Việc xác định IP của máy thường được sử dụng trong:\nChương trình Client – Server Thông báo IP Server cho Client kết nối Kiểm tra kết nối mạng LAN Ghi log và giám sát hệ thống Kết luận Qua bài học này, ta đã:\nHiểu vai trò của địa chỉ IP trong lập trình mạng Biết cách lấy IP bằng lớp InetAddress Chuẩn bị nền tảng cho các kỹ thuật TCP, UDP và RMI Liên hệ với học phần Lập trình Mạng máy tính Bài học này nằm trong nội dung mở đầu của học phần Lập trình Mạng máy tính (CMP180) tại Trường Đại học Công nghệ TP.HCM (HUTECH).\nTrong lộ trình môn học, sinh viên sẽ lần lượt tiếp cận các nội dung:\nKiến thức nền tảng về mạng và lập trình mạng Quản lý luồng nhập xuất (I/O) Quản lý địa chỉ và kết nối mạng Lập trình Socket TCP và UDP Xử lý đa tuyến, đa luồng Multicast UDP và Java RMI Thực hiện đồ án học phần cá nhân Mục tiêu của bài học Thông qua Bài 1, sinh viên sẽ:\nLàm quen với môi trường lập trình mạng bằng Java Hiểu được vai trò của địa chỉ IP trong giao tiếp mạng Biết cách sử dụng lớp InetAddress để lấy IP và hostname Chuẩn bị nền tảng cho các bài học tiếp theo về Socket và Server – Client ","permalink":"http://localhost:1313/blog/bai-viet-1/","summary":"GIỚI THIỆU HỌC PHẦN.","title":"Bài 1: Tổng quan khoá học"},{"content":"Trong lập trình mạng, nếu IP được xem như địa chỉ nhà của một máy tính trong mạng,\nthì Port (cổng) chính là số hiệu dùng để xác định chương trình hoặc dịch vụ cụ thể đang chạy trên máy đó.\nMột máy tính có thể chạy đồng thời nhiều ứng dụng mạng như Web Server, Database Server, Game Server hoặc Chat Server.\nMỗi ứng dụng bắt buộc phải gắn với một Port riêng để hệ điều hành có thể phân biệt và định tuyến dữ liệu chính xác.\nPort nằm ở đâu trong mô hình TCP/IP? Trong bộ giao thức TCP/IP, Port thuộc về Transport Layer (Tầng giao vận) và được sử dụng bởi hai giao thức chính là TCP và UDP.\nĐịa chỉ IP xác định máy nào sẽ nhận dữ liệu Port xác định ứng dụng nào trên máy đó sẽ xử lý dữ liệu Sự kết hợp giữa IP + Port tạo thành một Socket, là điểm cuối (endpoint) của quá trình giao tiếp mạng.\nCác loại Port phổ biến Port được đánh số từ 0 đến 65535 và được chia thành ba nhóm chính:\nInternet và các End Devices Trước khi tìm hiểu về Port, cần hiểu Internet được cấu thành từ hàng tỷ thiết bị đầu cuối (End Devices) như máy tính, điện thoại, máy chủ và các thiết bị IoT.\nCác thiết bị này kết nối với nhau thông qua nhiều lớp mạng khác nhau, và mỗi thiết bị khi tham gia giao tiếp mạng đều cần có địa chỉ IP và Port để định danh. Hình 2.1: Sơ đồ minh họa Internet và các thiết bị đầu cuối (End Devices) kết nối thông qua các mạng truy cập và mạng lõi.\nTrong quá trình giao tiếp mạng, một thiết bị không chỉ cần địa chỉ IP để xác định vị trí trong mạng, mà còn cần Port để xác định chính xác ứng dụng hoặc dịch vụ đang lắng nghe trên thiết bị đó.\nDo đó, Port đóng vai trò như “điểm tiếp nhận” (endpoint) cho các tiến trình mạng chạy trên cùng một máy.\nMô hình các tầng giao thức TCP/IP Để hiểu rõ Port hoạt động ở đâu và vì sao Server cần Port, ta cần nắm được mô hình giao thức TCP/IP – nền tảng của mọi ứng dụng mạng hiện nay.\nHình 2.2: Mô hình các tầng giao thức TCP/IP và các giao thức tiêu biểu tương ứng với từng tầng.\nTrong mô hình TCP/IP, địa chỉ IP hoạt động ở tầng Internet, giúp xác định thiết bị trong mạng.\nTrong khi đó, Port hoạt động ở tầng Transport (TCP/UDP), giúp xác định chính xác ứng dụng hoặc dịch vụ đang giao tiếp trên thiết bị đó.\nWell-known Ports (0 – 1023) Được dùng cho các dịch vụ chuẩn:\nPort 80: HTTP Port 443: HTTPS Port 21: FTP Port 25: SMTP Registered Ports (1024 – 49151) Thường dùng cho các ứng dụng phổ biến:\nPort 3306: MySQL Port 8080: Web Server thay thế port 80 Dynamic / Private Ports (49152 – 65535) Do hệ điều hành cấp phát tạm thời cho Client khi giao tiếp mạng.\nVì sao Server thường dùng cổng 8080? Cổng 8080 rất phổ biến trong quá trình phát triển và học tập vì:\nTránh xung đột với cổng 80 đang được hệ điều hành chiếm dụng Không cần quyền Administrator khi mở Server Phù hợp cho các Web Server thử nghiệm như: Apache Tomcat Spring Boot Node.js Lỗi thường gặp: “Address already in use” Lỗi này xảy ra khi Server cố gắng mở một Port đã bị chương trình khác chiếm dụng.\nNguyên nhân phổ biến:\nServer cũ chưa được tắt Port đang được dùng bởi dịch vụ khác Chạy nhiều Server cùng lúc Cách khắc phục:\nĐổi sang Port khác (ví dụ: 8080 → 9090) Kiểm tra Port đang sử dụng trong hệ điều hành Đảm bảo chỉ có một Server chạy tại một thời điểm Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), khái niệm Port sẽ được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Xây dựng mô hình Client – Server Java RMI và Multicast Việc hiểu rõ Port là nền tảng bắt buộc trước khi triển khai các ứng dụng mạng thực tế.\nKết luận Qua bài học này, ta đã:\nHiểu được Port là gì và vai trò của Port trong lập trình mạng Nắm được mối quan hệ giữa IP, Port và Socket Giải thích được lý do Server thường sử dụng cổng 8080 Chuẩn bị kiến thức nền cho các bài học tiếp theo về TCP và UDP ","permalink":"http://localhost:1313/blog/bai-viet-2/","summary":"MẠNG MÁY TÍNH \u0026amp; INTERNET.","title":"Bài 2: Kiến thức nền tảng?"},{"content":"Trong lập trình Java, luồng nhập xuất (Input / Output Streams) đóng vai trò trung gian giúp chương trình đọc và ghi dữ liệu từ nhiều nguồn khác nhau như bàn phím, file, console, bộ nhớ và sau này là socket mạng.\nHiểu rõ cơ chế luồng nhập xuất là bước nền bắt buộc trước khi đi vào lập trình Socket TCP, UDP hay Java RMI.\nLuồng (Stream) là gì? Luồng (Stream) là dòng dữ liệu di chuyển\ntừ nguồn → chương trình hoặc từ chương trình → đích.\nKhi Java đọc hoặc ghi dữ liệu, dữ liệu không đi trực tiếp mà luôn được đóng gói và truyền qua luồng.\nLuồng nhập xuất là gì? Luồng nhập xuất là cơ chế cho phép chương trình:\nNhận dữ liệu từ bên ngoài (Input) Ghi dữ liệu ra bên ngoài (Output) Luồng có thể kết nối với nhiều nguồn và đích khác nhau:\nFile Bàn phím Màn hình (console) Bộ nhớ Kết nối mạng (TCP / UDP) Dữ liệu trong luồng tồn tại dưới những dạng nào? Trong Java, dữ liệu trong luồng tồn tại dưới hai dạng chính:\nLuồng byte Luồng ký tự Việc chọn đúng loại luồng ảnh hưởng trực tiếp đến hiệu năng và tính chính xác của chương trình.\nLuồng byte trong Java Đặc điểm Dữ liệu được xử lý dưới dạng nhị phân Phù hợp với: File nhị phân Ảnh, video Socket mạng Dữ liệu phức tạp Các lớp gốc InputStream – luồng đọc byte OutputStream – luồng ghi byte Cả hai đều là lớp trừu tượng (abstract).\nCác luồng byte đọc phổ biến FileInputStream – đọc byte từ file ByteArrayInputStream – đọc từ mảng byte PipedInputStream – đọc từ luồng pipe Các luồng byte ghi phổ biến FileOutputStream – ghi byte vào file ByteArrayOutputStream – ghi vào mảng byte PipedOutputStream – ghi vào luồng pipe Mô hình đọc/ghi dữ liệu với Stream Quy trình chung khi làm việc với luồng:\nTạo đối tượng Stream Gắn Stream với nguồn hoặc đích Đọc/ghi dữ liệu trong vòng lặp Đóng Stream sau khi hoàn tất Luồng ký tự trong Java Đặc điểm Xử lý dữ liệu dạng Unicode Phù hợp với: File văn bản Chuỗi Dữ liệu hiển thị cho người dùng Các lớp gốc Reader – luồng đọc ký tự Writer – luồng ghi ký tự Các luồng ký tự đọc phổ biến FileReader – đọc file văn bản BufferedReader – đọc có bộ đệm StringReader – đọc chuỗi CharArrayReader – đọc mảng ký tự Các luồng ký tự ghi phổ biến FileWriter – ghi vào file văn bản BufferedWriter – ghi có bộ đệm PrintWriter – ghi dữ liệu dạng dễ đọc StringWriter – ghi chuỗi Luồng lọc dữ liệu (Filtered Streams) Luồng lọc dùng để chuyển đổi dữ liệu từ dạng byte/ký tự sang các kiểu dữ liệu khác.\nCác luồng lọc phổ biến DataInputStream DataOutputStream Cho phép đọc/ghi các kiểu dữ liệu nguyên thủy:\nint float double boolean char Đây là cầu nối giữa luồng thô và dữ liệu có kiểu trong Java.\nLưu trạng thái đối tượng – Serialization Serialization là gì? Serialization (chuỗi hóa) là quá trình chuyển đối tượng Java thành luồng byte để:\nLưu vào file Truyền qua mạng Phục hồi lại sau này Deserialization Ngược lại, Deserialization (giải chuỗi) là quá trình:\nĐọc byte Tái tạo lại đối tượng ban đầu Đây là nền tảng cho:\nLưu dữ liệu chương trình Java RMI Truyền object qua mạng Try-with-resources (TWR) Java hỗ trợ Try-with-resources để:\nTự động đóng stream Tránh rò rỉ tài nguyên Code gọn và an toàn hơn So với try-catch truyền thống, TWR:\nÍt lỗi hơn Dễ bảo trì hơn Được khuyến khích sử dụng Các lỗi I/O thường gặp Khi làm việc với luồng, một số exception phổ biến là:\nFileNotFoundException IOException EOFException UnsupportedEncodingException FileAlreadyExistsException AccessDeniedException SocketException MalformedURLException SerializationException InvalidPathException Việc bắt và xử lý exception đúng cách là yêu cầu bắt buộc trong lập trình Java.\nLiên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), luồng nhập xuất được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Truyền dữ liệu Client – Server Java RMI Multicast UDP Không hiểu I/O Stream → không thể làm mạng đúng cách.\nKết luận Qua bài học này, ta đã:\nHiểu khái niệm luồng nhập xuất trong Java Phân biệt luồng byte và luồng ký tự Nắm được cách đọc/ghi dữ liệu với Stream Biết vai trò của Serialization và Filtered Streams Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo Khi xử lý các tác vụ mạng (như gọi API), người mới học JS hay viết code lồng nhau kiểu này:\n1 2 3 4 5 6 7 8 9 10 // Cực hình Callback Hell getData(function(a) { getMoreData(a, function(b) { getMoreData(b, function(c) { getMoreData(c, function(d) { console.log(d); }); }); }); }); ","permalink":"http://localhost:1313/blog/bai-viet-3/","summary":"Tổng quan về Input/Output Streams trong Java – nền tảng cho xử lý file, console và lập trình mạng.","title":"Bài 3: Quản lý luồng nhập xuất trong Java"},{"content":"Trong lập trình mạng, trước khi chương trình có thể gửi hoặc nhận dữ liệu, điều quan trọng nhất là xác định đúng địa chỉ kết nối mạng. Nếu xác định sai địa chỉ, chương trình sẽ không thể giao tiếp, dù phần xử lý dữ liệu có đúng đến đâu.\nBài học này giúp bạn hiểu cách Java làm việc với địa chỉ IP, tên miền (DNS) và URL. Đây là nền tảng bắt buộc trước khi đi vào Socket TCP, UDP, Web Crawler và Java RMI.\nĐịa chỉ kết nối mạng là gì? Địa chỉ kết nối mạng là thông tin dùng để xác định máy nào trong mạng cần giao tiếp và dịch vụ nào trên máy đó sẽ xử lý dữ liệu.\nTrong Internet, địa chỉ kết nối thường bao gồm:\nĐịa chỉ IP Tên miền (Domain Name) Cổng (Port) Giao thức (Protocol) DNS – Domain Name System Hình 4.1 – Mô hình hoạt động của DNS (Domain Name System)\nClient gửi yêu cầu phân giải tên miền đến DNS Server, DNS trả về địa chỉ IP tương ứng để client kết nối đến server đích.*\nCon người dễ nhớ tên miền hơn các dãy số IP.\nDNS (Domain Name System) có nhiệm vụ ánh xạ tên miền sang địa chỉ IP, giúp client tìm đúng server cần kết nối.\nVí dụ:\ngoogle.com tương ứng với nhiều địa chỉ IP khác nhau www.cs.yale.edu tương ứng với 128.36.229.30 Nhờ DNS, người dùng không cần ghi nhớ địa chỉ IP khi truy cập Internet. Địa chỉ IPv4 IPv4 là dạng địa chỉ phổ biến, gồm 32 bit, thường được viết thành bốn nhóm số.\nVí dụ:\n192.168.1.1 8.8.8.8 Một số dải địa chỉ đặc biệt:\n127.x.x.x là loopback (localhost) 224.0.0.0 – 239.255.255.255 là multicast Lớp InetAddress trong Java Java cung cấp lớp InetAddress để làm việc với địa chỉ IP và DNS.\nLớp này thường được dùng để:\nPhân giải tên miền sang IP Kiểm tra loại địa chỉ Kiểm tra khả năng kết nối mạng Ví dụ minh họa:\n1 InetAddress address = InetAddress.getByName(\u0026#34;google.com\u0026#34;); URL – Uniform Resource Locator URL được dùng để xác định tài nguyên trên Internet như trang web, file hoặc dịch vụ.\nMột URL đầy đủ thường bao gồm các thành phần sau:\nGiao thức (Protocol) Tên miền (Host) Cổng (Port) Đường dẫn (Path) Chuỗi truy vấn (Query) Ví dụ một URL đầy đủ: https://www.hutech.edu.vn/admission?id=123\nURL cho biết lấy dữ liệu ở đâu và bằng cách nào.\nLớp URL trong Java Lớp URL cho phép chương trình Java:\nPhân tích các thành phần của URL Kết nối tới server Đọc dữ liệu từ Internet Ví dụ minh họa:\n1 URL url = new URL(\u0026#34;https://www.example.com\u0026#34;); Ý nghĩa của việc quản lý địa chỉ kết nối mạng Hiểu rõ cách quản lý địa chỉ mạng giúp:\nTránh kết nối sai server Chuẩn bị đúng địa chỉ cho Socket TCP/UDP Hiểu cách Web Crawler hoạt động Nắm vững mô hình Client – Server Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm địa chỉ kết nối mạng Biết vai trò của DNS và IPv4 Nắm được cách Java làm việc với InetAddress Hiểu cấu trúc và vai trò của URL Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-4/","summary":"Tìm hiểu cách Java quản lý địa chỉ mạng thông qua InetAddress, URL, URLConnection và DNS.","title":"Bài 4: Quản lý địa chỉ kết nối mạng trong Java"},{"content":"Trong lập trình mạng, TCP Socket là cơ chế quan trọng nhất để xây dựng các ứng dụng Client – Server có độ tin cậy cao.\nBài học này giúp bạn hiểu TCP là gì, vì sao cần TCP, và cách Java triển khai TCP thông qua Socket và ServerSocket.\nĐây là bước chuyển tiếp trực tiếp từ kiến thức địa chỉ mạng (IP, DNS, URL) sang giao tiếp dữ liệu thực tế giữa các chương trình.\nTCP là gì? TCP (Transmission Control Protocol) là giao thức truyền thông hướng kết nối, đảm bảo dữ liệu được truyền:\nĐúng thứ tự Đầy đủ Không bị mất mát Không bị trùng lặp Trước khi truyền dữ liệu, TCP yêu cầu thiết lập kết nối giữa hai bên, và chỉ khi kết nối thành công thì dữ liệu mới được trao đổi.\nVì sao sử dụng TCP? TCP được sử dụng khi ứng dụng yêu cầu độ tin cậy cao, ví dụ:\nỨng dụng chat Ứng dụng client–server Truyền file Game online theo lượt Hệ thống ngân hàng, thương mại điện tử TCP cung cấp các cơ chế quan trọng:\nĐảm bảo dữ liệu: gói tin bị mất sẽ được gửi lại Kiểm soát lỗi: phát hiện và sửa lỗi trong quá trình truyền Kiểm soát luồng: tránh làm quá tải phía nhận Giao tiếp hai chiều: cho phép gửi và nhận dữ liệu đồng thời Cơ chế hoạt động của TCP Quá trình giao tiếp TCP gồm ba giai đoạn chính:\nThiết lập kết nối (Bắt tay 3 bước – Three-way Handshake) Truyền dữ liệu Giải phóng kết nối Nhờ cơ chế này, TCP đảm bảo rằng hai bên luôn sẵn sàng trước khi truyền và kết thúc an toàn sau khi hoàn tất.\nMô hình Client – Server Các ứng dụng TCP thường hoạt động theo mô hình Client – Server.\nServer:\nChạy trước Lắng nghe yêu cầu kết nối Cung cấp dịch vụ Trả kết quả cho client Client:\nChạy sau Chủ động kết nối tới server Gửi yêu cầu Nhận phản hồi từ server Quá trình giao tiếp gồm:\nClient gửi yêu cầu Server xử lý Server trả kết quả cho client Socket trong Java Trong Java, Socket đại diện cho điểm cuối giao tiếp giữa client và server khi sử dụng TCP.\nSocket cho phép:\nGửi dữ liệu tới server Nhận dữ liệu từ server Giao tiếp hai chiều thông qua luồng nhập/xuất Ví dụ minh họa tạo Socket phía client:\n1 Socket socket = new Socket(\u0026#34;localhost\u0026#34;, 8080); ServerSocket trong Java ServerSocket được sử dụng ở phía server để:\nMở một cổng lắng nghe Chờ client kết nối Chấp nhận kết nối và tạo Socket giao tiếp ServerSocket đóng vai trò như cửa ngõ, cho phép các client kết nối vào server.\nVí dụ minh họa:\n1 ServerSocket server = new ServerSocket(8080); Luồng dữ liệu trong TCP Socket Sau khi kết nối TCP được thiết lập, client và server trao đổi dữ liệu thông qua các luồng:\nInputStream: dùng để đọc dữ liệu từ socket OutputStream: dùng để ghi dữ liệu vào socket Luồng dữ liệu này hoạt động tương tự như I/O Stream đã học ở bài trước,\nnhưng nguồn và đích là mạng thay vì file hay bàn phím.\nVí dụ ứng dụng: Trò chơi Oẳn Tù Tì Một bài tập tiêu biểu sử dụng TCP Socket là trò chơi Oẳn Tù Tì theo mô hình Client – Server.\nĐặc điểm Server quản lý luật chơi và điểm số Hai client gửi lựa chọn (kéo – búa – bao) Server xác định kết quả và gửi lại cho client Dữ liệu được truyền qua TCP để đảm bảo chính xác Thông qua bài tập này, sinh viên hiểu rõ:\nCách thiết lập kết nối TCP Cách trao đổi dữ liệu giữa nhiều client Cách xử lý lỗi mạng và ngoại lệ Ý nghĩa của lập trình TCP Socket Việc nắm vững TCP Socket giúp bạn:\nHiểu bản chất giao tiếp mạng Xây dựng hệ thống Client – Server thực tế Chuẩn bị cho các bài nâng cao như: Đa tuyến (Multi-thread) Socket UDP Java RMI Ứng dụng mạng phân tán Kết luận Qua bài học này, bạn đã:\nHiểu TCP là gì và vì sao cần TCP Nắm được mô hình Client – Server Biết vai trò của Socket và ServerSocket trong Java Hiểu cách dữ liệu được truyền qua TCP Chuẩn bị nền tảng cho các bài học UDP và xử lý đồng thời tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-5/","summary":"Giải thích mô hình Client–Server và cách lập trình Socket TCP trong Java – nền tảng cho giao tiếp mạng tin cậy.","title":"Bài 5: Lập trình Socket TCP trong Java"},{"content":"#Trong lập trình mạng, không phải lúc nào ứng dụng cũng cần độ tin cậy tuyệt đối như TCP.\nTrong nhiều trường hợp, điều quan trọng hơn là tốc độ truyền nhanh và độ trễ thấp.\nBài học này giới thiệu UDP Socket – cơ chế truyền dữ liệu không kết nối, được sử dụng rộng rãi trong các ứng dụng thời gian thực.\nUDP là gì? UDP (User Datagram Protocol) là giao thức truyền thông không hướng kết nối.\nĐiều này có nghĩa là:\nKhông thiết lập kết nối trước khi truyền Không đảm bảo dữ liệu đến nơi Không đảm bảo thứ tự gói tin Không tự động gửi lại gói tin bị mất UDP gửi dữ liệu theo từng datagram (gói tin độc lập).\nSo sánh TCP và UDP TCP UDP Có kết nối Không kết nối Đảm bảo dữ liệu Không đảm bảo Truyền theo luồng Truyền theo gói Độ trễ cao hơn Độ trễ thấp Phù hợp dữ liệu quan trọng Phù hợp dữ liệu thời gian thực Khi nào sử dụng UDP? UDP được sử dụng khi:\nCần truyền nhanh Có thể chấp nhận mất gói tin Dữ liệu được gửi liên tục Ví dụ ứng dụng UDP:\nTruyền video, audio trực tuyến Game online thời gian thực Chat broadcast DNS Multicast, streaming UDP Socket trong Java Java hỗ trợ UDP thông qua hai lớp chính:\nDatagramSocket: quản lý socket UDP DatagramPacket: đại diện cho gói dữ liệu UDP UDP không phân biệt client hay server rõ ràng như TCP.\nMỗi chương trình chỉ cần một DatagramSocket để gửi và nhận dữ liệu.\nDatagramPacket là gì? DatagramPacket là gói dữ liệu UDP, bao gồm:\nDữ liệu cần gửi Địa chỉ IP đích Số hiệu cổng Mỗi lần gửi hoặc nhận dữ liệu, UDP làm việc với một DatagramPacket riêng biệt.\nLuồng dữ liệu trong UDP UDP không có luồng InputStream / OutputStream như TCP.\nQuy trình truyền dữ liệu UDP:\nTạo DatagramSocket Tạo DatagramPacket chứa dữ liệu Gửi packet đi Nhận packet về Đọc dữ liệu từ packet Mỗi gói tin là độc lập, không liên quan đến các gói khác.\nĐặc điểm quan trọng của UDP Không kiểm soát lỗi Không kiểm soát luồng Không bắt tay kết nối Gửi nhanh, xử lý đơn giản Phù hợp truyền broadcast và multicast Chính vì vậy, UDP thường được dùng khi tốc độ quan trọng hơn độ chính xác tuyệt đối.\nÝ nghĩa của lập trình Socket UDP Nắm vững UDP giúp bạn:\nHiểu bản chất truyền dữ liệu không kết nối Xây dựng ứng dụng thời gian thực Phân biệt rõ TCP và UDP trong thiết kế hệ thống Chuẩn bị cho các chủ đề nâng cao như: Multicast UDP Java RMI Hệ thống phân tán Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính, UDP được sử dụng trong:\nSocket UDP Multicast Ứng dụng truyền tin nhanh Game, streaming, broadcast Hiểu UDP giúp bạn chọn đúng giao thức cho từng bài toán thực tế.\nKết luận Qua bài học này, bạn đã:\nHiểu UDP là gì và cơ chế hoạt động Phân biệt được TCP và UDP Biết vai trò của DatagramSocket và DatagramPacket Hiểu cách truyền dữ liệu không kết nối Chuẩn bị nền tảng cho bài Multicast UDP \u0026amp; Java RMI tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-6/","summary":"Giải thích giao thức UDP và cách Java lập trình Socket UDP – nền tảng cho truyền dữ liệu nhanh, không kết nối.","title":"Bài 6: Lập trình Socket UDP trong Java"},{"content":"Trong các ứng dụng mạng thực tế, đặc biệt là Server, chương trình thường phải xử lý nhiều yêu cầu cùng lúc.\nNếu chỉ sử dụng một luồng thực thi, server sẽ bị tắc nghẽn, các client phải chờ đợi và hiệu năng giảm nghiêm trọng.\nVì vậy, lập trình đa tuyến (Multithreading) và xử lý đồng thời (Concurrency) là kỹ thuật bắt buộc trong lập trình mạng.\nTuyến (Thread) là gì? Thread là một dòng điều khiển tuần tự bên trong một chương trình.\nMột chương trình (process) có thể chứa nhiều thread Các thread có thể chạy đồng thời Mỗi thread thực hiện một nhiệm vụ riêng Thread không phải là một chương trình độc lập,\nnó luôn thuộc về một process.\nProcess và Thread Process:\nCó không gian bộ nhớ riêng Chạy độc lập với process khác Tạo và chuyển đổi tốn nhiều tài nguyên Thread:\nChia sẻ bộ nhớ với các thread khác trong cùng process Tạo nhanh hơn process Chuyển đổi nhanh hơn Nhờ thread, chương trình có thể thực hiện nhiều công việc cùng lúc trong cùng một ứng dụng.\nVì sao cần lập trình đa tuyến? Lập trình đa tuyến giúp:\nTăng hiệu suất và khả năng đáp ứng Tận dụng thời gian chờ đợi (I/O, mạng, tải file) Chia nhỏ tác vụ và xử lý đồng thời Cải thiện trải nghiệm người dùng Trong lập trình mạng, đa tuyến cho phép server phục vụ nhiều client cùng lúc.\nThực thi Thread trong Java Trong Java, một thread bắt đầu chạy khi gọi phương thức start().\nKhi thread chạy, JVM thực thi mã trong phương thức run() Khi run() kết thúc, thread cũng kết thúc Một thread không thể start lại, muốn chạy lại phải tạo thread mới Thread cần có điều kiện dừng rõ ràng để tránh chạy vô hạn.\nỨng dụng đa tuyến trong lập trình mạng Ứng dụng Chat đa tuyến Một ví dụ tiêu biểu của đa tuyến trong mạng là ứng dụng chat nhiều client – một server.\nĐặc điểm:\nServer chấp nhận nhiều client kết nối cùng lúc Mỗi client được xử lý bởi một thread riêng Tin nhắn từ một client được gửi tới tất cả client khác Server ghi lại nội dung chat vào file log Thông qua ví dụ này, sinh viên hiểu rõ:\nCách server xử lý nhiều kết nối đồng thời Cách phối hợp giữa socket và thread Vai trò của đa tuyến trong ứng dụng mạng Xử lý đồng thời (Concurrency) Xử lý đồng thời xảy ra khi nhiều thread:\nChạy cùng lúc Truy cập tài nguyên chung (biến, file, bộ nhớ) Nếu không kiểm soát tốt, chương trình có thể gặp các vấn đề nghiêm trọng.\nRace Condition Race Condition xảy ra khi:\nNhiều thread cùng truy cập và thay đổi dữ liệu chung Kết quả phụ thuộc vào thứ tự thực thi không xác định Điều này có thể dẫn đến:\nDữ liệu sai lệch Kết quả không nhất quán Lỗi khó phát hiện Đồng bộ hóa (Synchronization) Để tránh race condition, Java cung cấp cơ chế đồng bộ hóa:\nĐảm bảo chỉ một thread được truy cập tài nguyên tại một thời điểm Giữ cho dữ liệu luôn nhất quán Đồng bộ hóa là nền tảng để xây dựng các ứng dụng an toàn và ổn định khi chạy đa tuyến.\nCác vấn đề thường gặp trong xử lý đồng thời Một số vấn đề phổ biến:\nRace condition: tranh chấp dữ liệu Deadlock: các thread chờ nhau vô hạn Livelock: các thread liên tục phản ứng nhưng không tiến triển Starvation: thread không bao giờ được cấp tài nguyên Những vấn đề này khiến lập trình đa tuyến trở nên phức tạp và khó debug.\nLập lịch Thread trong Java Java sử dụng cơ chế lập lịch theo độ ưu tiên:\nMỗi thread có độ ưu tiên từ MIN_PRIORITY đến MAX_PRIORITY JVM chọn thread runnable có độ ưu tiên cao hơn để chạy Thread có thể nhường CPU cho thread khác bằng cách gọi yield() Việc hiểu cơ chế lập lịch giúp lập trình viên thiết kế thread hợp lý hơn.\nÝ nghĩa của lập trình đa tuyến và xử lý đồng thời Nắm vững kiến thức bài này giúp bạn:\nXây dựng server xử lý nhiều client Viết ứng dụng mạng hiệu năng cao Tránh lỗi tranh chấp dữ liệu Chuẩn bị cho các chủ đề nâng cao như: Server đa tuyến Pooling Threads Multicast UDP Java RMI Hệ thống phân tán Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm thread và multithreading Phân biệt process và thread Biết vai trò của đa tuyến trong lập trình mạng Hiểu các vấn đề xử lý đồng thời và race condition Chuẩn bị nền tảng cho các bài học nâng cao tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-7/","summary":"Giải thích lập trình đa tuyến và xử lý đồng thời trong Java – nền tảng cho các ứng dụng mạng nhiều client và hệ thống phân tán.","title":"Bài 7: Lập trình đa tuyến và xử lý đồng thời trong Java"},{"content":"Buổi 8 gồm 2 phần lớn:\nMulticast UDP: gửi dữ liệu từ một nguồn đến nhiều máy nhận cùng lúc (1 → N). Java RMI: gọi phương thức từ xa giữa các ứng dụng Java như gọi hàm bình thường (Remote Method Invocation). Đây là các kỹ thuật thường gặp trong streaming, trò chuyện nhóm, giám sát từ xa và hệ thống phân tán.\n1) UDP Multicast Unicast, Broadcast và Multicast Trong mạng máy tính có 3 kiểu gửi dữ liệu phổ biến:\nUnicast: 1 nguồn → 1 đích\nVí dụ: bạn mở một trang web, server trả dữ liệu cho riêng bạn.\nBroadcast: 1 nguồn → tất cả máy trong mạng nội bộ\nVí dụ: một thông báo phát cho toàn bộ LAN.\nMulticast: 1 nguồn → một nhóm máy đã đăng ký nhận dữ liệu\nVí dụ: server phát stream video cho nhóm người xem cùng lúc.\nMulticast là cách truyền hiệu quả khi nhiều máy cùng cần nhận một nội dung giống nhau.\nTại sao dùng UDP Multicast? UDP Multicast thường được dùng vì:\nHiệu suất cao: gửi 1 lần nhưng nhiều máy nhận → giảm tải mạng và server. Đơn giản, nhanh: UDP là kiểu “gửi và quên”, không phải chờ xác nhận. Tối ưu trong LAN: phù hợp môi trường mạng nội bộ (Local Area Network). Rất hợp streaming: audio/video cần tốc độ và độ trễ thấp hơn là đảm bảo tuyệt đối. Ứng dụng của Multicast Multicast có thể dùng trong:\nTruyền phát multimedia trực tiếp (audio/video streaming) Trò chuyện nhóm, hội thoại nhóm Quảng bá thông tin cấu hình mạng và cập nhật trong hệ thống mạng Game nhiều người chơi (gửi trạng thái game cho nhiều người) Phát thông tin trạng thái/cảnh báo cho nhiều thiết bị Phát tán cập nhật phần mềm trong mạng nội bộ Địa chỉ Multicast IPv4 Trong IPv4:\nClass D là dải địa chỉ dành cho multicast Dải địa chỉ multicast thường gặp: 224.0.0.0 – 239.255.255.255 Một số nhóm multicast hay được nhắc:\n224.0.0.1: tất cả host trong local subnet Multicast Group là gì? Multicast hoạt động theo “nhóm”:\nMột multicast group giống như một kênh. Máy nào muốn nhận dữ liệu phải tham gia nhóm (join group). Khi rời nhóm thì không nhận dữ liệu nữa. Multicast trong Java Java hỗ trợ multicast qua lớp:\njava.net.MulticastSocket (kế thừa từ DatagramSocket) Một số thao tác quan trọng:\njoinGroup(...): tham gia nhóm multicast leaveGroup(...): rời nhóm multicast setTimeToLive(ttl): đặt TTL (thời gian sống của gói tin, qua bao nhiêu router) Quy trình gửi dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket Tham gia nhóm multicast Tạo DatagramPacket chứa dữ liệu + địa chỉ nhóm + port Gửi packet Rời nhóm Ví dụ minh họa (ngắn, chỉ để hiểu):\n1 2 3 4 5 6 7 8 9 10 11 12 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(); socket.joinGroup(group); socket.setTimeToLive(5); byte[] data = \u0026#34;Hello Multicast\u0026#34;.getBytes(); DatagramPacket packet = new DatagramPacket(data, data.length, group, 9876); socket.send(packet); socket.leaveGroup(group); socket.close(); Quy trình nhận dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket lắng nghe trên port Tham gia nhóm multicast Tạo DatagramPacket rỗng để nhận dữ liệu Gọi receive() để chờ gói tin gửi về Đọc dữ liệu từ packet Rời nhóm và đóng socket Ví dụ minh họa (ngắn):\n1 2 3 4 5 6 7 8 9 10 11 12 13 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(9876); socket.joinGroup(group); byte[] buf = new byte[1024]; DatagramPacket packet = new DatagramPacket(buf, buf.length); socket.receive(packet); String msg = new String(packet.getData(), 0, packet.getLength()); System.out.println(\u0026#34;Received: \u0026#34; + msg); socket.leaveGroup(group); socket.close(); 2) Java RMI Java RMI là gì? RMI (Remote Method Invocation) cho phép chương trình Java:\nGọi phương thức của một đối tượng nằm trên máy khác Cảm giác giống như gọi method trong cùng chương trình Nói đơn giản:\nClient gọi: remoteObject.sum(1,2) Server thực thi thật và trả kết quả về cho client RMI giúp che giấu toàn bộ chi tiết mạng phía sau, người lập trình chỉ tập trung vào logic.\nVì sao dùng Java RMI? Java RMI được sử dụng vì:\nTích hợp sẵn trong Java, dễ triển khai nếu cả client và server đều dùng Java Gọi phương thức từ xa đơn giản như gọi hàm thông thường Hỗ trợ dữ liệu phức tạp: đối tượng, mảng, class tự định nghĩa Tự động xử lý giao tiếp mạng thông qua cơ chế stub / skeleton Dựa trên TCP/IP nên tương đối ổn định và tin cậy Hạn chế của Java RMI Một số điểm hạn chế cần lưu ý:\nPhụ thuộc Java: chủ yếu phù hợp Java ↔ Java Thiết kế dịch vụ phức tạp vẫn cần tổ chức tốt (đặc biệt khi dùng callback) Quản lý phiên và kết nối không mạnh như các giải pháp hiện đại Bảo mật cần cấu hình cẩn thận trong môi trường thực tế Ý tưởng kiến trúc RMI (hiểu nhanh) Trong Java RMI có các thành phần chính:\nRemote Interface\nKhai báo các phương thức cho phép gọi từ xa\nServer Implementation\nLớp cài đặt interface, chứa logic xử lý thật\nRMI Registry\nNơi đăng ký service để client tìm thấy server\nClient\nTìm (lookup) service trong registry và gọi phương thức\nCác bước triển khai RMI (tóm tắt) Định nghĩa Remote Interface Cài đặt interface bằng một class server (remote object) Viết chương trình server: tạo object và bind vào registry Viết chương trình client: lookup registry và gọi method Chạy RMI registry, chạy server, sau đó chạy client Ví dụ ứng dụng RMI Một số ví dụ thường gặp:\nTính tổng 2 số từ xa Dịch vụ quản lý tài khoản ATM Dịch vụ giám sát nhiệt độ có callback (server gọi ngược lại client) Bài tập gợi ý theo đúng nội dung buổi 8 BT8.01: Mô phỏng streaming video\n(1 server phát, nhiều client nhận dữ liệu)\nBT8.02: Server quản lý tài khoản ATM bằng RMI\n(thêm user, đăng nhập, gửi/rút tiền, lưu lịch sử giao dịch)\nKết luận Qua bài học này, bạn đã:\nHiểu sự khác nhau giữa Unicast, Broadcast và Multicast Nắm được vì sao Multicast UDP phù hợp cho truyền dữ liệu nhóm và streaming Biết cách Java hỗ trợ multicast qua MulticastSocket Hiểu Java RMI và cơ chế gọi phương thức từ xa Chuẩn bị nền tảng cho các bài ứng dụng mạng phân tán và đồ án học phần ","permalink":"http://localhost:1313/blog/bai-viet-8/","summary":"Giải thích Multicast UDP (gửi 1-n) và Java RMI (gọi phương thức từ xa) – nền tảng cho ứng dụng nhóm và hệ phân tán.","title":"Bài 8: Multicast UDP và Java RMI"},{"content":"Sau khi hoàn thành các bài về TCP, UDP, đa tuyến và xử lý đồng thời,\nchúng ta đã có đủ nền tảng để xây dựng một ứng dụng mạng hoàn chỉnh.\nBài học này giúp bạn xâu chuỗi toàn bộ kiến thức đã học,\nhiểu rõ mỗi công nghệ dùng trong trường hợp nào,\nvà cách thiết kế một hệ thống mạng đúng tư duy kỹ sư.\nNhìn lại các mô hình giao tiếp mạng đã học Trong lập trình mạng, các ứng dụng thường được xây dựng dựa trên mô hình Client – Server.\nClient: gửi yêu cầu, nhập dữ liệu, hiển thị kết quả Server: xử lý logic, quản lý dữ liệu, trả kết quả Tùy bài toán, ta lựa chọn giao thức và mô hình phù hợp.\nSo sánh TCP, UDP và Multicast TCP – Giao tiếp tin cậy TCP phù hợp khi:\nCần đảm bảo dữ liệu đúng và đủ Cần kết nối ổn định, hai chiều Ví dụ: chat, truyền file, game theo lượt, hệ thống ngân hàng Đặc trưng:\nCó bắt tay 3 bước Có kiểm soát lỗi, kiểm soát luồng Tốn tài nguyên hơn UDP UDP – Giao tiếp nhanh, không kết nối UDP phù hợp khi:\nƯu tiên tốc độ Chấp nhận mất gói Ví dụ: game thời gian thực, streaming, cảm biến Đặc trưng:\nKhông kết nối Không đảm bảo thứ tự Ít độ trễ UDP Multicast – Truyền dữ liệu nhóm Multicast được dùng khi:\nMột nguồn → nhiều người nhận Dữ liệu giống nhau cho tất cả client Ví dụ: livestream, thông báo hệ thống, truyền trạng thái Ưu điểm:\nGiảm tải server Tiết kiệm băng thông Phù hợp mạng LAN Vai trò của đa tuyến (Multithreading) Trong thực tế, server không thể xử lý từng client một cách tuần tự.\nĐa tuyến giúp:\nNhiều client kết nối cùng lúc Không client nào bị “đóng băng” Tăng khả năng mở rộng hệ thống Ví dụ:\nServer chat: mỗi client là một thread Server TCP: mỗi socket được xử lý riêng Thiết kế một ứng dụng mạng hoàn chỉnh Khi thiết kế, cần xác định rõ:\nGiao thức: TCP hay UDP? Mô hình: 1–1, 1–n, n–n? Đồng thời hay tuần tự? Client gửi gì? Server xử lý gì? Một thiết kế tốt luôn:\nPhân tách rõ giao tiếp – xử lý – dữ liệu Dễ mở rộng Dễ bảo trì Liên hệ với đồ án học phần Các đồ án như:\nChat đa tuyến Oẳn Tù Tì client–server Streaming UDP Dịch vụ RMI Đều là sự kết hợp của các kiến thức đã học,\nkhông phải nội dung mới.\nKết luận Qua bài học này, bạn đã:\nHệ thống lại toàn bộ kiến thức lập trình mạng Hiểu rõ khi nào dùng TCP, UDP, Multicast Nắm được vai trò của đa tuyến Biết cách tư duy thiết kế một ứng dụng mạng hoàn chỉnh Đây là bước chuẩn bị quan trọng trước khi vận dụng toàn bộ kiến thức vào một hệ thống thực tế.\n","permalink":"http://localhost:1313/blog/bai-viet-9/","summary":"Tổng hợp kiến thức TCP, UDP, đa tuyến và cách thiết kế ứng dụng mạng Client–Server hoàn chỉnh.","title":"Bài 9: Tổng hợp kiến thức \u0026 thiết kế ứng dụng mạng"},{"content":"Bài cuối cùng của học phần không nhằm giới thiệu công nghệ mới,\nmà tập trung vào cách vận dụng kiến thức đã học vào thực tế.\nĐây là giai đoạn chuyển từ:\n“Biết dùng” → “Biết thiết kế” → “Biết đánh giá hệ thống”\nTư duy vận dụng kiến thức Một ứng dụng mạng hoàn chỉnh cần trả lời được các câu hỏi:\nVì sao chọn TCP mà không phải UDP? Vì sao cần đa tuyến? Server có chịu được nhiều client không? Hệ thống có mở rộng được không? Đây chính là tư duy kỹ sư, không phải chỉ “chạy được là xong”.\nĐánh giá một ứng dụng mạng Khi hoàn thiện hệ thống, cần xem xét:\n1. Tính đúng đắn Dữ liệu có truyền đúng không? Có mất gói không? Có xử lý lỗi không? 2. Tính đồng thời Nhiều client có dùng chung được không? Có bị treo server không? Có race condition không? 3. Hiệu năng Độ trễ thế nào? Server có bị quá tải không? Có tách luồng hợp lý không? Liên hệ với các mô hình phân tán Các hệ thống đã học là nền tảng cho:\nHệ thống client–server lớn Ứng dụng phân tán Microservices Cloud services Java RMI, TCP đa tuyến hay UDP Multicast\nđều là những viên gạch đầu tiên.\nTừ học phần đến thực tế Sau học phần này, bạn có thể tiếp cận:\nWebSocket REST API gRPC Message Queue (Kafka, RabbitMQ) Hệ thống realtime Tư duy lập trình mạng không thay đổi, chỉ công nghệ thay đổi.\nTổng kết toàn bộ học phần Qua toàn bộ chuỗi bài, bạn đã:\nHiểu cách dữ liệu đi qua mạng Làm việc với TCP, UDP, Multicast Xử lý đa tuyến và đồng thời Tiếp cận lập trình phân tán với RMI Có tư duy thiết kế hệ thống mạng Lời kết Lập trình mạng không chỉ là code socket,\nmà là hiểu cách các hệ thống nói chuyện với nhau.\nNếu bạn hiểu được điều đó,\nbạn đã vượt xa mức “học để qua môn”.\n","permalink":"http://localhost:1313/blog/bai-viet-10/","summary":"Vận dụng toàn bộ kiến thức lập trình mạng để xây dựng, đánh giá và hoàn thiện một ứng dụng thực tế.","title":"Bài 10: Hoàn thiện \u0026 vận dụng lập trình mạng"},{"content":"Lời mở đầu Có những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\nMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\nHọc tập Những năm đại học trôi qua nhanh hơn mình từng nghĩ. Ngày mới bước chân vào giảng đường, mình vẫn còn khá mơ hồ về ngành học, về tương lai, về chính bản thân mình sẽ trở thành ai sau bốn năm. Nhưng rồi từng môn học, từng bài tập nhóm, từng đồ án kéo mình lại gần hơn với cách một hệ thống được hình thành và vận hành.\nHệ thống thông tin không chỉ là lập trình, cũng không đơn thuần là công nghệ. Đó là câu chuyện về con người, quy trình và dữ liệu. Mình học cách đặt câu hỏi, học cách lắng nghe yêu cầu, học cách vẽ ra những sơ đồ tưởng chừng khô khan nhưng lại chứa rất nhiều suy nghĩ phía sau. Dần dần, mình nhận ra mình thích phần “hiểu vấn đề” hơn là chỉ chăm chăm vào lời giải.\nĐịnh hướng Ở thời điểm hiện tại, mình đang định hướng theo con đường Business Analyst (BA). Mình hứng thú với vai trò đứng giữa – không quá xa kỹ thuật, cũng không tách rời nghiệp vụ. Đó là nơi cần sự rõ ràng trong tư duy, sự kiên nhẫn trong giao tiếp và khả năng chuyển hóa những điều mơ hồ thành thứ có thể triển khai được.\nMình không nghĩ BA là một vị trí “nhẹ nhàng” hay “an toàn”. Ngược lại, đó là công việc đòi hỏi phải học rất nhiều, sai rất nhiều và sửa rất nhiều. Nhưng chính điều đó khiến mình thấy phù hợp. Mình muốn hiểu hệ thống trước khi xây dựng nó, muốn biết vì sao người ta see cần một chức năng, chứ không chỉ là nó được viết như thế nào.\nBlog Blog này ra đời khá tự nhiên, giống như một cuốn sổ mở rộng hơn là một trang thể hiện điều gì đó to tát. Mình viết để nhớ, để hệ thống lại những gì đã học, và đôi khi là để sắp xếp lại suy nghĩ của chính mình.\nỞ đây có thể là kiến thức về Hệ thống thông tin, về phân tích nghiệp vụ, về lập trình, hoặc đơn giản là những trải nghiệm học tập và va chạm trong quá trình làm đồ án, làm việc nhóm, và chuẩn bị bước ra môi trường thực tế. Mình không mong mọi thứ phải hoàn hảo, chỉ mong nó thật và có ích cho ai đó đang đi trên con đường tương tự.\nLời kết Mình đang ở một giai đoạn chưa thể gọi là trưởng thành, nhưng cũng không còn quá non nớt. Vẫn đang học, vẫn đang thử, vẫn đang sai và sửa mỗi ngày. Nếu có một điều mình mong giữ được lâu nhất, thì đó là sự tò mò và tinh thần học hỏi – những thứ giúp mình không đứng yên giữa rất nhiều lựa chọn ngoài kia.\nCảm ơn bạn đã ghé qua và đọc những dòng này. Hy vọng ở một thời điểm nào đó, những chia sẻ nhỏ ở đây sẽ chạm đến bạn – dù chỉ là một chút. \u0026ldquo;Học để chia sẻ, chia sẻ để học nhiều hơn.\u0026rdquo;\nLiên hệ Nếu bạn muốn gửi cho mình vài dòng trao đổi,\nbạn có thể liên hệ với mình qua Email hoặc GitHub ,Facebook dưới đây.\nCảm ơn bạn đã ghé thăm blog! ","permalink":"http://localhost:1313/about/","summary":"\u003ch2 id=\"lời-mở-đầu\"\u003eLời mở đầu\u003c/h2\u003e\n\u003cp\u003eCó những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\u003c/p\u003e\n\u003cp\u003eMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\u003c/p\u003e","title":"Giới thiệu"},{"content":"Trong lập trình mạng, trước khi kết nối, ta phải biết \u0026ldquo;địa chỉ nhà\u0026rdquo; (IP) của mình và đối phương. Java cung cấp class\nHình 1.1: Hiệu ứng Dunning–Kruger – mức độ tự tin thay đổi theo kinh nghiệm học tập\nGóc nhìn học tập: Hiệu ứng Dunning–Kruger InetAddress để làm việc này.\nĐịa chỉ IP là gì trong lập trình mạng? IP (Internet Protocol Address) là địa chỉ định danh của một thiết bị khi tham gia vào mạng máy tính.\nTrong lập trình mạng, IP đóng vai trò quan trọng trong việc:\nXác định máy gửi và máy nhận Định tuyến dữ liệu trong quá trình truyền thông Thiết lập kết nối giữa các tiến trình chạy trên những máy khác nhau Nếu không có địa chỉ IP, các máy tính sẽ không thể nhận biết và giao tiếp với nhau.\nVai trò của lớp InetAddress trong Java Lớp InetAddress đại diện cho một địa chỉ IP trong Java.\nThông qua lớp này, lập trình viên có thể:\nLấy địa chỉ IP của máy đang chạy chương trình Lấy tên máy (hostname) Phân giải tên miền sang địa chỉ IP Chuẩn bị thông tin để tạo Socket hoặc ServerSocket Hầu hết các chương trình lập trình mạng trong Java đều sử dụng InetAddress ở bước khởi tạo.\nPhân tích ý nghĩa các lệnh trong chương trình InetAddress.getLocalHost()\n→ Trả về đối tượng đại diện cho máy cục bộ (localhost).\ngetHostName()\n→ Lấy tên máy do hệ điều hành hoặc mạng gán.\ngetHostAddress()\n→ Lấy địa chỉ IP của máy dưới dạng chuỗi.\nViệc in ra hostname và IP giúp:\nKiểm tra cấu hình mạng Xác định đúng máy khi kết nối Client – Server Debug lỗi mạng Một số lưu ý khi lấy IP trong Java Khi máy không kết nối mạng, IP có thể là 127.0.0.1 Khi máy có nhiều card mạng (WiFi, LAN, VPN), IP trả về có thể không phải IP Internet Trên Server, hostname và IP thường khác máy cá nhân Ứng dụng thực tế Việc xác định IP của máy thường được sử dụng trong:\nChương trình Client – Server Thông báo IP Server cho Client kết nối Kiểm tra kết nối mạng LAN Ghi log và giám sát hệ thống Kết luận Qua bài học này, ta đã:\nHiểu vai trò của địa chỉ IP trong lập trình mạng Biết cách lấy IP bằng lớp InetAddress Chuẩn bị nền tảng cho các kỹ thuật TCP, UDP và RMI Liên hệ với học phần Lập trình Mạng máy tính Bài học này nằm trong nội dung mở đầu của học phần Lập trình Mạng máy tính (CMP180) tại Trường Đại học Công nghệ TP.HCM (HUTECH).\nTrong lộ trình môn học, sinh viên sẽ lần lượt tiếp cận các nội dung:\nKiến thức nền tảng về mạng và lập trình mạng Quản lý luồng nhập xuất (I/O) Quản lý địa chỉ và kết nối mạng Lập trình Socket TCP và UDP Xử lý đa tuyến, đa luồng Multicast UDP và Java RMI Thực hiện đồ án học phần cá nhân Mục tiêu của bài học Thông qua Bài 1, sinh viên sẽ:\nLàm quen với môi trường lập trình mạng bằng Java Hiểu được vai trò của địa chỉ IP trong giao tiếp mạng Biết cách sử dụng lớp InetAddress để lấy IP và hostname Chuẩn bị nền tảng cho các bài học tiếp theo về Socket và Server – Client ","permalink":"http://localhost:1313/blog/bai-viet-1/","summary":"GIỚI THIỆU HỌC PHẦN.","title":"Bài 1: Tổng quan khoá học"},{"content":"Trong lập trình mạng, nếu IP được xem như địa chỉ nhà của một máy tính trong mạng,\nthì Port (cổng) chính là số hiệu dùng để xác định chương trình hoặc dịch vụ cụ thể đang chạy trên máy đó.\nMột máy tính có thể chạy đồng thời nhiều ứng dụng mạng như Web Server, Database Server, Game Server hoặc Chat Server.\nMỗi ứng dụng bắt buộc phải gắn với một Port riêng để hệ điều hành có thể phân biệt và định tuyến dữ liệu chính xác.\nPort nằm ở đâu trong mô hình TCP/IP? Trong bộ giao thức TCP/IP, Port thuộc về Transport Layer (Tầng giao vận) và được sử dụng bởi hai giao thức chính là TCP và UDP.\nĐịa chỉ IP xác định máy nào sẽ nhận dữ liệu Port xác định ứng dụng nào trên máy đó sẽ xử lý dữ liệu Sự kết hợp giữa IP + Port tạo thành một Socket, là điểm cuối (endpoint) của quá trình giao tiếp mạng.\nCác loại Port phổ biến Port được đánh số từ 0 đến 65535 và được chia thành ba nhóm chính:\nInternet và các End Devices Trước khi tìm hiểu về Port, cần hiểu Internet được cấu thành từ hàng tỷ thiết bị đầu cuối (End Devices) như máy tính, điện thoại, máy chủ và các thiết bị IoT.\nCác thiết bị này kết nối với nhau thông qua nhiều lớp mạng khác nhau, và mỗi thiết bị khi tham gia giao tiếp mạng đều cần có địa chỉ IP và Port để định danh. Hình 2.1: Sơ đồ minh họa Internet và các thiết bị đầu cuối (End Devices) kết nối thông qua các mạng truy cập và mạng lõi.\nTrong quá trình giao tiếp mạng, một thiết bị không chỉ cần địa chỉ IP để xác định vị trí trong mạng, mà còn cần Port để xác định chính xác ứng dụng hoặc dịch vụ đang lắng nghe trên thiết bị đó.\nDo đó, Port đóng vai trò như “điểm tiếp nhận” (endpoint) cho các tiến trình mạng chạy trên cùng một máy.\nMô hình các tầng giao thức TCP/IP Để hiểu rõ Port hoạt động ở đâu và vì sao Server cần Port, ta cần nắm được mô hình giao thức TCP/IP – nền tảng của mọi ứng dụng mạng hiện nay.\nHình 2.2: Mô hình các tầng giao thức TCP/IP và các giao thức tiêu biểu tương ứng với từng tầng.\nTrong mô hình TCP/IP, địa chỉ IP hoạt động ở tầng Internet, giúp xác định thiết bị trong mạng.\nTrong khi đó, Port hoạt động ở tầng Transport (TCP/UDP), giúp xác định chính xác ứng dụng hoặc dịch vụ đang giao tiếp trên thiết bị đó.\nWell-known Ports (0 – 1023) Được dùng cho các dịch vụ chuẩn:\nPort 80: HTTP Port 443: HTTPS Port 21: FTP Port 25: SMTP Registered Ports (1024 – 49151) Thường dùng cho các ứng dụng phổ biến:\nPort 3306: MySQL Port 8080: Web Server thay thế port 80 Dynamic / Private Ports (49152 – 65535) Do hệ điều hành cấp phát tạm thời cho Client khi giao tiếp mạng.\nVì sao Server thường dùng cổng 8080? Cổng 8080 rất phổ biến trong quá trình phát triển và học tập vì:\nTránh xung đột với cổng 80 đang được hệ điều hành chiếm dụng Không cần quyền Administrator khi mở Server Phù hợp cho các Web Server thử nghiệm như: Apache Tomcat Spring Boot Node.js Lỗi thường gặp: “Address already in use” Lỗi này xảy ra khi Server cố gắng mở một Port đã bị chương trình khác chiếm dụng.\nNguyên nhân phổ biến:\nServer cũ chưa được tắt Port đang được dùng bởi dịch vụ khác Chạy nhiều Server cùng lúc Cách khắc phục:\nĐổi sang Port khác (ví dụ: 8080 → 9090) Kiểm tra Port đang sử dụng trong hệ điều hành Đảm bảo chỉ có một Server chạy tại một thời điểm Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), khái niệm Port sẽ được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Xây dựng mô hình Client – Server Java RMI và Multicast Việc hiểu rõ Port là nền tảng bắt buộc trước khi triển khai các ứng dụng mạng thực tế.\nKết luận Qua bài học này, ta đã:\nHiểu được Port là gì và vai trò của Port trong lập trình mạng Nắm được mối quan hệ giữa IP, Port và Socket Giải thích được lý do Server thường sử dụng cổng 8080 Chuẩn bị kiến thức nền cho các bài học tiếp theo về TCP và UDP ","permalink":"http://localhost:1313/blog/bai-viet-2/","summary":"MẠNG MÁY TÍNH \u0026amp; INTERNET.","title":"Bài 2: Kiến thức nền tảng?"},{"content":"Trong lập trình Java, luồng nhập xuất (Input / Output Streams) đóng vai trò trung gian giúp chương trình đọc và ghi dữ liệu từ nhiều nguồn khác nhau như bàn phím, file, console, bộ nhớ và sau này là socket mạng.\nHiểu rõ cơ chế luồng nhập xuất là bước nền bắt buộc trước khi đi vào lập trình Socket TCP, UDP hay Java RMI.\nLuồng (Stream) là gì? Luồng (Stream) là dòng dữ liệu di chuyển\ntừ nguồn → chương trình hoặc từ chương trình → đích.\nKhi Java đọc hoặc ghi dữ liệu, dữ liệu không đi trực tiếp mà luôn được đóng gói và truyền qua luồng.\nLuồng nhập xuất là gì? Luồng nhập xuất là cơ chế cho phép chương trình:\nNhận dữ liệu từ bên ngoài (Input) Ghi dữ liệu ra bên ngoài (Output) Luồng có thể kết nối với nhiều nguồn và đích khác nhau:\nFile Bàn phím Màn hình (console) Bộ nhớ Kết nối mạng (TCP / UDP) Dữ liệu trong luồng tồn tại dưới những dạng nào? Trong Java, dữ liệu trong luồng tồn tại dưới hai dạng chính:\nLuồng byte Luồng ký tự Việc chọn đúng loại luồng ảnh hưởng trực tiếp đến hiệu năng và tính chính xác của chương trình.\nLuồng byte trong Java Đặc điểm Dữ liệu được xử lý dưới dạng nhị phân Phù hợp với: File nhị phân Ảnh, video Socket mạng Dữ liệu phức tạp Các lớp gốc InputStream – luồng đọc byte OutputStream – luồng ghi byte Cả hai đều là lớp trừu tượng (abstract).\nCác luồng byte đọc phổ biến FileInputStream – đọc byte từ file ByteArrayInputStream – đọc từ mảng byte PipedInputStream – đọc từ luồng pipe Các luồng byte ghi phổ biến FileOutputStream – ghi byte vào file ByteArrayOutputStream – ghi vào mảng byte PipedOutputStream – ghi vào luồng pipe Mô hình đọc/ghi dữ liệu với Stream Quy trình chung khi làm việc với luồng:\nTạo đối tượng Stream Gắn Stream với nguồn hoặc đích Đọc/ghi dữ liệu trong vòng lặp Đóng Stream sau khi hoàn tất Luồng ký tự trong Java Đặc điểm Xử lý dữ liệu dạng Unicode Phù hợp với: File văn bản Chuỗi Dữ liệu hiển thị cho người dùng Các lớp gốc Reader – luồng đọc ký tự Writer – luồng ghi ký tự Các luồng ký tự đọc phổ biến FileReader – đọc file văn bản BufferedReader – đọc có bộ đệm StringReader – đọc chuỗi CharArrayReader – đọc mảng ký tự Các luồng ký tự ghi phổ biến FileWriter – ghi vào file văn bản BufferedWriter – ghi có bộ đệm PrintWriter – ghi dữ liệu dạng dễ đọc StringWriter – ghi chuỗi Luồng lọc dữ liệu (Filtered Streams) Luồng lọc dùng để chuyển đổi dữ liệu từ dạng byte/ký tự sang các kiểu dữ liệu khác.\nCác luồng lọc phổ biến DataInputStream DataOutputStream Cho phép đọc/ghi các kiểu dữ liệu nguyên thủy:\nint float double boolean char Đây là cầu nối giữa luồng thô và dữ liệu có kiểu trong Java.\nLưu trạng thái đối tượng – Serialization Serialization là gì? Serialization (chuỗi hóa) là quá trình chuyển đối tượng Java thành luồng byte để:\nLưu vào file Truyền qua mạng Phục hồi lại sau này Deserialization Ngược lại, Deserialization (giải chuỗi) là quá trình:\nĐọc byte Tái tạo lại đối tượng ban đầu Đây là nền tảng cho:\nLưu dữ liệu chương trình Java RMI Truyền object qua mạng Try-with-resources (TWR) Java hỗ trợ Try-with-resources để:\nTự động đóng stream Tránh rò rỉ tài nguyên Code gọn và an toàn hơn So với try-catch truyền thống, TWR:\nÍt lỗi hơn Dễ bảo trì hơn Được khuyến khích sử dụng Các lỗi I/O thường gặp Khi làm việc với luồng, một số exception phổ biến là:\nFileNotFoundException IOException EOFException UnsupportedEncodingException FileAlreadyExistsException AccessDeniedException SocketException MalformedURLException SerializationException InvalidPathException Việc bắt và xử lý exception đúng cách là yêu cầu bắt buộc trong lập trình Java.\nLiên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), luồng nhập xuất được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Truyền dữ liệu Client – Server Java RMI Multicast UDP Không hiểu I/O Stream → không thể làm mạng đúng cách.\nKết luận Qua bài học này, ta đã:\nHiểu khái niệm luồng nhập xuất trong Java Phân biệt luồng byte và luồng ký tự Nắm được cách đọc/ghi dữ liệu với Stream Biết vai trò của Serialization và Filtered Streams Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo Khi xử lý các tác vụ mạng (như gọi API), người mới học JS hay viết code lồng nhau kiểu này:\n1 2 3 4 5 6 7 8 9 10 // Cực hình Callback Hell getData(function(a) { getMoreData(a, function(b) { getMoreData(b, function(c) { getMoreData(c, function(d) { console.log(d); }); }); }); }); ","permalink":"http://localhost:1313/blog/bai-viet-3/","summary":"Tổng quan về Input/Output Streams trong Java – nền tảng cho xử lý file, console và lập trình mạng.","title":"Bài 3: Quản lý luồng nhập xuất trong Java"},{"content":"Trong lập trình mạng, trước khi chương trình có thể gửi hoặc nhận dữ liệu, điều quan trọng nhất là xác định đúng địa chỉ kết nối mạng. Nếu xác định sai địa chỉ, chương trình sẽ không thể giao tiếp, dù phần xử lý dữ liệu có đúng đến đâu.\nBài học này giúp bạn hiểu cách Java làm việc với địa chỉ IP, tên miền (DNS) và URL. Đây là nền tảng bắt buộc trước khi đi vào Socket TCP, UDP, Web Crawler và Java RMI.\nĐịa chỉ kết nối mạng là gì? Địa chỉ kết nối mạng là thông tin dùng để xác định máy nào trong mạng cần giao tiếp và dịch vụ nào trên máy đó sẽ xử lý dữ liệu.\nTrong Internet, địa chỉ kết nối thường bao gồm:\nĐịa chỉ IP Tên miền (Domain Name) Cổng (Port) Giao thức (Protocol) DNS – Domain Name System Hình 4.1 – Mô hình hoạt động của DNS (Domain Name System)\nClient gửi yêu cầu phân giải tên miền đến DNS Server, DNS trả về địa chỉ IP tương ứng để client kết nối đến server đích.*\nCon người dễ nhớ tên miền hơn các dãy số IP.\nDNS (Domain Name System) có nhiệm vụ ánh xạ tên miền sang địa chỉ IP, giúp client tìm đúng server cần kết nối.\nVí dụ:\ngoogle.com tương ứng với nhiều địa chỉ IP khác nhau www.cs.yale.edu tương ứng với 128.36.229.30 Nhờ DNS, người dùng không cần ghi nhớ địa chỉ IP khi truy cập Internet. Hình 4.2 minh họa cấu trúc phân cấp của hệ thống DNS, bao gồm Root Domain, các Top-Level Domain (com, edu, org, vn, …) và các tên miền con phía dưới.\nCấu trúc phân cấp này giúp DNS hoạt động hiệu quả và dễ mở rộng trên toàn Internet.\nĐịa chỉ IPv4 IPv4 là dạng địa chỉ phổ biến, gồm 32 bit, thường được viết thành bốn nhóm số.\nVí dụ:\n192.168.1.1 8.8.8.8 Một số dải địa chỉ đặc biệt:\n127.x.x.x là loopback (localhost) 224.0.0.0 – 239.255.255.255 là multicast Lớp InetAddress trong Java Java cung cấp lớp InetAddress để làm việc với địa chỉ IP và DNS.\nLớp này thường được dùng để:\nPhân giải tên miền sang IP Kiểm tra loại địa chỉ Kiểm tra khả năng kết nối mạng Ví dụ minh họa:\n1 InetAddress address = InetAddress.getByName(\u0026#34;google.com\u0026#34;); URL – Uniform Resource Locator URL được dùng để xác định tài nguyên trên Internet như trang web, file hoặc dịch vụ.\nMột URL đầy đủ thường bao gồm các thành phần sau:\nGiao thức (Protocol) Tên miền (Host) Cổng (Port) Đường dẫn (Path) Chuỗi truy vấn (Query) Ví dụ một URL đầy đủ: https://www.hutech.edu.vn/admission?id=123\nURL cho biết lấy dữ liệu ở đâu và bằng cách nào.\nLớp URL trong Java Lớp URL cho phép chương trình Java:\nPhân tích các thành phần của URL Kết nối tới server Đọc dữ liệu từ Internet Ví dụ minh họa:\n1 URL url = new URL(\u0026#34;https://www.example.com\u0026#34;); Ý nghĩa của việc quản lý địa chỉ kết nối mạng Hiểu rõ cách quản lý địa chỉ mạng giúp:\nTránh kết nối sai server Chuẩn bị đúng địa chỉ cho Socket TCP/UDP Hiểu cách Web Crawler hoạt động Nắm vững mô hình Client – Server Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm địa chỉ kết nối mạng Biết vai trò của DNS và IPv4 Nắm được cách Java làm việc với InetAddress Hiểu cấu trúc và vai trò của URL Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-4/","summary":"Tìm hiểu cách Java quản lý địa chỉ mạng thông qua InetAddress, URL, URLConnection và DNS.","title":"Bài 4: Quản lý địa chỉ kết nối mạng trong Java"},{"content":"Trong lập trình mạng, TCP Socket là cơ chế quan trọng nhất để xây dựng các ứng dụng Client – Server có độ tin cậy cao.\nBài học này giúp bạn hiểu TCP là gì, vì sao cần TCP, và cách Java triển khai TCP thông qua Socket và ServerSocket.\nĐây là bước chuyển tiếp trực tiếp từ kiến thức địa chỉ mạng (IP, DNS, URL) sang giao tiếp dữ liệu thực tế giữa các chương trình.\nTCP là gì? TCP (Transmission Control Protocol) là giao thức truyền thông hướng kết nối, đảm bảo dữ liệu được truyền:\nĐúng thứ tự Đầy đủ Không bị mất mát Không bị trùng lặp Trước khi truyền dữ liệu, TCP yêu cầu thiết lập kết nối giữa hai bên, và chỉ khi kết nối thành công thì dữ liệu mới được trao đổi.\nVì sao sử dụng TCP? TCP được sử dụng khi ứng dụng yêu cầu độ tin cậy cao, ví dụ:\nỨng dụng chat Ứng dụng client–server Truyền file Game online theo lượt Hệ thống ngân hàng, thương mại điện tử TCP cung cấp các cơ chế quan trọng:\nĐảm bảo dữ liệu: gói tin bị mất sẽ được gửi lại Kiểm soát lỗi: phát hiện và sửa lỗi trong quá trình truyền Kiểm soát luồng: tránh làm quá tải phía nhận Giao tiếp hai chiều: cho phép gửi và nhận dữ liệu đồng thời Cơ chế hoạt động của TCP Quá trình giao tiếp TCP gồm ba giai đoạn chính:\nThiết lập kết nối (Bắt tay 3 bước – Three-way Handshake) Truyền dữ liệu Giải phóng kết nối Nhờ cơ chế này, TCP đảm bảo rằng hai bên luôn sẵn sàng trước khi truyền và kết thúc an toàn sau khi hoàn tất.\nMô hình Client – Server Các ứng dụng TCP thường hoạt động theo mô hình Client – Server.\nServer:\nChạy trước Lắng nghe yêu cầu kết nối Cung cấp dịch vụ Trả kết quả cho client Client:\nChạy sau Chủ động kết nối tới server Gửi yêu cầu Nhận phản hồi từ server Quá trình giao tiếp gồm:\nClient gửi yêu cầu Server xử lý Server trả kết quả cho client Socket trong Java Trong Java, Socket đại diện cho điểm cuối giao tiếp giữa client và server khi sử dụng TCP.\nSocket cho phép:\nGửi dữ liệu tới server Nhận dữ liệu từ server Giao tiếp hai chiều thông qua luồng nhập/xuất Ví dụ minh họa tạo Socket phía client:\n1 Socket socket = new Socket(\u0026#34;localhost\u0026#34;, 8080); ServerSocket trong Java ServerSocket được sử dụng ở phía server để:\nMở một cổng lắng nghe Chờ client kết nối Chấp nhận kết nối và tạo Socket giao tiếp ServerSocket đóng vai trò như cửa ngõ, cho phép các client kết nối vào server.\nVí dụ minh họa:\n1 ServerSocket server = new ServerSocket(8080); Luồng dữ liệu trong TCP Socket Sau khi kết nối TCP được thiết lập, client và server trao đổi dữ liệu thông qua các luồng:\nInputStream: dùng để đọc dữ liệu từ socket OutputStream: dùng để ghi dữ liệu vào socket Luồng dữ liệu này hoạt động tương tự như I/O Stream đã học ở bài trước,\nnhưng nguồn và đích là mạng thay vì file hay bàn phím.\nVí dụ ứng dụng: Trò chơi Oẳn Tù Tì Một bài tập tiêu biểu sử dụng TCP Socket là trò chơi Oẳn Tù Tì theo mô hình Client – Server.\nĐặc điểm Server quản lý luật chơi và điểm số Hai client gửi lựa chọn (kéo – búa – bao) Server xác định kết quả và gửi lại cho client Dữ liệu được truyền qua TCP để đảm bảo chính xác Thông qua bài tập này, sinh viên hiểu rõ:\nCách thiết lập kết nối TCP Cách trao đổi dữ liệu giữa nhiều client Cách xử lý lỗi mạng và ngoại lệ Ý nghĩa của lập trình TCP Socket Việc nắm vững TCP Socket giúp bạn:\nHiểu bản chất giao tiếp mạng Xây dựng hệ thống Client – Server thực tế Chuẩn bị cho các bài nâng cao như: Đa tuyến (Multi-thread) Socket UDP Java RMI Ứng dụng mạng phân tán Kết luận Qua bài học này, bạn đã:\nHiểu TCP là gì và vì sao cần TCP Nắm được mô hình Client – Server Biết vai trò của Socket và ServerSocket trong Java Hiểu cách dữ liệu được truyền qua TCP Chuẩn bị nền tảng cho các bài học UDP và xử lý đồng thời tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-5/","summary":"Giải thích mô hình Client–Server và cách lập trình Socket TCP trong Java – nền tảng cho giao tiếp mạng tin cậy.","title":"Bài 5: Lập trình Socket TCP trong Java"},{"content":"#Trong lập trình mạng, không phải lúc nào ứng dụng cũng cần độ tin cậy tuyệt đối như TCP.\nTrong nhiều trường hợp, điều quan trọng hơn là tốc độ truyền nhanh và độ trễ thấp.\nBài học này giới thiệu UDP Socket – cơ chế truyền dữ liệu không kết nối, được sử dụng rộng rãi trong các ứng dụng thời gian thực.\nUDP là gì? UDP (User Datagram Protocol) là giao thức truyền thông không hướng kết nối.\nĐiều này có nghĩa là:\nKhông thiết lập kết nối trước khi truyền Không đảm bảo dữ liệu đến nơi Không đảm bảo thứ tự gói tin Không tự động gửi lại gói tin bị mất UDP gửi dữ liệu theo từng datagram (gói tin độc lập).\nSo sánh TCP và UDP TCP UDP Có kết nối Không kết nối Đảm bảo dữ liệu Không đảm bảo Truyền theo luồng Truyền theo gói Độ trễ cao hơn Độ trễ thấp Phù hợp dữ liệu quan trọng Phù hợp dữ liệu thời gian thực Khi nào sử dụng UDP? UDP được sử dụng khi:\nCần truyền nhanh Có thể chấp nhận mất gói tin Dữ liệu được gửi liên tục Ví dụ ứng dụng UDP:\nTruyền video, audio trực tuyến Game online thời gian thực Chat broadcast DNS Multicast, streaming UDP Socket trong Java Java hỗ trợ UDP thông qua hai lớp chính:\nDatagramSocket: quản lý socket UDP DatagramPacket: đại diện cho gói dữ liệu UDP UDP không phân biệt client hay server rõ ràng như TCP.\nMỗi chương trình chỉ cần một DatagramSocket để gửi và nhận dữ liệu.\nDatagramPacket là gì? DatagramPacket là gói dữ liệu UDP, bao gồm:\nDữ liệu cần gửi Địa chỉ IP đích Số hiệu cổng Mỗi lần gửi hoặc nhận dữ liệu, UDP làm việc với một DatagramPacket riêng biệt.\nLuồng dữ liệu trong UDP UDP không có luồng InputStream / OutputStream như TCP.\nQuy trình truyền dữ liệu UDP:\nTạo DatagramSocket Tạo DatagramPacket chứa dữ liệu Gửi packet đi Nhận packet về Đọc dữ liệu từ packet Mỗi gói tin là độc lập, không liên quan đến các gói khác.\nĐặc điểm quan trọng của UDP Không kiểm soát lỗi Không kiểm soát luồng Không bắt tay kết nối Gửi nhanh, xử lý đơn giản Phù hợp truyền broadcast và multicast Chính vì vậy, UDP thường được dùng khi tốc độ quan trọng hơn độ chính xác tuyệt đối.\nÝ nghĩa của lập trình Socket UDP Nắm vững UDP giúp bạn:\nHiểu bản chất truyền dữ liệu không kết nối Xây dựng ứng dụng thời gian thực Phân biệt rõ TCP và UDP trong thiết kế hệ thống Chuẩn bị cho các chủ đề nâng cao như: Multicast UDP Java RMI Hệ thống phân tán Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính, UDP được sử dụng trong:\nSocket UDP Multicast Ứng dụng truyền tin nhanh Game, streaming, broadcast Hiểu UDP giúp bạn chọn đúng giao thức cho từng bài toán thực tế.\nKết luận Qua bài học này, bạn đã:\nHiểu UDP là gì và cơ chế hoạt động Phân biệt được TCP và UDP Biết vai trò của DatagramSocket và DatagramPacket Hiểu cách truyền dữ liệu không kết nối Chuẩn bị nền tảng cho bài Multicast UDP \u0026amp; Java RMI tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-6/","summary":"Giải thích giao thức UDP và cách Java lập trình Socket UDP – nền tảng cho truyền dữ liệu nhanh, không kết nối.","title":"Bài 6: Lập trình Socket UDP trong Java"},{"content":"Trong các ứng dụng mạng thực tế, đặc biệt là Server, chương trình thường phải xử lý nhiều yêu cầu cùng lúc.\nNếu chỉ sử dụng một luồng thực thi, server sẽ bị tắc nghẽn, các client phải chờ đợi và hiệu năng giảm nghiêm trọng.\nVì vậy, lập trình đa tuyến (Multithreading) và xử lý đồng thời (Concurrency) là kỹ thuật bắt buộc trong lập trình mạng.\nTuyến (Thread) là gì? Thread là một dòng điều khiển tuần tự bên trong một chương trình.\nMột chương trình (process) có thể chứa nhiều thread Các thread có thể chạy đồng thời Mỗi thread thực hiện một nhiệm vụ riêng Thread không phải là một chương trình độc lập,\nnó luôn thuộc về một process.\nProcess và Thread Process:\nCó không gian bộ nhớ riêng Chạy độc lập với process khác Tạo và chuyển đổi tốn nhiều tài nguyên Thread:\nChia sẻ bộ nhớ với các thread khác trong cùng process Tạo nhanh hơn process Chuyển đổi nhanh hơn Nhờ thread, chương trình có thể thực hiện nhiều công việc cùng lúc trong cùng một ứng dụng.\nVì sao cần lập trình đa tuyến? Lập trình đa tuyến giúp:\nTăng hiệu suất và khả năng đáp ứng Tận dụng thời gian chờ đợi (I/O, mạng, tải file) Chia nhỏ tác vụ và xử lý đồng thời Cải thiện trải nghiệm người dùng Trong lập trình mạng, đa tuyến cho phép server phục vụ nhiều client cùng lúc.\nThực thi Thread trong Java Trong Java, một thread bắt đầu chạy khi gọi phương thức start().\nKhi thread chạy, JVM thực thi mã trong phương thức run() Khi run() kết thúc, thread cũng kết thúc Một thread không thể start lại, muốn chạy lại phải tạo thread mới Thread cần có điều kiện dừng rõ ràng để tránh chạy vô hạn.\nỨng dụng đa tuyến trong lập trình mạng Ứng dụng Chat đa tuyến Một ví dụ tiêu biểu của đa tuyến trong mạng là ứng dụng chat nhiều client – một server.\nĐặc điểm:\nServer chấp nhận nhiều client kết nối cùng lúc Mỗi client được xử lý bởi một thread riêng Tin nhắn từ một client được gửi tới tất cả client khác Server ghi lại nội dung chat vào file log Thông qua ví dụ này, sinh viên hiểu rõ:\nCách server xử lý nhiều kết nối đồng thời Cách phối hợp giữa socket và thread Vai trò của đa tuyến trong ứng dụng mạng Xử lý đồng thời (Concurrency) Xử lý đồng thời xảy ra khi nhiều thread:\nChạy cùng lúc Truy cập tài nguyên chung (biến, file, bộ nhớ) Nếu không kiểm soát tốt, chương trình có thể gặp các vấn đề nghiêm trọng.\nRace Condition Race Condition xảy ra khi:\nNhiều thread cùng truy cập và thay đổi dữ liệu chung Kết quả phụ thuộc vào thứ tự thực thi không xác định Điều này có thể dẫn đến:\nDữ liệu sai lệch Kết quả không nhất quán Lỗi khó phát hiện Đồng bộ hóa (Synchronization) Để tránh race condition, Java cung cấp cơ chế đồng bộ hóa:\nĐảm bảo chỉ một thread được truy cập tài nguyên tại một thời điểm Giữ cho dữ liệu luôn nhất quán Đồng bộ hóa là nền tảng để xây dựng các ứng dụng an toàn và ổn định khi chạy đa tuyến.\nCác vấn đề thường gặp trong xử lý đồng thời Một số vấn đề phổ biến:\nRace condition: tranh chấp dữ liệu Deadlock: các thread chờ nhau vô hạn Livelock: các thread liên tục phản ứng nhưng không tiến triển Starvation: thread không bao giờ được cấp tài nguyên Những vấn đề này khiến lập trình đa tuyến trở nên phức tạp và khó debug.\nLập lịch Thread trong Java Java sử dụng cơ chế lập lịch theo độ ưu tiên:\nMỗi thread có độ ưu tiên từ MIN_PRIORITY đến MAX_PRIORITY JVM chọn thread runnable có độ ưu tiên cao hơn để chạy Thread có thể nhường CPU cho thread khác bằng cách gọi yield() Việc hiểu cơ chế lập lịch giúp lập trình viên thiết kế thread hợp lý hơn.\nÝ nghĩa của lập trình đa tuyến và xử lý đồng thời Nắm vững kiến thức bài này giúp bạn:\nXây dựng server xử lý nhiều client Viết ứng dụng mạng hiệu năng cao Tránh lỗi tranh chấp dữ liệu Chuẩn bị cho các chủ đề nâng cao như: Server đa tuyến Pooling Threads Multicast UDP Java RMI Hệ thống phân tán Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm thread và multithreading Phân biệt process và thread Biết vai trò của đa tuyến trong lập trình mạng Hiểu các vấn đề xử lý đồng thời và race condition Chuẩn bị nền tảng cho các bài học nâng cao tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-7/","summary":"Giải thích lập trình đa tuyến và xử lý đồng thời trong Java – nền tảng cho các ứng dụng mạng nhiều client và hệ thống phân tán.","title":"Bài 7: Lập trình đa tuyến và xử lý đồng thời trong Java"},{"content":"Buổi 8 gồm 2 phần lớn:\nMulticast UDP: gửi dữ liệu từ một nguồn đến nhiều máy nhận cùng lúc (1 → N). Java RMI: gọi phương thức từ xa giữa các ứng dụng Java như gọi hàm bình thường (Remote Method Invocation). Đây là các kỹ thuật thường gặp trong streaming, trò chuyện nhóm, giám sát từ xa và hệ thống phân tán.\n1) UDP Multicast Unicast, Broadcast và Multicast Trong mạng máy tính có 3 kiểu gửi dữ liệu phổ biến:\nUnicast: 1 nguồn → 1 đích\nVí dụ: bạn mở một trang web, server trả dữ liệu cho riêng bạn.\nBroadcast: 1 nguồn → tất cả máy trong mạng nội bộ\nVí dụ: một thông báo phát cho toàn bộ LAN.\nMulticast: 1 nguồn → một nhóm máy đã đăng ký nhận dữ liệu\nVí dụ: server phát stream video cho nhóm người xem cùng lúc.\nMulticast là cách truyền hiệu quả khi nhiều máy cùng cần nhận một nội dung giống nhau.\nTại sao dùng UDP Multicast? UDP Multicast thường được dùng vì:\nHiệu suất cao: gửi 1 lần nhưng nhiều máy nhận → giảm tải mạng và server. Đơn giản, nhanh: UDP là kiểu “gửi và quên”, không phải chờ xác nhận. Tối ưu trong LAN: phù hợp môi trường mạng nội bộ (Local Area Network). Rất hợp streaming: audio/video cần tốc độ và độ trễ thấp hơn là đảm bảo tuyệt đối. Ứng dụng của Multicast Multicast có thể dùng trong:\nTruyền phát multimedia trực tiếp (audio/video streaming) Trò chuyện nhóm, hội thoại nhóm Quảng bá thông tin cấu hình mạng và cập nhật trong hệ thống mạng Game nhiều người chơi (gửi trạng thái game cho nhiều người) Phát thông tin trạng thái/cảnh báo cho nhiều thiết bị Phát tán cập nhật phần mềm trong mạng nội bộ Địa chỉ Multicast IPv4 Trong IPv4:\nClass D là dải địa chỉ dành cho multicast Dải địa chỉ multicast thường gặp: 224.0.0.0 – 239.255.255.255 Một số nhóm multicast hay được nhắc:\n224.0.0.1: tất cả host trong local subnet Multicast Group là gì? Multicast hoạt động theo “nhóm”:\nMột multicast group giống như một kênh. Máy nào muốn nhận dữ liệu phải tham gia nhóm (join group). Khi rời nhóm thì không nhận dữ liệu nữa. Multicast trong Java Java hỗ trợ multicast qua lớp:\njava.net.MulticastSocket (kế thừa từ DatagramSocket) Một số thao tác quan trọng:\njoinGroup(...): tham gia nhóm multicast leaveGroup(...): rời nhóm multicast setTimeToLive(ttl): đặt TTL (thời gian sống của gói tin, qua bao nhiêu router) Quy trình gửi dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket Tham gia nhóm multicast Tạo DatagramPacket chứa dữ liệu + địa chỉ nhóm + port Gửi packet Rời nhóm Ví dụ minh họa (ngắn, chỉ để hiểu):\n1 2 3 4 5 6 7 8 9 10 11 12 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(); socket.joinGroup(group); socket.setTimeToLive(5); byte[] data = \u0026#34;Hello Multicast\u0026#34;.getBytes(); DatagramPacket packet = new DatagramPacket(data, data.length, group, 9876); socket.send(packet); socket.leaveGroup(group); socket.close(); Quy trình nhận dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket lắng nghe trên port Tham gia nhóm multicast Tạo DatagramPacket rỗng để nhận dữ liệu Gọi receive() để chờ gói tin gửi về Đọc dữ liệu từ packet Rời nhóm và đóng socket Ví dụ minh họa (ngắn):\n1 2 3 4 5 6 7 8 9 10 11 12 13 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(9876); socket.joinGroup(group); byte[] buf = new byte[1024]; DatagramPacket packet = new DatagramPacket(buf, buf.length); socket.receive(packet); String msg = new String(packet.getData(), 0, packet.getLength()); System.out.println(\u0026#34;Received: \u0026#34; + msg); socket.leaveGroup(group); socket.close(); 2) Java RMI Java RMI là gì? RMI (Remote Method Invocation) cho phép chương trình Java:\nGọi phương thức của một đối tượng nằm trên máy khác Cảm giác giống như gọi method trong cùng chương trình Nói đơn giản:\nClient gọi: remoteObject.sum(1,2) Server thực thi thật và trả kết quả về cho client RMI giúp che giấu toàn bộ chi tiết mạng phía sau, người lập trình chỉ tập trung vào logic.\nVì sao dùng Java RMI? Java RMI được sử dụng vì:\nTích hợp sẵn trong Java, dễ triển khai nếu cả client và server đều dùng Java Gọi phương thức từ xa đơn giản như gọi hàm thông thường Hỗ trợ dữ liệu phức tạp: đối tượng, mảng, class tự định nghĩa Tự động xử lý giao tiếp mạng thông qua cơ chế stub / skeleton Dựa trên TCP/IP nên tương đối ổn định và tin cậy Hạn chế của Java RMI Một số điểm hạn chế cần lưu ý:\nPhụ thuộc Java: chủ yếu phù hợp Java ↔ Java Thiết kế dịch vụ phức tạp vẫn cần tổ chức tốt (đặc biệt khi dùng callback) Quản lý phiên và kết nối không mạnh như các giải pháp hiện đại Bảo mật cần cấu hình cẩn thận trong môi trường thực tế Ý tưởng kiến trúc RMI (hiểu nhanh) Trong Java RMI có các thành phần chính:\nRemote Interface\nKhai báo các phương thức cho phép gọi từ xa\nServer Implementation\nLớp cài đặt interface, chứa logic xử lý thật\nRMI Registry\nNơi đăng ký service để client tìm thấy server\nClient\nTìm (lookup) service trong registry và gọi phương thức\nCác bước triển khai RMI (tóm tắt) Định nghĩa Remote Interface Cài đặt interface bằng một class server (remote object) Viết chương trình server: tạo object và bind vào registry Viết chương trình client: lookup registry và gọi method Chạy RMI registry, chạy server, sau đó chạy client Ví dụ ứng dụng RMI Một số ví dụ thường gặp:\nTính tổng 2 số từ xa Dịch vụ quản lý tài khoản ATM Dịch vụ giám sát nhiệt độ có callback (server gọi ngược lại client) Bài tập gợi ý theo đúng nội dung buổi 8 BT8.01: Mô phỏng streaming video\n(1 server phát, nhiều client nhận dữ liệu)\nBT8.02: Server quản lý tài khoản ATM bằng RMI\n(thêm user, đăng nhập, gửi/rút tiền, lưu lịch sử giao dịch)\nKết luận Qua bài học này, bạn đã:\nHiểu sự khác nhau giữa Unicast, Broadcast và Multicast Nắm được vì sao Multicast UDP phù hợp cho truyền dữ liệu nhóm và streaming Biết cách Java hỗ trợ multicast qua MulticastSocket Hiểu Java RMI và cơ chế gọi phương thức từ xa Chuẩn bị nền tảng cho các bài ứng dụng mạng phân tán và đồ án học phần ","permalink":"http://localhost:1313/blog/bai-viet-8/","summary":"Giải thích Multicast UDP (gửi 1-n) và Java RMI (gọi phương thức từ xa) – nền tảng cho ứng dụng nhóm và hệ phân tán.","title":"Bài 8: Multicast UDP và Java RMI"},{"content":"Sau khi hoàn thành các bài về TCP, UDP, đa tuyến và xử lý đồng thời,\nchúng ta đã có đủ nền tảng để xây dựng một ứng dụng mạng hoàn chỉnh.\nBài học này giúp bạn xâu chuỗi toàn bộ kiến thức đã học,\nhiểu rõ mỗi công nghệ dùng trong trường hợp nào,\nvà cách thiết kế một hệ thống mạng đúng tư duy kỹ sư.\nNhìn lại các mô hình giao tiếp mạng đã học Trong lập trình mạng, các ứng dụng thường được xây dựng dựa trên mô hình Client – Server.\nClient: gửi yêu cầu, nhập dữ liệu, hiển thị kết quả Server: xử lý logic, quản lý dữ liệu, trả kết quả Tùy bài toán, ta lựa chọn giao thức và mô hình phù hợp.\nSo sánh TCP, UDP và Multicast TCP – Giao tiếp tin cậy TCP phù hợp khi:\nCần đảm bảo dữ liệu đúng và đủ Cần kết nối ổn định, hai chiều Ví dụ: chat, truyền file, game theo lượt, hệ thống ngân hàng Đặc trưng:\nCó bắt tay 3 bước Có kiểm soát lỗi, kiểm soát luồng Tốn tài nguyên hơn UDP UDP – Giao tiếp nhanh, không kết nối UDP phù hợp khi:\nƯu tiên tốc độ Chấp nhận mất gói Ví dụ: game thời gian thực, streaming, cảm biến Đặc trưng:\nKhông kết nối Không đảm bảo thứ tự Ít độ trễ UDP Multicast – Truyền dữ liệu nhóm Multicast được dùng khi:\nMột nguồn → nhiều người nhận Dữ liệu giống nhau cho tất cả client Ví dụ: livestream, thông báo hệ thống, truyền trạng thái Ưu điểm:\nGiảm tải server Tiết kiệm băng thông Phù hợp mạng LAN Vai trò của đa tuyến (Multithreading) Trong thực tế, server không thể xử lý từng client một cách tuần tự.\nĐa tuyến giúp:\nNhiều client kết nối cùng lúc Không client nào bị “đóng băng” Tăng khả năng mở rộng hệ thống Ví dụ:\nServer chat: mỗi client là một thread Server TCP: mỗi socket được xử lý riêng Thiết kế một ứng dụng mạng hoàn chỉnh Khi thiết kế, cần xác định rõ:\nGiao thức: TCP hay UDP? Mô hình: 1–1, 1–n, n–n? Đồng thời hay tuần tự? Client gửi gì? Server xử lý gì? Một thiết kế tốt luôn:\nPhân tách rõ giao tiếp – xử lý – dữ liệu Dễ mở rộng Dễ bảo trì Liên hệ với đồ án học phần Các đồ án như:\nChat đa tuyến Oẳn Tù Tì client–server Streaming UDP Dịch vụ RMI Đều là sự kết hợp của các kiến thức đã học,\nkhông phải nội dung mới.\nKết luận Qua bài học này, bạn đã:\nHệ thống lại toàn bộ kiến thức lập trình mạng Hiểu rõ khi nào dùng TCP, UDP, Multicast Nắm được vai trò của đa tuyến Biết cách tư duy thiết kế một ứng dụng mạng hoàn chỉnh Đây là bước chuẩn bị quan trọng trước khi vận dụng toàn bộ kiến thức vào một hệ thống thực tế.\n","permalink":"http://localhost:1313/blog/bai-viet-9/","summary":"Tổng hợp kiến thức TCP, UDP, đa tuyến và cách thiết kế ứng dụng mạng Client–Server hoàn chỉnh.","title":"Bài 9: Tổng hợp kiến thức \u0026 thiết kế ứng dụng mạng"},{"content":"Bài cuối cùng của học phần không nhằm giới thiệu công nghệ mới,\nmà tập trung vào cách vận dụng kiến thức đã học vào thực tế.\nĐây là giai đoạn chuyển từ:\n“Biết dùng” → “Biết thiết kế” → “Biết đánh giá hệ thống”\nTư duy vận dụng kiến thức Một ứng dụng mạng hoàn chỉnh cần trả lời được các câu hỏi:\nVì sao chọn TCP mà không phải UDP? Vì sao cần đa tuyến? Server có chịu được nhiều client không? Hệ thống có mở rộng được không? Đây chính là tư duy kỹ sư, không phải chỉ “chạy được là xong”.\nĐánh giá một ứng dụng mạng Khi hoàn thiện hệ thống, cần xem xét:\n1. Tính đúng đắn Dữ liệu có truyền đúng không? Có mất gói không? Có xử lý lỗi không? 2. Tính đồng thời Nhiều client có dùng chung được không? Có bị treo server không? Có race condition không? 3. Hiệu năng Độ trễ thế nào? Server có bị quá tải không? Có tách luồng hợp lý không? Liên hệ với các mô hình phân tán Các hệ thống đã học là nền tảng cho:\nHệ thống client–server lớn Ứng dụng phân tán Microservices Cloud services Java RMI, TCP đa tuyến hay UDP Multicast\nđều là những viên gạch đầu tiên.\nTừ học phần đến thực tế Sau học phần này, bạn có thể tiếp cận:\nWebSocket REST API gRPC Message Queue (Kafka, RabbitMQ) Hệ thống realtime Tư duy lập trình mạng không thay đổi, chỉ công nghệ thay đổi.\nTổng kết toàn bộ học phần Qua toàn bộ chuỗi bài, bạn đã:\nHiểu cách dữ liệu đi qua mạng Làm việc với TCP, UDP, Multicast Xử lý đa tuyến và đồng thời Tiếp cận lập trình phân tán với RMI Có tư duy thiết kế hệ thống mạng Lời kết Lập trình mạng không chỉ là code socket,\nmà là hiểu cách các hệ thống nói chuyện với nhau.\nNếu bạn hiểu được điều đó,\nbạn đã vượt xa mức “học để qua môn”.\n","permalink":"http://localhost:1313/blog/bai-viet-10/","summary":"Vận dụng toàn bộ kiến thức lập trình mạng để xây dựng, đánh giá và hoàn thiện một ứng dụng thực tế.","title":"Bài 10: Hoàn thiện \u0026 vận dụng lập trình mạng"},{"content":"Lời mở đầu Có những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\nMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\nHọc tập Những năm đại học trôi qua nhanh hơn mình từng nghĩ. Ngày mới bước chân vào giảng đường, mình vẫn còn khá mơ hồ về ngành học, về tương lai, về chính bản thân mình sẽ trở thành ai sau bốn năm. Nhưng rồi từng môn học, từng bài tập nhóm, từng đồ án kéo mình lại gần hơn với cách một hệ thống được hình thành và vận hành.\nHệ thống thông tin không chỉ là lập trình, cũng không đơn thuần là công nghệ. Đó là câu chuyện về con người, quy trình và dữ liệu. Mình học cách đặt câu hỏi, học cách lắng nghe yêu cầu, học cách vẽ ra những sơ đồ tưởng chừng khô khan nhưng lại chứa rất nhiều suy nghĩ phía sau. Dần dần, mình nhận ra mình thích phần “hiểu vấn đề” hơn là chỉ chăm chăm vào lời giải.\nĐịnh hướng Ở thời điểm hiện tại, mình đang định hướng theo con đường Business Analyst (BA). Mình hứng thú với vai trò đứng giữa – không quá xa kỹ thuật, cũng không tách rời nghiệp vụ. Đó là nơi cần sự rõ ràng trong tư duy, sự kiên nhẫn trong giao tiếp và khả năng chuyển hóa những điều mơ hồ thành thứ có thể triển khai được.\nMình không nghĩ BA là một vị trí “nhẹ nhàng” hay “an toàn”. Ngược lại, đó là công việc đòi hỏi phải học rất nhiều, sai rất nhiều và sửa rất nhiều. Nhưng chính điều đó khiến mình thấy phù hợp. Mình muốn hiểu hệ thống trước khi xây dựng nó, muốn biết vì sao người ta see cần một chức năng, chứ không chỉ là nó được viết như thế nào.\nBlog Blog này ra đời khá tự nhiên, giống như một cuốn sổ mở rộng hơn là một trang thể hiện điều gì đó to tát. Mình viết để nhớ, để hệ thống lại những gì đã học, và đôi khi là để sắp xếp lại suy nghĩ của chính mình.\nỞ đây có thể là kiến thức về Hệ thống thông tin, về phân tích nghiệp vụ, về lập trình, hoặc đơn giản là những trải nghiệm học tập và va chạm trong quá trình làm đồ án, làm việc nhóm, và chuẩn bị bước ra môi trường thực tế. Mình không mong mọi thứ phải hoàn hảo, chỉ mong nó thật và có ích cho ai đó đang đi trên con đường tương tự.\nLời kết Mình đang ở một giai đoạn chưa thể gọi là trưởng thành, nhưng cũng không còn quá non nớt. Vẫn đang học, vẫn đang thử, vẫn đang sai và sửa mỗi ngày. Nếu có một điều mình mong giữ được lâu nhất, thì đó là sự tò mò và tinh thần học hỏi – những thứ giúp mình không đứng yên giữa rất nhiều lựa chọn ngoài kia.\nCảm ơn bạn đã ghé qua và đọc những dòng này. Hy vọng ở một thời điểm nào đó, những chia sẻ nhỏ ở đây sẽ chạm đến bạn – dù chỉ là một chút. \u0026ldquo;Học để chia sẻ, chia sẻ để học nhiều hơn.\u0026rdquo;\nLiên hệ Nếu bạn muốn gửi cho mình vài dòng trao đổi,\nbạn có thể liên hệ với mình qua Email hoặc GitHub ,Facebook dưới đây.\nCảm ơn bạn đã ghé thăm blog! ","permalink":"http://localhost:1313/about/","summary":"\u003ch2 id=\"lời-mở-đầu\"\u003eLời mở đầu\u003c/h2\u003e\n\u003cp\u003eCó những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\u003c/p\u003e\n\u003cp\u003eMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\u003c/p\u003e","title":"Giới thiệu"},{"content":"Trong lập trình mạng, trước khi kết nối, ta phải biết \u0026ldquo;địa chỉ nhà\u0026rdquo; (IP) của mình và đối phương. Java cung cấp class\nHình 1.1: Hiệu ứng Dunning–Kruger – mức độ tự tin thay đổi theo kinh nghiệm học tập\nGóc nhìn học tập: Hiệu ứng Dunning–Kruger InetAddress để làm việc này.\nĐịa chỉ IP là gì trong lập trình mạng? IP (Internet Protocol Address) là địa chỉ định danh của một thiết bị khi tham gia vào mạng máy tính.\nTrong lập trình mạng, IP đóng vai trò quan trọng trong việc:\nXác định máy gửi và máy nhận Định tuyến dữ liệu trong quá trình truyền thông Thiết lập kết nối giữa các tiến trình chạy trên những máy khác nhau Nếu không có địa chỉ IP, các máy tính sẽ không thể nhận biết và giao tiếp với nhau.\nVai trò của lớp InetAddress trong Java Lớp InetAddress đại diện cho một địa chỉ IP trong Java.\nThông qua lớp này, lập trình viên có thể:\nLấy địa chỉ IP của máy đang chạy chương trình Lấy tên máy (hostname) Phân giải tên miền sang địa chỉ IP Chuẩn bị thông tin để tạo Socket hoặc ServerSocket Hầu hết các chương trình lập trình mạng trong Java đều sử dụng InetAddress ở bước khởi tạo.\nPhân tích ý nghĩa các lệnh trong chương trình InetAddress.getLocalHost()\n→ Trả về đối tượng đại diện cho máy cục bộ (localhost).\ngetHostName()\n→ Lấy tên máy do hệ điều hành hoặc mạng gán.\ngetHostAddress()\n→ Lấy địa chỉ IP của máy dưới dạng chuỗi.\nViệc in ra hostname và IP giúp:\nKiểm tra cấu hình mạng Xác định đúng máy khi kết nối Client – Server Debug lỗi mạng Một số lưu ý khi lấy IP trong Java Khi máy không kết nối mạng, IP có thể là 127.0.0.1 Khi máy có nhiều card mạng (WiFi, LAN, VPN), IP trả về có thể không phải IP Internet Trên Server, hostname và IP thường khác máy cá nhân Ứng dụng thực tế Việc xác định IP của máy thường được sử dụng trong:\nChương trình Client – Server Thông báo IP Server cho Client kết nối Kiểm tra kết nối mạng LAN Ghi log và giám sát hệ thống Kết luận Qua bài học này, ta đã:\nHiểu vai trò của địa chỉ IP trong lập trình mạng Biết cách lấy IP bằng lớp InetAddress Chuẩn bị nền tảng cho các kỹ thuật TCP, UDP và RMI Liên hệ với học phần Lập trình Mạng máy tính Bài học này nằm trong nội dung mở đầu của học phần Lập trình Mạng máy tính (CMP180) tại Trường Đại học Công nghệ TP.HCM (HUTECH).\nTrong lộ trình môn học, sinh viên sẽ lần lượt tiếp cận các nội dung:\nKiến thức nền tảng về mạng và lập trình mạng Quản lý luồng nhập xuất (I/O) Quản lý địa chỉ và kết nối mạng Lập trình Socket TCP và UDP Xử lý đa tuyến, đa luồng Multicast UDP và Java RMI Thực hiện đồ án học phần cá nhân Mục tiêu của bài học Thông qua Bài 1, sinh viên sẽ:\nLàm quen với môi trường lập trình mạng bằng Java Hiểu được vai trò của địa chỉ IP trong giao tiếp mạng Biết cách sử dụng lớp InetAddress để lấy IP và hostname Chuẩn bị nền tảng cho các bài học tiếp theo về Socket và Server – Client ","permalink":"http://localhost:1313/blog/bai-viet-1/","summary":"GIỚI THIỆU HỌC PHẦN.","title":"Bài 1: Tổng quan khoá học"},{"content":"Trong lập trình mạng, nếu IP được xem như địa chỉ nhà của một máy tính trong mạng,\nthì Port (cổng) chính là số hiệu dùng để xác định chương trình hoặc dịch vụ cụ thể đang chạy trên máy đó.\nMột máy tính có thể chạy đồng thời nhiều ứng dụng mạng như Web Server, Database Server, Game Server hoặc Chat Server.\nMỗi ứng dụng bắt buộc phải gắn với một Port riêng để hệ điều hành có thể phân biệt và định tuyến dữ liệu chính xác.\nPort nằm ở đâu trong mô hình TCP/IP? Trong bộ giao thức TCP/IP, Port thuộc về Transport Layer (Tầng giao vận) và được sử dụng bởi hai giao thức chính là TCP và UDP.\nĐịa chỉ IP xác định máy nào sẽ nhận dữ liệu Port xác định ứng dụng nào trên máy đó sẽ xử lý dữ liệu Sự kết hợp giữa IP + Port tạo thành một Socket, là điểm cuối (endpoint) của quá trình giao tiếp mạng.\nCác loại Port phổ biến Port được đánh số từ 0 đến 65535 và được chia thành ba nhóm chính:\nInternet và các End Devices Trước khi tìm hiểu về Port, cần hiểu Internet được cấu thành từ hàng tỷ thiết bị đầu cuối (End Devices) như máy tính, điện thoại, máy chủ và các thiết bị IoT.\nCác thiết bị này kết nối với nhau thông qua nhiều lớp mạng khác nhau, và mỗi thiết bị khi tham gia giao tiếp mạng đều cần có địa chỉ IP và Port để định danh. Hình 2.1: Sơ đồ minh họa Internet và các thiết bị đầu cuối (End Devices) kết nối thông qua các mạng truy cập và mạng lõi.\nTrong quá trình giao tiếp mạng, một thiết bị không chỉ cần địa chỉ IP để xác định vị trí trong mạng, mà còn cần Port để xác định chính xác ứng dụng hoặc dịch vụ đang lắng nghe trên thiết bị đó.\nDo đó, Port đóng vai trò như “điểm tiếp nhận” (endpoint) cho các tiến trình mạng chạy trên cùng một máy.\nMô hình các tầng giao thức TCP/IP Để hiểu rõ Port hoạt động ở đâu và vì sao Server cần Port, ta cần nắm được mô hình giao thức TCP/IP – nền tảng của mọi ứng dụng mạng hiện nay.\nHình 2.2: Mô hình các tầng giao thức TCP/IP và các giao thức tiêu biểu tương ứng với từng tầng.\nTrong mô hình TCP/IP, địa chỉ IP hoạt động ở tầng Internet, giúp xác định thiết bị trong mạng.\nTrong khi đó, Port hoạt động ở tầng Transport (TCP/UDP), giúp xác định chính xác ứng dụng hoặc dịch vụ đang giao tiếp trên thiết bị đó.\nWell-known Ports (0 – 1023) Được dùng cho các dịch vụ chuẩn:\nPort 80: HTTP Port 443: HTTPS Port 21: FTP Port 25: SMTP Registered Ports (1024 – 49151) Thường dùng cho các ứng dụng phổ biến:\nPort 3306: MySQL Port 8080: Web Server thay thế port 80 Dynamic / Private Ports (49152 – 65535) Do hệ điều hành cấp phát tạm thời cho Client khi giao tiếp mạng.\nVì sao Server thường dùng cổng 8080? Cổng 8080 rất phổ biến trong quá trình phát triển và học tập vì:\nTránh xung đột với cổng 80 đang được hệ điều hành chiếm dụng Không cần quyền Administrator khi mở Server Phù hợp cho các Web Server thử nghiệm như: Apache Tomcat Spring Boot Node.js Lỗi thường gặp: “Address already in use” Lỗi này xảy ra khi Server cố gắng mở một Port đã bị chương trình khác chiếm dụng.\nNguyên nhân phổ biến:\nServer cũ chưa được tắt Port đang được dùng bởi dịch vụ khác Chạy nhiều Server cùng lúc Cách khắc phục:\nĐổi sang Port khác (ví dụ: 8080 → 9090) Kiểm tra Port đang sử dụng trong hệ điều hành Đảm bảo chỉ có một Server chạy tại một thời điểm Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), khái niệm Port sẽ được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Xây dựng mô hình Client – Server Java RMI và Multicast Việc hiểu rõ Port là nền tảng bắt buộc trước khi triển khai các ứng dụng mạng thực tế.\nKết luận Qua bài học này, ta đã:\nHiểu được Port là gì và vai trò của Port trong lập trình mạng Nắm được mối quan hệ giữa IP, Port và Socket Giải thích được lý do Server thường sử dụng cổng 8080 Chuẩn bị kiến thức nền cho các bài học tiếp theo về TCP và UDP ","permalink":"http://localhost:1313/blog/bai-viet-2/","summary":"MẠNG MÁY TÍNH \u0026amp; INTERNET.","title":"Bài 2: Kiến thức nền tảng?"},{"content":"Trong lập trình Java, luồng nhập xuất (Input / Output Streams) đóng vai trò trung gian giúp chương trình đọc và ghi dữ liệu từ nhiều nguồn khác nhau như bàn phím, file, console, bộ nhớ và sau này là socket mạng.\nHiểu rõ cơ chế luồng nhập xuất là bước nền bắt buộc trước khi đi vào lập trình Socket TCP, UDP hay Java RMI.\nLuồng (Stream) là gì? Luồng (Stream) là dòng dữ liệu di chuyển\ntừ nguồn → chương trình hoặc từ chương trình → đích.\nKhi Java đọc hoặc ghi dữ liệu, dữ liệu không đi trực tiếp mà luôn được đóng gói và truyền qua luồng.\nLuồng nhập xuất là gì? Luồng nhập xuất là cơ chế cho phép chương trình:\nNhận dữ liệu từ bên ngoài (Input) Ghi dữ liệu ra bên ngoài (Output) Luồng có thể kết nối với nhiều nguồn và đích khác nhau:\nFile Bàn phím Màn hình (console) Bộ nhớ Kết nối mạng (TCP / UDP) Dữ liệu trong luồng tồn tại dưới những dạng nào? Trong Java, dữ liệu trong luồng tồn tại dưới hai dạng chính:\nLuồng byte Luồng ký tự Việc chọn đúng loại luồng ảnh hưởng trực tiếp đến hiệu năng và tính chính xác của chương trình.\nLuồng byte trong Java Đặc điểm Dữ liệu được xử lý dưới dạng nhị phân Phù hợp với: File nhị phân Ảnh, video Socket mạng Dữ liệu phức tạp Các lớp gốc InputStream – luồng đọc byte OutputStream – luồng ghi byte Cả hai đều là lớp trừu tượng (abstract).\nCác luồng byte đọc phổ biến FileInputStream – đọc byte từ file ByteArrayInputStream – đọc từ mảng byte PipedInputStream – đọc từ luồng pipe Các luồng byte ghi phổ biến FileOutputStream – ghi byte vào file ByteArrayOutputStream – ghi vào mảng byte PipedOutputStream – ghi vào luồng pipe Mô hình đọc/ghi dữ liệu với Stream Quy trình chung khi làm việc với luồng:\nTạo đối tượng Stream Gắn Stream với nguồn hoặc đích Đọc/ghi dữ liệu trong vòng lặp Đóng Stream sau khi hoàn tất Luồng ký tự trong Java Đặc điểm Xử lý dữ liệu dạng Unicode Phù hợp với: File văn bản Chuỗi Dữ liệu hiển thị cho người dùng Các lớp gốc Reader – luồng đọc ký tự Writer – luồng ghi ký tự Các luồng ký tự đọc phổ biến FileReader – đọc file văn bản BufferedReader – đọc có bộ đệm StringReader – đọc chuỗi CharArrayReader – đọc mảng ký tự Các luồng ký tự ghi phổ biến FileWriter – ghi vào file văn bản BufferedWriter – ghi có bộ đệm PrintWriter – ghi dữ liệu dạng dễ đọc StringWriter – ghi chuỗi Luồng lọc dữ liệu (Filtered Streams) Luồng lọc dùng để chuyển đổi dữ liệu từ dạng byte/ký tự sang các kiểu dữ liệu khác.\nCác luồng lọc phổ biến DataInputStream DataOutputStream Cho phép đọc/ghi các kiểu dữ liệu nguyên thủy:\nint float double boolean char Đây là cầu nối giữa luồng thô và dữ liệu có kiểu trong Java.\nLưu trạng thái đối tượng – Serialization Serialization là gì? Serialization (chuỗi hóa) là quá trình chuyển đối tượng Java thành luồng byte để:\nLưu vào file Truyền qua mạng Phục hồi lại sau này Deserialization Ngược lại, Deserialization (giải chuỗi) là quá trình:\nĐọc byte Tái tạo lại đối tượng ban đầu Đây là nền tảng cho:\nLưu dữ liệu chương trình Java RMI Truyền object qua mạng Try-with-resources (TWR) Java hỗ trợ Try-with-resources để:\nTự động đóng stream Tránh rò rỉ tài nguyên Code gọn và an toàn hơn So với try-catch truyền thống, TWR:\nÍt lỗi hơn Dễ bảo trì hơn Được khuyến khích sử dụng Các lỗi I/O thường gặp Khi làm việc với luồng, một số exception phổ biến là:\nFileNotFoundException IOException EOFException UnsupportedEncodingException FileAlreadyExistsException AccessDeniedException SocketException MalformedURLException SerializationException InvalidPathException Việc bắt và xử lý exception đúng cách là yêu cầu bắt buộc trong lập trình Java.\nLiên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), luồng nhập xuất được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Truyền dữ liệu Client – Server Java RMI Multicast UDP Không hiểu I/O Stream → không thể làm mạng đúng cách.\nKết luận Qua bài học này, ta đã:\nHiểu khái niệm luồng nhập xuất trong Java Phân biệt luồng byte và luồng ký tự Nắm được cách đọc/ghi dữ liệu với Stream Biết vai trò của Serialization và Filtered Streams Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo Khi xử lý các tác vụ mạng (như gọi API), người mới học JS hay viết code lồng nhau kiểu này:\n1 2 3 4 5 6 7 8 9 10 // Cực hình Callback Hell getData(function(a) { getMoreData(a, function(b) { getMoreData(b, function(c) { getMoreData(c, function(d) { console.log(d); }); }); }); }); ","permalink":"http://localhost:1313/blog/bai-viet-3/","summary":"Tổng quan về Input/Output Streams trong Java – nền tảng cho xử lý file, console và lập trình mạng.","title":"Bài 3: Quản lý luồng nhập xuất trong Java"},{"content":"Trong lập trình mạng, trước khi chương trình có thể gửi hoặc nhận dữ liệu, điều quan trọng nhất là xác định đúng địa chỉ kết nối mạng. Nếu xác định sai địa chỉ, chương trình sẽ không thể giao tiếp, dù phần xử lý dữ liệu có đúng đến đâu.\nBài học này giúp bạn hiểu cách Java làm việc với địa chỉ IP, tên miền (DNS) và URL. Đây là nền tảng bắt buộc trước khi đi vào Socket TCP, UDP, Web Crawler và Java RMI.\nĐịa chỉ kết nối mạng là gì? Địa chỉ kết nối mạng là thông tin dùng để xác định máy nào trong mạng cần giao tiếp và dịch vụ nào trên máy đó sẽ xử lý dữ liệu.\nTrong Internet, địa chỉ kết nối thường bao gồm:\nĐịa chỉ IP Tên miền (Domain Name) Cổng (Port) Giao thức (Protocol) DNS – Domain Name System Hình 4.1 – Mô hình hoạt động của DNS (Domain Name System)\nClient gửi yêu cầu phân giải tên miền đến DNS Server, DNS trả về địa chỉ IP tương ứng để client kết nối đến server đích.*\nCon người dễ nhớ tên miền hơn các dãy số IP.\nDNS (Domain Name System) có nhiệm vụ ánh xạ tên miền sang địa chỉ IP, giúp client tìm đúng server cần kết nối.\nVí dụ:\ngoogle.com tương ứng với nhiều địa chỉ IP khác nhau www.cs.yale.edu tương ứng với 128.36.229.30 Nhờ DNS, người dùng không cần ghi nhớ địa chỉ IP khi truy cập Internet. *Hình 4.2 minh họa cấu trúc phân cấp của hệ thống DNS, bao gồm Root Domain, các Top-Level Domain (com, edu, org, vn, …) và các tên miền con phía dưới.\nCấu trúc phân cấp này giúp DNS hoạt động hiệu quả và dễ mở rộng trên toàn Internet.*\nĐịa chỉ IPv4 IPv4 là dạng địa chỉ phổ biến, gồm 32 bit, thường được viết thành bốn nhóm số.\nVí dụ:\n192.168.1.1 8.8.8.8 Một số dải địa chỉ đặc biệt:\n127.x.x.x là loopback (localhost) 224.0.0.0 – 239.255.255.255 là multicast Lớp InetAddress trong Java Java cung cấp lớp InetAddress để làm việc với địa chỉ IP và DNS.\nLớp này thường được dùng để:\nPhân giải tên miền sang IP Kiểm tra loại địa chỉ Kiểm tra khả năng kết nối mạng Ví dụ minh họa:\n1 InetAddress address = InetAddress.getByName(\u0026#34;google.com\u0026#34;); URL – Uniform Resource Locator URL được dùng để xác định tài nguyên trên Internet như trang web, file hoặc dịch vụ.\nMột URL đầy đủ thường bao gồm các thành phần sau:\nGiao thức (Protocol) Tên miền (Host) Cổng (Port) Đường dẫn (Path) Chuỗi truy vấn (Query) Ví dụ một URL đầy đủ: https://www.hutech.edu.vn/admission?id=123\nURL cho biết lấy dữ liệu ở đâu và bằng cách nào.\nLớp URL trong Java Lớp URL cho phép chương trình Java:\nPhân tích các thành phần của URL Kết nối tới server Đọc dữ liệu từ Internet Ví dụ minh họa:\n1 URL url = new URL(\u0026#34;https://www.example.com\u0026#34;); Ý nghĩa của việc quản lý địa chỉ kết nối mạng Hiểu rõ cách quản lý địa chỉ mạng giúp:\nTránh kết nối sai server Chuẩn bị đúng địa chỉ cho Socket TCP/UDP Hiểu cách Web Crawler hoạt động Nắm vững mô hình Client – Server Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm địa chỉ kết nối mạng Biết vai trò của DNS và IPv4 Nắm được cách Java làm việc với InetAddress Hiểu cấu trúc và vai trò của URL Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-4/","summary":"Tìm hiểu cách Java quản lý địa chỉ mạng thông qua InetAddress, URL, URLConnection và DNS.","title":"Bài 4: Quản lý địa chỉ kết nối mạng trong Java"},{"content":"Trong lập trình mạng, TCP Socket là cơ chế quan trọng nhất để xây dựng các ứng dụng Client – Server có độ tin cậy cao.\nBài học này giúp bạn hiểu TCP là gì, vì sao cần TCP, và cách Java triển khai TCP thông qua Socket và ServerSocket.\nĐây là bước chuyển tiếp trực tiếp từ kiến thức địa chỉ mạng (IP, DNS, URL) sang giao tiếp dữ liệu thực tế giữa các chương trình.\nTCP là gì? TCP (Transmission Control Protocol) là giao thức truyền thông hướng kết nối, đảm bảo dữ liệu được truyền:\nĐúng thứ tự Đầy đủ Không bị mất mát Không bị trùng lặp Trước khi truyền dữ liệu, TCP yêu cầu thiết lập kết nối giữa hai bên, và chỉ khi kết nối thành công thì dữ liệu mới được trao đổi.\nVì sao sử dụng TCP? TCP được sử dụng khi ứng dụng yêu cầu độ tin cậy cao, ví dụ:\nỨng dụng chat Ứng dụng client–server Truyền file Game online theo lượt Hệ thống ngân hàng, thương mại điện tử TCP cung cấp các cơ chế quan trọng:\nĐảm bảo dữ liệu: gói tin bị mất sẽ được gửi lại Kiểm soát lỗi: phát hiện và sửa lỗi trong quá trình truyền Kiểm soát luồng: tránh làm quá tải phía nhận Giao tiếp hai chiều: cho phép gửi và nhận dữ liệu đồng thời Cơ chế hoạt động của TCP Quá trình giao tiếp TCP gồm ba giai đoạn chính:\nThiết lập kết nối (Bắt tay 3 bước – Three-way Handshake) Truyền dữ liệu Giải phóng kết nối Nhờ cơ chế này, TCP đảm bảo rằng hai bên luôn sẵn sàng trước khi truyền và kết thúc an toàn sau khi hoàn tất.\nMô hình Client – Server Các ứng dụng TCP thường hoạt động theo mô hình Client – Server.\nServer:\nChạy trước Lắng nghe yêu cầu kết nối Cung cấp dịch vụ Trả kết quả cho client Client:\nChạy sau Chủ động kết nối tới server Gửi yêu cầu Nhận phản hồi từ server Quá trình giao tiếp gồm:\nClient gửi yêu cầu Server xử lý Server trả kết quả cho client Socket trong Java Trong Java, Socket đại diện cho điểm cuối giao tiếp giữa client và server khi sử dụng TCP.\nSocket cho phép:\nGửi dữ liệu tới server Nhận dữ liệu từ server Giao tiếp hai chiều thông qua luồng nhập/xuất Ví dụ minh họa tạo Socket phía client:\n1 Socket socket = new Socket(\u0026#34;localhost\u0026#34;, 8080); ServerSocket trong Java ServerSocket được sử dụng ở phía server để:\nMở một cổng lắng nghe Chờ client kết nối Chấp nhận kết nối và tạo Socket giao tiếp ServerSocket đóng vai trò như cửa ngõ, cho phép các client kết nối vào server.\nVí dụ minh họa:\n1 ServerSocket server = new ServerSocket(8080); Luồng dữ liệu trong TCP Socket Sau khi kết nối TCP được thiết lập, client và server trao đổi dữ liệu thông qua các luồng:\nInputStream: dùng để đọc dữ liệu từ socket OutputStream: dùng để ghi dữ liệu vào socket Luồng dữ liệu này hoạt động tương tự như I/O Stream đã học ở bài trước,\nnhưng nguồn và đích là mạng thay vì file hay bàn phím.\nVí dụ ứng dụng: Trò chơi Oẳn Tù Tì Một bài tập tiêu biểu sử dụng TCP Socket là trò chơi Oẳn Tù Tì theo mô hình Client – Server.\nĐặc điểm Server quản lý luật chơi và điểm số Hai client gửi lựa chọn (kéo – búa – bao) Server xác định kết quả và gửi lại cho client Dữ liệu được truyền qua TCP để đảm bảo chính xác Thông qua bài tập này, sinh viên hiểu rõ:\nCách thiết lập kết nối TCP Cách trao đổi dữ liệu giữa nhiều client Cách xử lý lỗi mạng và ngoại lệ Ý nghĩa của lập trình TCP Socket Việc nắm vững TCP Socket giúp bạn:\nHiểu bản chất giao tiếp mạng Xây dựng hệ thống Client – Server thực tế Chuẩn bị cho các bài nâng cao như: Đa tuyến (Multi-thread) Socket UDP Java RMI Ứng dụng mạng phân tán Kết luận Qua bài học này, bạn đã:\nHiểu TCP là gì và vì sao cần TCP Nắm được mô hình Client – Server Biết vai trò của Socket và ServerSocket trong Java Hiểu cách dữ liệu được truyền qua TCP Chuẩn bị nền tảng cho các bài học UDP và xử lý đồng thời tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-5/","summary":"Giải thích mô hình Client–Server và cách lập trình Socket TCP trong Java – nền tảng cho giao tiếp mạng tin cậy.","title":"Bài 5: Lập trình Socket TCP trong Java"},{"content":"#Trong lập trình mạng, không phải lúc nào ứng dụng cũng cần độ tin cậy tuyệt đối như TCP.\nTrong nhiều trường hợp, điều quan trọng hơn là tốc độ truyền nhanh và độ trễ thấp.\nBài học này giới thiệu UDP Socket – cơ chế truyền dữ liệu không kết nối, được sử dụng rộng rãi trong các ứng dụng thời gian thực.\nUDP là gì? UDP (User Datagram Protocol) là giao thức truyền thông không hướng kết nối.\nĐiều này có nghĩa là:\nKhông thiết lập kết nối trước khi truyền Không đảm bảo dữ liệu đến nơi Không đảm bảo thứ tự gói tin Không tự động gửi lại gói tin bị mất UDP gửi dữ liệu theo từng datagram (gói tin độc lập).\nSo sánh TCP và UDP TCP UDP Có kết nối Không kết nối Đảm bảo dữ liệu Không đảm bảo Truyền theo luồng Truyền theo gói Độ trễ cao hơn Độ trễ thấp Phù hợp dữ liệu quan trọng Phù hợp dữ liệu thời gian thực Khi nào sử dụng UDP? UDP được sử dụng khi:\nCần truyền nhanh Có thể chấp nhận mất gói tin Dữ liệu được gửi liên tục Ví dụ ứng dụng UDP:\nTruyền video, audio trực tuyến Game online thời gian thực Chat broadcast DNS Multicast, streaming UDP Socket trong Java Java hỗ trợ UDP thông qua hai lớp chính:\nDatagramSocket: quản lý socket UDP DatagramPacket: đại diện cho gói dữ liệu UDP UDP không phân biệt client hay server rõ ràng như TCP.\nMỗi chương trình chỉ cần một DatagramSocket để gửi và nhận dữ liệu.\nDatagramPacket là gì? DatagramPacket là gói dữ liệu UDP, bao gồm:\nDữ liệu cần gửi Địa chỉ IP đích Số hiệu cổng Mỗi lần gửi hoặc nhận dữ liệu, UDP làm việc với một DatagramPacket riêng biệt.\nLuồng dữ liệu trong UDP UDP không có luồng InputStream / OutputStream như TCP.\nQuy trình truyền dữ liệu UDP:\nTạo DatagramSocket Tạo DatagramPacket chứa dữ liệu Gửi packet đi Nhận packet về Đọc dữ liệu từ packet Mỗi gói tin là độc lập, không liên quan đến các gói khác.\nĐặc điểm quan trọng của UDP Không kiểm soát lỗi Không kiểm soát luồng Không bắt tay kết nối Gửi nhanh, xử lý đơn giản Phù hợp truyền broadcast và multicast Chính vì vậy, UDP thường được dùng khi tốc độ quan trọng hơn độ chính xác tuyệt đối.\nÝ nghĩa của lập trình Socket UDP Nắm vững UDP giúp bạn:\nHiểu bản chất truyền dữ liệu không kết nối Xây dựng ứng dụng thời gian thực Phân biệt rõ TCP và UDP trong thiết kế hệ thống Chuẩn bị cho các chủ đề nâng cao như: Multicast UDP Java RMI Hệ thống phân tán Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính, UDP được sử dụng trong:\nSocket UDP Multicast Ứng dụng truyền tin nhanh Game, streaming, broadcast Hiểu UDP giúp bạn chọn đúng giao thức cho từng bài toán thực tế.\nKết luận Qua bài học này, bạn đã:\nHiểu UDP là gì và cơ chế hoạt động Phân biệt được TCP và UDP Biết vai trò của DatagramSocket và DatagramPacket Hiểu cách truyền dữ liệu không kết nối Chuẩn bị nền tảng cho bài Multicast UDP \u0026amp; Java RMI tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-6/","summary":"Giải thích giao thức UDP và cách Java lập trình Socket UDP – nền tảng cho truyền dữ liệu nhanh, không kết nối.","title":"Bài 6: Lập trình Socket UDP trong Java"},{"content":"Trong các ứng dụng mạng thực tế, đặc biệt là Server, chương trình thường phải xử lý nhiều yêu cầu cùng lúc.\nNếu chỉ sử dụng một luồng thực thi, server sẽ bị tắc nghẽn, các client phải chờ đợi và hiệu năng giảm nghiêm trọng.\nVì vậy, lập trình đa tuyến (Multithreading) và xử lý đồng thời (Concurrency) là kỹ thuật bắt buộc trong lập trình mạng.\nTuyến (Thread) là gì? Thread là một dòng điều khiển tuần tự bên trong một chương trình.\nMột chương trình (process) có thể chứa nhiều thread Các thread có thể chạy đồng thời Mỗi thread thực hiện một nhiệm vụ riêng Thread không phải là một chương trình độc lập,\nnó luôn thuộc về một process.\nProcess và Thread Process:\nCó không gian bộ nhớ riêng Chạy độc lập với process khác Tạo và chuyển đổi tốn nhiều tài nguyên Thread:\nChia sẻ bộ nhớ với các thread khác trong cùng process Tạo nhanh hơn process Chuyển đổi nhanh hơn Nhờ thread, chương trình có thể thực hiện nhiều công việc cùng lúc trong cùng một ứng dụng.\nVì sao cần lập trình đa tuyến? Lập trình đa tuyến giúp:\nTăng hiệu suất và khả năng đáp ứng Tận dụng thời gian chờ đợi (I/O, mạng, tải file) Chia nhỏ tác vụ và xử lý đồng thời Cải thiện trải nghiệm người dùng Trong lập trình mạng, đa tuyến cho phép server phục vụ nhiều client cùng lúc.\nThực thi Thread trong Java Trong Java, một thread bắt đầu chạy khi gọi phương thức start().\nKhi thread chạy, JVM thực thi mã trong phương thức run() Khi run() kết thúc, thread cũng kết thúc Một thread không thể start lại, muốn chạy lại phải tạo thread mới Thread cần có điều kiện dừng rõ ràng để tránh chạy vô hạn.\nỨng dụng đa tuyến trong lập trình mạng Ứng dụng Chat đa tuyến Một ví dụ tiêu biểu của đa tuyến trong mạng là ứng dụng chat nhiều client – một server.\nĐặc điểm:\nServer chấp nhận nhiều client kết nối cùng lúc Mỗi client được xử lý bởi một thread riêng Tin nhắn từ một client được gửi tới tất cả client khác Server ghi lại nội dung chat vào file log Thông qua ví dụ này, sinh viên hiểu rõ:\nCách server xử lý nhiều kết nối đồng thời Cách phối hợp giữa socket và thread Vai trò của đa tuyến trong ứng dụng mạng Xử lý đồng thời (Concurrency) Xử lý đồng thời xảy ra khi nhiều thread:\nChạy cùng lúc Truy cập tài nguyên chung (biến, file, bộ nhớ) Nếu không kiểm soát tốt, chương trình có thể gặp các vấn đề nghiêm trọng.\nRace Condition Race Condition xảy ra khi:\nNhiều thread cùng truy cập và thay đổi dữ liệu chung Kết quả phụ thuộc vào thứ tự thực thi không xác định Điều này có thể dẫn đến:\nDữ liệu sai lệch Kết quả không nhất quán Lỗi khó phát hiện Đồng bộ hóa (Synchronization) Để tránh race condition, Java cung cấp cơ chế đồng bộ hóa:\nĐảm bảo chỉ một thread được truy cập tài nguyên tại một thời điểm Giữ cho dữ liệu luôn nhất quán Đồng bộ hóa là nền tảng để xây dựng các ứng dụng an toàn và ổn định khi chạy đa tuyến.\nCác vấn đề thường gặp trong xử lý đồng thời Một số vấn đề phổ biến:\nRace condition: tranh chấp dữ liệu Deadlock: các thread chờ nhau vô hạn Livelock: các thread liên tục phản ứng nhưng không tiến triển Starvation: thread không bao giờ được cấp tài nguyên Những vấn đề này khiến lập trình đa tuyến trở nên phức tạp và khó debug.\nLập lịch Thread trong Java Java sử dụng cơ chế lập lịch theo độ ưu tiên:\nMỗi thread có độ ưu tiên từ MIN_PRIORITY đến MAX_PRIORITY JVM chọn thread runnable có độ ưu tiên cao hơn để chạy Thread có thể nhường CPU cho thread khác bằng cách gọi yield() Việc hiểu cơ chế lập lịch giúp lập trình viên thiết kế thread hợp lý hơn.\nÝ nghĩa của lập trình đa tuyến và xử lý đồng thời Nắm vững kiến thức bài này giúp bạn:\nXây dựng server xử lý nhiều client Viết ứng dụng mạng hiệu năng cao Tránh lỗi tranh chấp dữ liệu Chuẩn bị cho các chủ đề nâng cao như: Server đa tuyến Pooling Threads Multicast UDP Java RMI Hệ thống phân tán Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm thread và multithreading Phân biệt process và thread Biết vai trò của đa tuyến trong lập trình mạng Hiểu các vấn đề xử lý đồng thời và race condition Chuẩn bị nền tảng cho các bài học nâng cao tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-7/","summary":"Giải thích lập trình đa tuyến và xử lý đồng thời trong Java – nền tảng cho các ứng dụng mạng nhiều client và hệ thống phân tán.","title":"Bài 7: Lập trình đa tuyến và xử lý đồng thời trong Java"},{"content":"Buổi 8 gồm 2 phần lớn:\nMulticast UDP: gửi dữ liệu từ một nguồn đến nhiều máy nhận cùng lúc (1 → N). Java RMI: gọi phương thức từ xa giữa các ứng dụng Java như gọi hàm bình thường (Remote Method Invocation). Đây là các kỹ thuật thường gặp trong streaming, trò chuyện nhóm, giám sát từ xa và hệ thống phân tán.\n1) UDP Multicast Unicast, Broadcast và Multicast Trong mạng máy tính có 3 kiểu gửi dữ liệu phổ biến:\nUnicast: 1 nguồn → 1 đích\nVí dụ: bạn mở một trang web, server trả dữ liệu cho riêng bạn.\nBroadcast: 1 nguồn → tất cả máy trong mạng nội bộ\nVí dụ: một thông báo phát cho toàn bộ LAN.\nMulticast: 1 nguồn → một nhóm máy đã đăng ký nhận dữ liệu\nVí dụ: server phát stream video cho nhóm người xem cùng lúc.\nMulticast là cách truyền hiệu quả khi nhiều máy cùng cần nhận một nội dung giống nhau.\nTại sao dùng UDP Multicast? UDP Multicast thường được dùng vì:\nHiệu suất cao: gửi 1 lần nhưng nhiều máy nhận → giảm tải mạng và server. Đơn giản, nhanh: UDP là kiểu “gửi và quên”, không phải chờ xác nhận. Tối ưu trong LAN: phù hợp môi trường mạng nội bộ (Local Area Network). Rất hợp streaming: audio/video cần tốc độ và độ trễ thấp hơn là đảm bảo tuyệt đối. Ứng dụng của Multicast Multicast có thể dùng trong:\nTruyền phát multimedia trực tiếp (audio/video streaming) Trò chuyện nhóm, hội thoại nhóm Quảng bá thông tin cấu hình mạng và cập nhật trong hệ thống mạng Game nhiều người chơi (gửi trạng thái game cho nhiều người) Phát thông tin trạng thái/cảnh báo cho nhiều thiết bị Phát tán cập nhật phần mềm trong mạng nội bộ Địa chỉ Multicast IPv4 Trong IPv4:\nClass D là dải địa chỉ dành cho multicast Dải địa chỉ multicast thường gặp: 224.0.0.0 – 239.255.255.255 Một số nhóm multicast hay được nhắc:\n224.0.0.1: tất cả host trong local subnet Multicast Group là gì? Multicast hoạt động theo “nhóm”:\nMột multicast group giống như một kênh. Máy nào muốn nhận dữ liệu phải tham gia nhóm (join group). Khi rời nhóm thì không nhận dữ liệu nữa. Multicast trong Java Java hỗ trợ multicast qua lớp:\njava.net.MulticastSocket (kế thừa từ DatagramSocket) Một số thao tác quan trọng:\njoinGroup(...): tham gia nhóm multicast leaveGroup(...): rời nhóm multicast setTimeToLive(ttl): đặt TTL (thời gian sống của gói tin, qua bao nhiêu router) Quy trình gửi dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket Tham gia nhóm multicast Tạo DatagramPacket chứa dữ liệu + địa chỉ nhóm + port Gửi packet Rời nhóm Ví dụ minh họa (ngắn, chỉ để hiểu):\n1 2 3 4 5 6 7 8 9 10 11 12 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(); socket.joinGroup(group); socket.setTimeToLive(5); byte[] data = \u0026#34;Hello Multicast\u0026#34;.getBytes(); DatagramPacket packet = new DatagramPacket(data, data.length, group, 9876); socket.send(packet); socket.leaveGroup(group); socket.close(); Quy trình nhận dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket lắng nghe trên port Tham gia nhóm multicast Tạo DatagramPacket rỗng để nhận dữ liệu Gọi receive() để chờ gói tin gửi về Đọc dữ liệu từ packet Rời nhóm và đóng socket Ví dụ minh họa (ngắn):\n1 2 3 4 5 6 7 8 9 10 11 12 13 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(9876); socket.joinGroup(group); byte[] buf = new byte[1024]; DatagramPacket packet = new DatagramPacket(buf, buf.length); socket.receive(packet); String msg = new String(packet.getData(), 0, packet.getLength()); System.out.println(\u0026#34;Received: \u0026#34; + msg); socket.leaveGroup(group); socket.close(); 2) Java RMI Java RMI là gì? RMI (Remote Method Invocation) cho phép chương trình Java:\nGọi phương thức của một đối tượng nằm trên máy khác Cảm giác giống như gọi method trong cùng chương trình Nói đơn giản:\nClient gọi: remoteObject.sum(1,2) Server thực thi thật và trả kết quả về cho client RMI giúp che giấu toàn bộ chi tiết mạng phía sau, người lập trình chỉ tập trung vào logic.\nVì sao dùng Java RMI? Java RMI được sử dụng vì:\nTích hợp sẵn trong Java, dễ triển khai nếu cả client và server đều dùng Java Gọi phương thức từ xa đơn giản như gọi hàm thông thường Hỗ trợ dữ liệu phức tạp: đối tượng, mảng, class tự định nghĩa Tự động xử lý giao tiếp mạng thông qua cơ chế stub / skeleton Dựa trên TCP/IP nên tương đối ổn định và tin cậy Hạn chế của Java RMI Một số điểm hạn chế cần lưu ý:\nPhụ thuộc Java: chủ yếu phù hợp Java ↔ Java Thiết kế dịch vụ phức tạp vẫn cần tổ chức tốt (đặc biệt khi dùng callback) Quản lý phiên và kết nối không mạnh như các giải pháp hiện đại Bảo mật cần cấu hình cẩn thận trong môi trường thực tế Ý tưởng kiến trúc RMI (hiểu nhanh) Trong Java RMI có các thành phần chính:\nRemote Interface\nKhai báo các phương thức cho phép gọi từ xa\nServer Implementation\nLớp cài đặt interface, chứa logic xử lý thật\nRMI Registry\nNơi đăng ký service để client tìm thấy server\nClient\nTìm (lookup) service trong registry và gọi phương thức\nCác bước triển khai RMI (tóm tắt) Định nghĩa Remote Interface Cài đặt interface bằng một class server (remote object) Viết chương trình server: tạo object và bind vào registry Viết chương trình client: lookup registry và gọi method Chạy RMI registry, chạy server, sau đó chạy client Ví dụ ứng dụng RMI Một số ví dụ thường gặp:\nTính tổng 2 số từ xa Dịch vụ quản lý tài khoản ATM Dịch vụ giám sát nhiệt độ có callback (server gọi ngược lại client) Bài tập gợi ý theo đúng nội dung buổi 8 BT8.01: Mô phỏng streaming video\n(1 server phát, nhiều client nhận dữ liệu)\nBT8.02: Server quản lý tài khoản ATM bằng RMI\n(thêm user, đăng nhập, gửi/rút tiền, lưu lịch sử giao dịch)\nKết luận Qua bài học này, bạn đã:\nHiểu sự khác nhau giữa Unicast, Broadcast và Multicast Nắm được vì sao Multicast UDP phù hợp cho truyền dữ liệu nhóm và streaming Biết cách Java hỗ trợ multicast qua MulticastSocket Hiểu Java RMI và cơ chế gọi phương thức từ xa Chuẩn bị nền tảng cho các bài ứng dụng mạng phân tán và đồ án học phần ","permalink":"http://localhost:1313/blog/bai-viet-8/","summary":"Giải thích Multicast UDP (gửi 1-n) và Java RMI (gọi phương thức từ xa) – nền tảng cho ứng dụng nhóm và hệ phân tán.","title":"Bài 8: Multicast UDP và Java RMI"},{"content":"Sau khi hoàn thành các bài về TCP, UDP, đa tuyến và xử lý đồng thời,\nchúng ta đã có đủ nền tảng để xây dựng một ứng dụng mạng hoàn chỉnh.\nBài học này giúp bạn xâu chuỗi toàn bộ kiến thức đã học,\nhiểu rõ mỗi công nghệ dùng trong trường hợp nào,\nvà cách thiết kế một hệ thống mạng đúng tư duy kỹ sư.\nNhìn lại các mô hình giao tiếp mạng đã học Trong lập trình mạng, các ứng dụng thường được xây dựng dựa trên mô hình Client – Server.\nClient: gửi yêu cầu, nhập dữ liệu, hiển thị kết quả Server: xử lý logic, quản lý dữ liệu, trả kết quả Tùy bài toán, ta lựa chọn giao thức và mô hình phù hợp.\nSo sánh TCP, UDP và Multicast TCP – Giao tiếp tin cậy TCP phù hợp khi:\nCần đảm bảo dữ liệu đúng và đủ Cần kết nối ổn định, hai chiều Ví dụ: chat, truyền file, game theo lượt, hệ thống ngân hàng Đặc trưng:\nCó bắt tay 3 bước Có kiểm soát lỗi, kiểm soát luồng Tốn tài nguyên hơn UDP UDP – Giao tiếp nhanh, không kết nối UDP phù hợp khi:\nƯu tiên tốc độ Chấp nhận mất gói Ví dụ: game thời gian thực, streaming, cảm biến Đặc trưng:\nKhông kết nối Không đảm bảo thứ tự Ít độ trễ UDP Multicast – Truyền dữ liệu nhóm Multicast được dùng khi:\nMột nguồn → nhiều người nhận Dữ liệu giống nhau cho tất cả client Ví dụ: livestream, thông báo hệ thống, truyền trạng thái Ưu điểm:\nGiảm tải server Tiết kiệm băng thông Phù hợp mạng LAN Vai trò của đa tuyến (Multithreading) Trong thực tế, server không thể xử lý từng client một cách tuần tự.\nĐa tuyến giúp:\nNhiều client kết nối cùng lúc Không client nào bị “đóng băng” Tăng khả năng mở rộng hệ thống Ví dụ:\nServer chat: mỗi client là một thread Server TCP: mỗi socket được xử lý riêng Thiết kế một ứng dụng mạng hoàn chỉnh Khi thiết kế, cần xác định rõ:\nGiao thức: TCP hay UDP? Mô hình: 1–1, 1–n, n–n? Đồng thời hay tuần tự? Client gửi gì? Server xử lý gì? Một thiết kế tốt luôn:\nPhân tách rõ giao tiếp – xử lý – dữ liệu Dễ mở rộng Dễ bảo trì Liên hệ với đồ án học phần Các đồ án như:\nChat đa tuyến Oẳn Tù Tì client–server Streaming UDP Dịch vụ RMI Đều là sự kết hợp của các kiến thức đã học,\nkhông phải nội dung mới.\nKết luận Qua bài học này, bạn đã:\nHệ thống lại toàn bộ kiến thức lập trình mạng Hiểu rõ khi nào dùng TCP, UDP, Multicast Nắm được vai trò của đa tuyến Biết cách tư duy thiết kế một ứng dụng mạng hoàn chỉnh Đây là bước chuẩn bị quan trọng trước khi vận dụng toàn bộ kiến thức vào một hệ thống thực tế.\n","permalink":"http://localhost:1313/blog/bai-viet-9/","summary":"Tổng hợp kiến thức TCP, UDP, đa tuyến và cách thiết kế ứng dụng mạng Client–Server hoàn chỉnh.","title":"Bài 9: Tổng hợp kiến thức \u0026 thiết kế ứng dụng mạng"},{"content":"Bài cuối cùng của học phần không nhằm giới thiệu công nghệ mới,\nmà tập trung vào cách vận dụng kiến thức đã học vào thực tế.\nĐây là giai đoạn chuyển từ:\n“Biết dùng” → “Biết thiết kế” → “Biết đánh giá hệ thống”\nTư duy vận dụng kiến thức Một ứng dụng mạng hoàn chỉnh cần trả lời được các câu hỏi:\nVì sao chọn TCP mà không phải UDP? Vì sao cần đa tuyến? Server có chịu được nhiều client không? Hệ thống có mở rộng được không? Đây chính là tư duy kỹ sư, không phải chỉ “chạy được là xong”.\nĐánh giá một ứng dụng mạng Khi hoàn thiện hệ thống, cần xem xét:\n1. Tính đúng đắn Dữ liệu có truyền đúng không? Có mất gói không? Có xử lý lỗi không? 2. Tính đồng thời Nhiều client có dùng chung được không? Có bị treo server không? Có race condition không? 3. Hiệu năng Độ trễ thế nào? Server có bị quá tải không? Có tách luồng hợp lý không? Liên hệ với các mô hình phân tán Các hệ thống đã học là nền tảng cho:\nHệ thống client–server lớn Ứng dụng phân tán Microservices Cloud services Java RMI, TCP đa tuyến hay UDP Multicast\nđều là những viên gạch đầu tiên.\nTừ học phần đến thực tế Sau học phần này, bạn có thể tiếp cận:\nWebSocket REST API gRPC Message Queue (Kafka, RabbitMQ) Hệ thống realtime Tư duy lập trình mạng không thay đổi, chỉ công nghệ thay đổi.\nTổng kết toàn bộ học phần Qua toàn bộ chuỗi bài, bạn đã:\nHiểu cách dữ liệu đi qua mạng Làm việc với TCP, UDP, Multicast Xử lý đa tuyến và đồng thời Tiếp cận lập trình phân tán với RMI Có tư duy thiết kế hệ thống mạng Lời kết Lập trình mạng không chỉ là code socket,\nmà là hiểu cách các hệ thống nói chuyện với nhau.\nNếu bạn hiểu được điều đó,\nbạn đã vượt xa mức “học để qua môn”.\n","permalink":"http://localhost:1313/blog/bai-viet-10/","summary":"Vận dụng toàn bộ kiến thức lập trình mạng để xây dựng, đánh giá và hoàn thiện một ứng dụng thực tế.","title":"Bài 10: Hoàn thiện \u0026 vận dụng lập trình mạng"},{"content":"Lời mở đầu Có những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\nMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\nHọc tập Những năm đại học trôi qua nhanh hơn mình từng nghĩ. Ngày mới bước chân vào giảng đường, mình vẫn còn khá mơ hồ về ngành học, về tương lai, về chính bản thân mình sẽ trở thành ai sau bốn năm. Nhưng rồi từng môn học, từng bài tập nhóm, từng đồ án kéo mình lại gần hơn với cách một hệ thống được hình thành và vận hành.\nHệ thống thông tin không chỉ là lập trình, cũng không đơn thuần là công nghệ. Đó là câu chuyện về con người, quy trình và dữ liệu. Mình học cách đặt câu hỏi, học cách lắng nghe yêu cầu, học cách vẽ ra những sơ đồ tưởng chừng khô khan nhưng lại chứa rất nhiều suy nghĩ phía sau. Dần dần, mình nhận ra mình thích phần “hiểu vấn đề” hơn là chỉ chăm chăm vào lời giải.\nĐịnh hướng Ở thời điểm hiện tại, mình đang định hướng theo con đường Business Analyst (BA). Mình hứng thú với vai trò đứng giữa – không quá xa kỹ thuật, cũng không tách rời nghiệp vụ. Đó là nơi cần sự rõ ràng trong tư duy, sự kiên nhẫn trong giao tiếp và khả năng chuyển hóa những điều mơ hồ thành thứ có thể triển khai được.\nMình không nghĩ BA là một vị trí “nhẹ nhàng” hay “an toàn”. Ngược lại, đó là công việc đòi hỏi phải học rất nhiều, sai rất nhiều và sửa rất nhiều. Nhưng chính điều đó khiến mình thấy phù hợp. Mình muốn hiểu hệ thống trước khi xây dựng nó, muốn biết vì sao người ta see cần một chức năng, chứ không chỉ là nó được viết như thế nào.\nBlog Blog này ra đời khá tự nhiên, giống như một cuốn sổ mở rộng hơn là một trang thể hiện điều gì đó to tát. Mình viết để nhớ, để hệ thống lại những gì đã học, và đôi khi là để sắp xếp lại suy nghĩ của chính mình.\nỞ đây có thể là kiến thức về Hệ thống thông tin, về phân tích nghiệp vụ, về lập trình, hoặc đơn giản là những trải nghiệm học tập và va chạm trong quá trình làm đồ án, làm việc nhóm, và chuẩn bị bước ra môi trường thực tế. Mình không mong mọi thứ phải hoàn hảo, chỉ mong nó thật và có ích cho ai đó đang đi trên con đường tương tự.\nLời kết Mình đang ở một giai đoạn chưa thể gọi là trưởng thành, nhưng cũng không còn quá non nớt. Vẫn đang học, vẫn đang thử, vẫn đang sai và sửa mỗi ngày. Nếu có một điều mình mong giữ được lâu nhất, thì đó là sự tò mò và tinh thần học hỏi – những thứ giúp mình không đứng yên giữa rất nhiều lựa chọn ngoài kia.\nCảm ơn bạn đã ghé qua và đọc những dòng này. Hy vọng ở một thời điểm nào đó, những chia sẻ nhỏ ở đây sẽ chạm đến bạn – dù chỉ là một chút. \u0026ldquo;Học để chia sẻ, chia sẻ để học nhiều hơn.\u0026rdquo;\nLiên hệ Nếu bạn muốn gửi cho mình vài dòng trao đổi,\nbạn có thể liên hệ với mình qua Email hoặc GitHub ,Facebook dưới đây.\nCảm ơn bạn đã ghé thăm blog! ","permalink":"http://localhost:1313/about/","summary":"\u003ch2 id=\"lời-mở-đầu\"\u003eLời mở đầu\u003c/h2\u003e\n\u003cp\u003eCó những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\u003c/p\u003e\n\u003cp\u003eMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\u003c/p\u003e","title":"Giới thiệu"},{"content":"Trong lập trình mạng, trước khi kết nối, ta phải biết \u0026ldquo;địa chỉ nhà\u0026rdquo; (IP) của mình và đối phương. Java cung cấp class\nHình 1.1: Hiệu ứng Dunning–Kruger – mức độ tự tin thay đổi theo kinh nghiệm học tập\nGóc nhìn học tập: Hiệu ứng Dunning–Kruger InetAddress để làm việc này.\nĐịa chỉ IP là gì trong lập trình mạng? IP (Internet Protocol Address) là địa chỉ định danh của một thiết bị khi tham gia vào mạng máy tính.\nTrong lập trình mạng, IP đóng vai trò quan trọng trong việc:\nXác định máy gửi và máy nhận Định tuyến dữ liệu trong quá trình truyền thông Thiết lập kết nối giữa các tiến trình chạy trên những máy khác nhau Nếu không có địa chỉ IP, các máy tính sẽ không thể nhận biết và giao tiếp với nhau.\nVai trò của lớp InetAddress trong Java Lớp InetAddress đại diện cho một địa chỉ IP trong Java.\nThông qua lớp này, lập trình viên có thể:\nLấy địa chỉ IP của máy đang chạy chương trình Lấy tên máy (hostname) Phân giải tên miền sang địa chỉ IP Chuẩn bị thông tin để tạo Socket hoặc ServerSocket Hầu hết các chương trình lập trình mạng trong Java đều sử dụng InetAddress ở bước khởi tạo.\nPhân tích ý nghĩa các lệnh trong chương trình InetAddress.getLocalHost()\n→ Trả về đối tượng đại diện cho máy cục bộ (localhost).\ngetHostName()\n→ Lấy tên máy do hệ điều hành hoặc mạng gán.\ngetHostAddress()\n→ Lấy địa chỉ IP của máy dưới dạng chuỗi.\nViệc in ra hostname và IP giúp:\nKiểm tra cấu hình mạng Xác định đúng máy khi kết nối Client – Server Debug lỗi mạng Một số lưu ý khi lấy IP trong Java Khi máy không kết nối mạng, IP có thể là 127.0.0.1 Khi máy có nhiều card mạng (WiFi, LAN, VPN), IP trả về có thể không phải IP Internet Trên Server, hostname và IP thường khác máy cá nhân Ứng dụng thực tế Việc xác định IP của máy thường được sử dụng trong:\nChương trình Client – Server Thông báo IP Server cho Client kết nối Kiểm tra kết nối mạng LAN Ghi log và giám sát hệ thống Kết luận Qua bài học này, ta đã:\nHiểu vai trò của địa chỉ IP trong lập trình mạng Biết cách lấy IP bằng lớp InetAddress Chuẩn bị nền tảng cho các kỹ thuật TCP, UDP và RMI Liên hệ với học phần Lập trình Mạng máy tính Bài học này nằm trong nội dung mở đầu của học phần Lập trình Mạng máy tính (CMP180) tại Trường Đại học Công nghệ TP.HCM (HUTECH).\nTrong lộ trình môn học, sinh viên sẽ lần lượt tiếp cận các nội dung:\nKiến thức nền tảng về mạng và lập trình mạng Quản lý luồng nhập xuất (I/O) Quản lý địa chỉ và kết nối mạng Lập trình Socket TCP và UDP Xử lý đa tuyến, đa luồng Multicast UDP và Java RMI Thực hiện đồ án học phần cá nhân Mục tiêu của bài học Thông qua Bài 1, sinh viên sẽ:\nLàm quen với môi trường lập trình mạng bằng Java Hiểu được vai trò của địa chỉ IP trong giao tiếp mạng Biết cách sử dụng lớp InetAddress để lấy IP và hostname Chuẩn bị nền tảng cho các bài học tiếp theo về Socket và Server – Client ","permalink":"http://localhost:1313/blog/bai-viet-1/","summary":"GIỚI THIỆU HỌC PHẦN.","title":"Bài 1: Tổng quan khoá học"},{"content":"Trong lập trình mạng, nếu IP được xem như địa chỉ nhà của một máy tính trong mạng,\nthì Port (cổng) chính là số hiệu dùng để xác định chương trình hoặc dịch vụ cụ thể đang chạy trên máy đó.\nMột máy tính có thể chạy đồng thời nhiều ứng dụng mạng như Web Server, Database Server, Game Server hoặc Chat Server.\nMỗi ứng dụng bắt buộc phải gắn với một Port riêng để hệ điều hành có thể phân biệt và định tuyến dữ liệu chính xác.\nPort nằm ở đâu trong mô hình TCP/IP? Trong bộ giao thức TCP/IP, Port thuộc về Transport Layer (Tầng giao vận) và được sử dụng bởi hai giao thức chính là TCP và UDP.\nĐịa chỉ IP xác định máy nào sẽ nhận dữ liệu Port xác định ứng dụng nào trên máy đó sẽ xử lý dữ liệu Sự kết hợp giữa IP + Port tạo thành một Socket, là điểm cuối (endpoint) của quá trình giao tiếp mạng.\nCác loại Port phổ biến Port được đánh số từ 0 đến 65535 và được chia thành ba nhóm chính:\nInternet và các End Devices Trước khi tìm hiểu về Port, cần hiểu Internet được cấu thành từ hàng tỷ thiết bị đầu cuối (End Devices) như máy tính, điện thoại, máy chủ và các thiết bị IoT.\nCác thiết bị này kết nối với nhau thông qua nhiều lớp mạng khác nhau, và mỗi thiết bị khi tham gia giao tiếp mạng đều cần có địa chỉ IP và Port để định danh. Hình 2.1: Sơ đồ minh họa Internet và các thiết bị đầu cuối (End Devices) kết nối thông qua các mạng truy cập và mạng lõi.\nTrong quá trình giao tiếp mạng, một thiết bị không chỉ cần địa chỉ IP để xác định vị trí trong mạng, mà còn cần Port để xác định chính xác ứng dụng hoặc dịch vụ đang lắng nghe trên thiết bị đó.\nDo đó, Port đóng vai trò như “điểm tiếp nhận” (endpoint) cho các tiến trình mạng chạy trên cùng một máy.\nMô hình các tầng giao thức TCP/IP Để hiểu rõ Port hoạt động ở đâu và vì sao Server cần Port, ta cần nắm được mô hình giao thức TCP/IP – nền tảng của mọi ứng dụng mạng hiện nay.\nHình 2.2: Mô hình các tầng giao thức TCP/IP và các giao thức tiêu biểu tương ứng với từng tầng.\nTrong mô hình TCP/IP, địa chỉ IP hoạt động ở tầng Internet, giúp xác định thiết bị trong mạng.\nTrong khi đó, Port hoạt động ở tầng Transport (TCP/UDP), giúp xác định chính xác ứng dụng hoặc dịch vụ đang giao tiếp trên thiết bị đó.\nWell-known Ports (0 – 1023) Được dùng cho các dịch vụ chuẩn:\nPort 80: HTTP Port 443: HTTPS Port 21: FTP Port 25: SMTP Registered Ports (1024 – 49151) Thường dùng cho các ứng dụng phổ biến:\nPort 3306: MySQL Port 8080: Web Server thay thế port 80 Dynamic / Private Ports (49152 – 65535) Do hệ điều hành cấp phát tạm thời cho Client khi giao tiếp mạng.\nVì sao Server thường dùng cổng 8080? Cổng 8080 rất phổ biến trong quá trình phát triển và học tập vì:\nTránh xung đột với cổng 80 đang được hệ điều hành chiếm dụng Không cần quyền Administrator khi mở Server Phù hợp cho các Web Server thử nghiệm như: Apache Tomcat Spring Boot Node.js Lỗi thường gặp: “Address already in use” Lỗi này xảy ra khi Server cố gắng mở một Port đã bị chương trình khác chiếm dụng.\nNguyên nhân phổ biến:\nServer cũ chưa được tắt Port đang được dùng bởi dịch vụ khác Chạy nhiều Server cùng lúc Cách khắc phục:\nĐổi sang Port khác (ví dụ: 8080 → 9090) Kiểm tra Port đang sử dụng trong hệ điều hành Đảm bảo chỉ có một Server chạy tại một thời điểm Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), khái niệm Port sẽ được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Xây dựng mô hình Client – Server Java RMI và Multicast Việc hiểu rõ Port là nền tảng bắt buộc trước khi triển khai các ứng dụng mạng thực tế.\nKết luận Qua bài học này, ta đã:\nHiểu được Port là gì và vai trò của Port trong lập trình mạng Nắm được mối quan hệ giữa IP, Port và Socket Giải thích được lý do Server thường sử dụng cổng 8080 Chuẩn bị kiến thức nền cho các bài học tiếp theo về TCP và UDP ","permalink":"http://localhost:1313/blog/bai-viet-2/","summary":"MẠNG MÁY TÍNH \u0026amp; INTERNET.","title":"Bài 2: Kiến thức nền tảng?"},{"content":"Trong lập trình Java, luồng nhập xuất (Input / Output Streams) đóng vai trò trung gian giúp chương trình đọc và ghi dữ liệu từ nhiều nguồn khác nhau như bàn phím, file, console, bộ nhớ và sau này là socket mạng.\nHiểu rõ cơ chế luồng nhập xuất là bước nền bắt buộc trước khi đi vào lập trình Socket TCP, UDP hay Java RMI.\nLuồng (Stream) là gì? Luồng (Stream) là dòng dữ liệu di chuyển\ntừ nguồn → chương trình hoặc từ chương trình → đích.\nKhi Java đọc hoặc ghi dữ liệu, dữ liệu không đi trực tiếp mà luôn được đóng gói và truyền qua luồng.\nLuồng nhập xuất là gì? Luồng nhập xuất là cơ chế cho phép chương trình:\nNhận dữ liệu từ bên ngoài (Input) Ghi dữ liệu ra bên ngoài (Output) Luồng có thể kết nối với nhiều nguồn và đích khác nhau:\nFile Bàn phím Màn hình (console) Bộ nhớ Kết nối mạng (TCP / UDP) Dữ liệu trong luồng tồn tại dưới những dạng nào? Trong Java, dữ liệu trong luồng tồn tại dưới hai dạng chính:\nLuồng byte Luồng ký tự Việc chọn đúng loại luồng ảnh hưởng trực tiếp đến hiệu năng và tính chính xác của chương trình.\nLuồng byte trong Java Đặc điểm Dữ liệu được xử lý dưới dạng nhị phân Phù hợp với: File nhị phân Ảnh, video Socket mạng Dữ liệu phức tạp Các lớp gốc InputStream – luồng đọc byte OutputStream – luồng ghi byte Cả hai đều là lớp trừu tượng (abstract).\nCác luồng byte đọc phổ biến FileInputStream – đọc byte từ file ByteArrayInputStream – đọc từ mảng byte PipedInputStream – đọc từ luồng pipe Các luồng byte ghi phổ biến FileOutputStream – ghi byte vào file ByteArrayOutputStream – ghi vào mảng byte PipedOutputStream – ghi vào luồng pipe Mô hình đọc/ghi dữ liệu với Stream Quy trình chung khi làm việc với luồng:\nTạo đối tượng Stream Gắn Stream với nguồn hoặc đích Đọc/ghi dữ liệu trong vòng lặp Đóng Stream sau khi hoàn tất Luồng ký tự trong Java Đặc điểm Xử lý dữ liệu dạng Unicode Phù hợp với: File văn bản Chuỗi Dữ liệu hiển thị cho người dùng Các lớp gốc Reader – luồng đọc ký tự Writer – luồng ghi ký tự Các luồng ký tự đọc phổ biến FileReader – đọc file văn bản BufferedReader – đọc có bộ đệm StringReader – đọc chuỗi CharArrayReader – đọc mảng ký tự Các luồng ký tự ghi phổ biến FileWriter – ghi vào file văn bản BufferedWriter – ghi có bộ đệm PrintWriter – ghi dữ liệu dạng dễ đọc StringWriter – ghi chuỗi Luồng lọc dữ liệu (Filtered Streams) Luồng lọc dùng để chuyển đổi dữ liệu từ dạng byte/ký tự sang các kiểu dữ liệu khác.\nCác luồng lọc phổ biến DataInputStream DataOutputStream Cho phép đọc/ghi các kiểu dữ liệu nguyên thủy:\nint float double boolean char Đây là cầu nối giữa luồng thô và dữ liệu có kiểu trong Java.\nLưu trạng thái đối tượng – Serialization Serialization là gì? Serialization (chuỗi hóa) là quá trình chuyển đối tượng Java thành luồng byte để:\nLưu vào file Truyền qua mạng Phục hồi lại sau này Deserialization Ngược lại, Deserialization (giải chuỗi) là quá trình:\nĐọc byte Tái tạo lại đối tượng ban đầu Đây là nền tảng cho:\nLưu dữ liệu chương trình Java RMI Truyền object qua mạng Try-with-resources (TWR) Java hỗ trợ Try-with-resources để:\nTự động đóng stream Tránh rò rỉ tài nguyên Code gọn và an toàn hơn So với try-catch truyền thống, TWR:\nÍt lỗi hơn Dễ bảo trì hơn Được khuyến khích sử dụng Các lỗi I/O thường gặp Khi làm việc với luồng, một số exception phổ biến là:\nFileNotFoundException IOException EOFException UnsupportedEncodingException FileAlreadyExistsException AccessDeniedException SocketException MalformedURLException SerializationException InvalidPathException Việc bắt và xử lý exception đúng cách là yêu cầu bắt buộc trong lập trình Java.\nLiên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), luồng nhập xuất được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Truyền dữ liệu Client – Server Java RMI Multicast UDP Không hiểu I/O Stream → không thể làm mạng đúng cách.\nKết luận Qua bài học này, ta đã:\nHiểu khái niệm luồng nhập xuất trong Java Phân biệt luồng byte và luồng ký tự Nắm được cách đọc/ghi dữ liệu với Stream Biết vai trò của Serialization và Filtered Streams Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo Khi xử lý các tác vụ mạng (như gọi API), người mới học JS hay viết code lồng nhau kiểu này:\n1 2 3 4 5 6 7 8 9 10 // Cực hình Callback Hell getData(function(a) { getMoreData(a, function(b) { getMoreData(b, function(c) { getMoreData(c, function(d) { console.log(d); }); }); }); }); ","permalink":"http://localhost:1313/blog/bai-viet-3/","summary":"Tổng quan về Input/Output Streams trong Java – nền tảng cho xử lý file, console và lập trình mạng.","title":"Bài 3: Quản lý luồng nhập xuất trong Java"},{"content":"Trong lập trình mạng, trước khi chương trình có thể gửi hoặc nhận dữ liệu, điều quan trọng nhất là xác định đúng địa chỉ kết nối mạng. Nếu xác định sai địa chỉ, chương trình sẽ không thể giao tiếp, dù phần xử lý dữ liệu có đúng đến đâu.\nBài học này giúp bạn hiểu cách Java làm việc với địa chỉ IP, tên miền (DNS) và URL. Đây là nền tảng bắt buộc trước khi đi vào Socket TCP, UDP, Web Crawler và Java RMI.\nĐịa chỉ kết nối mạng là gì? Địa chỉ kết nối mạng là thông tin dùng để xác định máy nào trong mạng cần giao tiếp và dịch vụ nào trên máy đó sẽ xử lý dữ liệu.\nTrong Internet, địa chỉ kết nối thường bao gồm:\nĐịa chỉ IP Tên miền (Domain Name) Cổng (Port) Giao thức (Protocol) DNS – Domain Name System Hình 4.1 – Mô hình hoạt động của DNS (Domain Name System)\nClient gửi yêu cầu phân giải tên miền đến DNS Server, DNS trả về địa chỉ IP tương ứng để client kết nối đến server đích.*\nCon người dễ nhớ tên miền hơn các dãy số IP.\nDNS (Domain Name System) có nhiệm vụ ánh xạ tên miền sang địa chỉ IP, giúp client tìm đúng server cần kết nối.\nVí dụ:\ngoogle.com tương ứng với nhiều địa chỉ IP khác nhau www.cs.yale.edu tương ứng với 128.36.229.30 Nhờ DNS, người dùng không cần ghi nhớ địa chỉ IP khi truy cập Internet. *Hình 4.2 minh họa cấu trúc phân cấp của hệ thống DNS, bao gồm Root Domain, các Top-Level Domain (com, edu, org, vn, …) và các tên miền con phía dưới.\nCấu trúc phân cấp này giúp DNS hoạt động hiệu quả và dễ mở rộng trên toàn Internet.*\nĐịa chỉ IPv4 IPv4 là dạng địa chỉ phổ biến, gồm 32 bit, thường được viết thành bốn nhóm số.\nVí dụ:\n192.168.1.1 8.8.8.8 Một số dải địa chỉ đặc biệt:\n127.x.x.x là loopback (localhost) 224.0.0.0 – 239.255.255.255 là multicast Lớp InetAddress trong Java Java cung cấp lớp InetAddress để làm việc với địa chỉ IP và DNS.\nLớp này thường được dùng để:\nPhân giải tên miền sang IP Kiểm tra loại địa chỉ Kiểm tra khả năng kết nối mạng Ví dụ minh họa:\n1 InetAddress address = InetAddress.getByName(\u0026#34;google.com\u0026#34;); URL – Uniform Resource Locator URL được dùng để xác định tài nguyên trên Internet như trang web, file hoặc dịch vụ.\nMột URL đầy đủ thường bao gồm các thành phần sau:\nGiao thức (Protocol) Tên miền (Host) Cổng (Port) Đường dẫn (Path) Chuỗi truy vấn (Query) Ví dụ một URL đầy đủ: https://www.hutech.edu.vn/admission?id=123\nURL cho biết lấy dữ liệu ở đâu và bằng cách nào.\nLớp URL trong Java Lớp URL cho phép chương trình Java:\nPhân tích các thành phần của URL Kết nối tới server Đọc dữ liệu từ Internet Ví dụ minh họa:\n1 URL url = new URL(\u0026#34;https://www.example.com\u0026#34;); Ý nghĩa của việc quản lý địa chỉ kết nối mạng Hiểu rõ cách quản lý địa chỉ mạng giúp:\nTránh kết nối sai server Chuẩn bị đúng địa chỉ cho Socket TCP/UDP Hiểu cách Web Crawler hoạt động Nắm vững mô hình Client – Server Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm địa chỉ kết nối mạng Biết vai trò của DNS và IPv4 Nắm được cách Java làm việc với InetAddress Hiểu cấu trúc và vai trò của URL Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-4/","summary":"Tìm hiểu cách Java quản lý địa chỉ mạng thông qua InetAddress, URL, URLConnection và DNS.","title":"Bài 4: Quản lý địa chỉ kết nối mạng trong Java"},{"content":"Trong lập trình mạng, TCP Socket là cơ chế quan trọng nhất để xây dựng các ứng dụng Client – Server có độ tin cậy cao.\nBài học này giúp bạn hiểu TCP là gì, vì sao cần TCP, và cách Java triển khai TCP thông qua Socket và ServerSocket.\nĐây là bước chuyển tiếp trực tiếp từ kiến thức địa chỉ mạng (IP, DNS, URL) sang giao tiếp dữ liệu thực tế giữa các chương trình.\nTCP là gì? TCP (Transmission Control Protocol) là giao thức truyền thông hướng kết nối, đảm bảo dữ liệu được truyền:\nĐúng thứ tự Đầy đủ Không bị mất mát Không bị trùng lặp Trước khi truyền dữ liệu, TCP yêu cầu thiết lập kết nối giữa hai bên, và chỉ khi kết nối thành công thì dữ liệu mới được trao đổi.\nVì sao sử dụng TCP? TCP được sử dụng khi ứng dụng yêu cầu độ tin cậy cao, ví dụ:\nỨng dụng chat Ứng dụng client–server Truyền file Game online theo lượt Hệ thống ngân hàng, thương mại điện tử TCP cung cấp các cơ chế quan trọng:\nĐảm bảo dữ liệu: gói tin bị mất sẽ được gửi lại Kiểm soát lỗi: phát hiện và sửa lỗi trong quá trình truyền Kiểm soát luồng: tránh làm quá tải phía nhận Giao tiếp hai chiều: cho phép gửi và nhận dữ liệu đồng thời Cơ chế hoạt động của TCP Quá trình giao tiếp TCP gồm ba giai đoạn chính:\nThiết lập kết nối (Bắt tay 3 bước – Three-way Handshake) Truyền dữ liệu Giải phóng kết nối Nhờ cơ chế này, TCP đảm bảo rằng hai bên luôn sẵn sàng trước khi truyền và kết thúc an toàn sau khi hoàn tất.\nMô hình Client – Server Các ứng dụng TCP thường hoạt động theo mô hình Client – Server.\nServer:\nChạy trước Lắng nghe yêu cầu kết nối Cung cấp dịch vụ Trả kết quả cho client Client:\nChạy sau Chủ động kết nối tới server Gửi yêu cầu Nhận phản hồi từ server Quá trình giao tiếp gồm:\nClient gửi yêu cầu Server xử lý Server trả kết quả cho client Socket trong Java Trong Java, Socket đại diện cho điểm cuối giao tiếp giữa client và server khi sử dụng TCP.\nSocket cho phép:\nGửi dữ liệu tới server Nhận dữ liệu từ server Giao tiếp hai chiều thông qua luồng nhập/xuất Ví dụ minh họa tạo Socket phía client:\n1 Socket socket = new Socket(\u0026#34;localhost\u0026#34;, 8080); ServerSocket trong Java ServerSocket được sử dụng ở phía server để:\nMở một cổng lắng nghe Chờ client kết nối Chấp nhận kết nối và tạo Socket giao tiếp ServerSocket đóng vai trò như cửa ngõ, cho phép các client kết nối vào server.\nVí dụ minh họa:\n1 ServerSocket server = new ServerSocket(8080); Luồng dữ liệu trong TCP Socket Sau khi kết nối TCP được thiết lập, client và server trao đổi dữ liệu thông qua các luồng:\nInputStream: dùng để đọc dữ liệu từ socket OutputStream: dùng để ghi dữ liệu vào socket Luồng dữ liệu này hoạt động tương tự như I/O Stream đã học ở bài trước,\nnhưng nguồn và đích là mạng thay vì file hay bàn phím.\nVí dụ ứng dụng: Trò chơi Oẳn Tù Tì Một bài tập tiêu biểu sử dụng TCP Socket là trò chơi Oẳn Tù Tì theo mô hình Client – Server.\nĐặc điểm Server quản lý luật chơi và điểm số Hai client gửi lựa chọn (kéo – búa – bao) Server xác định kết quả và gửi lại cho client Dữ liệu được truyền qua TCP để đảm bảo chính xác Thông qua bài tập này, sinh viên hiểu rõ:\nCách thiết lập kết nối TCP Cách trao đổi dữ liệu giữa nhiều client Cách xử lý lỗi mạng và ngoại lệ Ý nghĩa của lập trình TCP Socket Việc nắm vững TCP Socket giúp bạn:\nHiểu bản chất giao tiếp mạng Xây dựng hệ thống Client – Server thực tế Chuẩn bị cho các bài nâng cao như: Đa tuyến (Multi-thread) Socket UDP Java RMI Ứng dụng mạng phân tán Kết luận Qua bài học này, bạn đã:\nHiểu TCP là gì và vì sao cần TCP Nắm được mô hình Client – Server Biết vai trò của Socket và ServerSocket trong Java Hiểu cách dữ liệu được truyền qua TCP Chuẩn bị nền tảng cho các bài học UDP và xử lý đồng thời tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-5/","summary":"Giải thích mô hình Client–Server và cách lập trình Socket TCP trong Java – nền tảng cho giao tiếp mạng tin cậy.","title":"Bài 5: Lập trình Socket TCP trong Java"},{"content":"#Trong lập trình mạng, không phải lúc nào ứng dụng cũng cần độ tin cậy tuyệt đối như TCP.\nTrong nhiều trường hợp, điều quan trọng hơn là tốc độ truyền nhanh và độ trễ thấp.\nBài học này giới thiệu UDP Socket – cơ chế truyền dữ liệu không kết nối, được sử dụng rộng rãi trong các ứng dụng thời gian thực.\nUDP là gì? UDP (User Datagram Protocol) là giao thức truyền thông không hướng kết nối.\nĐiều này có nghĩa là:\nKhông thiết lập kết nối trước khi truyền Không đảm bảo dữ liệu đến nơi Không đảm bảo thứ tự gói tin Không tự động gửi lại gói tin bị mất UDP gửi dữ liệu theo từng datagram (gói tin độc lập).\nSo sánh TCP và UDP TCP UDP Có kết nối Không kết nối Đảm bảo dữ liệu Không đảm bảo Truyền theo luồng Truyền theo gói Độ trễ cao hơn Độ trễ thấp Phù hợp dữ liệu quan trọng Phù hợp dữ liệu thời gian thực Khi nào sử dụng UDP? UDP được sử dụng khi:\nCần truyền nhanh Có thể chấp nhận mất gói tin Dữ liệu được gửi liên tục Ví dụ ứng dụng UDP:\nTruyền video, audio trực tuyến Game online thời gian thực Chat broadcast DNS Multicast, streaming UDP Socket trong Java Java hỗ trợ UDP thông qua hai lớp chính:\nDatagramSocket: quản lý socket UDP DatagramPacket: đại diện cho gói dữ liệu UDP UDP không phân biệt client hay server rõ ràng như TCP.\nMỗi chương trình chỉ cần một DatagramSocket để gửi và nhận dữ liệu.\nDatagramPacket là gì? DatagramPacket là gói dữ liệu UDP, bao gồm:\nDữ liệu cần gửi Địa chỉ IP đích Số hiệu cổng Mỗi lần gửi hoặc nhận dữ liệu, UDP làm việc với một DatagramPacket riêng biệt.\nLuồng dữ liệu trong UDP UDP không có luồng InputStream / OutputStream như TCP.\nQuy trình truyền dữ liệu UDP:\nTạo DatagramSocket Tạo DatagramPacket chứa dữ liệu Gửi packet đi Nhận packet về Đọc dữ liệu từ packet Mỗi gói tin là độc lập, không liên quan đến các gói khác.\nĐặc điểm quan trọng của UDP Không kiểm soát lỗi Không kiểm soát luồng Không bắt tay kết nối Gửi nhanh, xử lý đơn giản Phù hợp truyền broadcast và multicast Chính vì vậy, UDP thường được dùng khi tốc độ quan trọng hơn độ chính xác tuyệt đối.\nÝ nghĩa của lập trình Socket UDP Nắm vững UDP giúp bạn:\nHiểu bản chất truyền dữ liệu không kết nối Xây dựng ứng dụng thời gian thực Phân biệt rõ TCP và UDP trong thiết kế hệ thống Chuẩn bị cho các chủ đề nâng cao như: Multicast UDP Java RMI Hệ thống phân tán Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính, UDP được sử dụng trong:\nSocket UDP Multicast Ứng dụng truyền tin nhanh Game, streaming, broadcast Hiểu UDP giúp bạn chọn đúng giao thức cho từng bài toán thực tế.\nKết luận Qua bài học này, bạn đã:\nHiểu UDP là gì và cơ chế hoạt động Phân biệt được TCP và UDP Biết vai trò của DatagramSocket và DatagramPacket Hiểu cách truyền dữ liệu không kết nối Chuẩn bị nền tảng cho bài Multicast UDP \u0026amp; Java RMI tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-6/","summary":"Giải thích giao thức UDP và cách Java lập trình Socket UDP – nền tảng cho truyền dữ liệu nhanh, không kết nối.","title":"Bài 6: Lập trình Socket UDP trong Java"},{"content":"Trong các ứng dụng mạng thực tế, đặc biệt là Server, chương trình thường phải xử lý nhiều yêu cầu cùng lúc.\nNếu chỉ sử dụng một luồng thực thi, server sẽ bị tắc nghẽn, các client phải chờ đợi và hiệu năng giảm nghiêm trọng.\nVì vậy, lập trình đa tuyến (Multithreading) và xử lý đồng thời (Concurrency) là kỹ thuật bắt buộc trong lập trình mạng.\nTuyến (Thread) là gì? Thread là một dòng điều khiển tuần tự bên trong một chương trình.\nMột chương trình (process) có thể chứa nhiều thread Các thread có thể chạy đồng thời Mỗi thread thực hiện một nhiệm vụ riêng Thread không phải là một chương trình độc lập,\nnó luôn thuộc về một process.\nProcess và Thread Process:\nCó không gian bộ nhớ riêng Chạy độc lập với process khác Tạo và chuyển đổi tốn nhiều tài nguyên Thread:\nChia sẻ bộ nhớ với các thread khác trong cùng process Tạo nhanh hơn process Chuyển đổi nhanh hơn Nhờ thread, chương trình có thể thực hiện nhiều công việc cùng lúc trong cùng một ứng dụng.\nVì sao cần lập trình đa tuyến? Lập trình đa tuyến giúp:\nTăng hiệu suất và khả năng đáp ứng Tận dụng thời gian chờ đợi (I/O, mạng, tải file) Chia nhỏ tác vụ và xử lý đồng thời Cải thiện trải nghiệm người dùng Trong lập trình mạng, đa tuyến cho phép server phục vụ nhiều client cùng lúc.\nThực thi Thread trong Java Trong Java, một thread bắt đầu chạy khi gọi phương thức start().\nKhi thread chạy, JVM thực thi mã trong phương thức run() Khi run() kết thúc, thread cũng kết thúc Một thread không thể start lại, muốn chạy lại phải tạo thread mới Thread cần có điều kiện dừng rõ ràng để tránh chạy vô hạn.\nỨng dụng đa tuyến trong lập trình mạng Ứng dụng Chat đa tuyến Một ví dụ tiêu biểu của đa tuyến trong mạng là ứng dụng chat nhiều client – một server.\nĐặc điểm:\nServer chấp nhận nhiều client kết nối cùng lúc Mỗi client được xử lý bởi một thread riêng Tin nhắn từ một client được gửi tới tất cả client khác Server ghi lại nội dung chat vào file log Thông qua ví dụ này, sinh viên hiểu rõ:\nCách server xử lý nhiều kết nối đồng thời Cách phối hợp giữa socket và thread Vai trò của đa tuyến trong ứng dụng mạng Xử lý đồng thời (Concurrency) Xử lý đồng thời xảy ra khi nhiều thread:\nChạy cùng lúc Truy cập tài nguyên chung (biến, file, bộ nhớ) Nếu không kiểm soát tốt, chương trình có thể gặp các vấn đề nghiêm trọng.\nRace Condition Race Condition xảy ra khi:\nNhiều thread cùng truy cập và thay đổi dữ liệu chung Kết quả phụ thuộc vào thứ tự thực thi không xác định Điều này có thể dẫn đến:\nDữ liệu sai lệch Kết quả không nhất quán Lỗi khó phát hiện Đồng bộ hóa (Synchronization) Để tránh race condition, Java cung cấp cơ chế đồng bộ hóa:\nĐảm bảo chỉ một thread được truy cập tài nguyên tại một thời điểm Giữ cho dữ liệu luôn nhất quán Đồng bộ hóa là nền tảng để xây dựng các ứng dụng an toàn và ổn định khi chạy đa tuyến.\nCác vấn đề thường gặp trong xử lý đồng thời Một số vấn đề phổ biến:\nRace condition: tranh chấp dữ liệu Deadlock: các thread chờ nhau vô hạn Livelock: các thread liên tục phản ứng nhưng không tiến triển Starvation: thread không bao giờ được cấp tài nguyên Những vấn đề này khiến lập trình đa tuyến trở nên phức tạp và khó debug.\nLập lịch Thread trong Java Java sử dụng cơ chế lập lịch theo độ ưu tiên:\nMỗi thread có độ ưu tiên từ MIN_PRIORITY đến MAX_PRIORITY JVM chọn thread runnable có độ ưu tiên cao hơn để chạy Thread có thể nhường CPU cho thread khác bằng cách gọi yield() Việc hiểu cơ chế lập lịch giúp lập trình viên thiết kế thread hợp lý hơn.\nÝ nghĩa của lập trình đa tuyến và xử lý đồng thời Nắm vững kiến thức bài này giúp bạn:\nXây dựng server xử lý nhiều client Viết ứng dụng mạng hiệu năng cao Tránh lỗi tranh chấp dữ liệu Chuẩn bị cho các chủ đề nâng cao như: Server đa tuyến Pooling Threads Multicast UDP Java RMI Hệ thống phân tán Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm thread và multithreading Phân biệt process và thread Biết vai trò của đa tuyến trong lập trình mạng Hiểu các vấn đề xử lý đồng thời và race condition Chuẩn bị nền tảng cho các bài học nâng cao tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-7/","summary":"Giải thích lập trình đa tuyến và xử lý đồng thời trong Java – nền tảng cho các ứng dụng mạng nhiều client và hệ thống phân tán.","title":"Bài 7: Lập trình đa tuyến và xử lý đồng thời trong Java"},{"content":"Buổi 8 gồm 2 phần lớn:\nMulticast UDP: gửi dữ liệu từ một nguồn đến nhiều máy nhận cùng lúc (1 → N). Java RMI: gọi phương thức từ xa giữa các ứng dụng Java như gọi hàm bình thường (Remote Method Invocation). Đây là các kỹ thuật thường gặp trong streaming, trò chuyện nhóm, giám sát từ xa và hệ thống phân tán.\n1) UDP Multicast Unicast, Broadcast và Multicast Trong mạng máy tính có 3 kiểu gửi dữ liệu phổ biến:\nUnicast: 1 nguồn → 1 đích\nVí dụ: bạn mở một trang web, server trả dữ liệu cho riêng bạn.\nBroadcast: 1 nguồn → tất cả máy trong mạng nội bộ\nVí dụ: một thông báo phát cho toàn bộ LAN.\nMulticast: 1 nguồn → một nhóm máy đã đăng ký nhận dữ liệu\nVí dụ: server phát stream video cho nhóm người xem cùng lúc.\nMulticast là cách truyền hiệu quả khi nhiều máy cùng cần nhận một nội dung giống nhau.\nTại sao dùng UDP Multicast? UDP Multicast thường được dùng vì:\nHiệu suất cao: gửi 1 lần nhưng nhiều máy nhận → giảm tải mạng và server. Đơn giản, nhanh: UDP là kiểu “gửi và quên”, không phải chờ xác nhận. Tối ưu trong LAN: phù hợp môi trường mạng nội bộ (Local Area Network). Rất hợp streaming: audio/video cần tốc độ và độ trễ thấp hơn là đảm bảo tuyệt đối. Ứng dụng của Multicast Multicast có thể dùng trong:\nTruyền phát multimedia trực tiếp (audio/video streaming) Trò chuyện nhóm, hội thoại nhóm Quảng bá thông tin cấu hình mạng và cập nhật trong hệ thống mạng Game nhiều người chơi (gửi trạng thái game cho nhiều người) Phát thông tin trạng thái/cảnh báo cho nhiều thiết bị Phát tán cập nhật phần mềm trong mạng nội bộ Địa chỉ Multicast IPv4 Trong IPv4:\nClass D là dải địa chỉ dành cho multicast Dải địa chỉ multicast thường gặp: 224.0.0.0 – 239.255.255.255 Một số nhóm multicast hay được nhắc:\n224.0.0.1: tất cả host trong local subnet Multicast Group là gì? Multicast hoạt động theo “nhóm”:\nMột multicast group giống như một kênh. Máy nào muốn nhận dữ liệu phải tham gia nhóm (join group). Khi rời nhóm thì không nhận dữ liệu nữa. Multicast trong Java Java hỗ trợ multicast qua lớp:\njava.net.MulticastSocket (kế thừa từ DatagramSocket) Một số thao tác quan trọng:\njoinGroup(...): tham gia nhóm multicast leaveGroup(...): rời nhóm multicast setTimeToLive(ttl): đặt TTL (thời gian sống của gói tin, qua bao nhiêu router) Quy trình gửi dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket Tham gia nhóm multicast Tạo DatagramPacket chứa dữ liệu + địa chỉ nhóm + port Gửi packet Rời nhóm Ví dụ minh họa (ngắn, chỉ để hiểu):\n1 2 3 4 5 6 7 8 9 10 11 12 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(); socket.joinGroup(group); socket.setTimeToLive(5); byte[] data = \u0026#34;Hello Multicast\u0026#34;.getBytes(); DatagramPacket packet = new DatagramPacket(data, data.length, group, 9876); socket.send(packet); socket.leaveGroup(group); socket.close(); Quy trình nhận dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket lắng nghe trên port Tham gia nhóm multicast Tạo DatagramPacket rỗng để nhận dữ liệu Gọi receive() để chờ gói tin gửi về Đọc dữ liệu từ packet Rời nhóm và đóng socket Ví dụ minh họa (ngắn):\n1 2 3 4 5 6 7 8 9 10 11 12 13 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(9876); socket.joinGroup(group); byte[] buf = new byte[1024]; DatagramPacket packet = new DatagramPacket(buf, buf.length); socket.receive(packet); String msg = new String(packet.getData(), 0, packet.getLength()); System.out.println(\u0026#34;Received: \u0026#34; + msg); socket.leaveGroup(group); socket.close(); 2) Java RMI Java RMI là gì? RMI (Remote Method Invocation) cho phép chương trình Java:\nGọi phương thức của một đối tượng nằm trên máy khác Cảm giác giống như gọi method trong cùng chương trình Nói đơn giản:\nClient gọi: remoteObject.sum(1,2) Server thực thi thật và trả kết quả về cho client RMI giúp che giấu toàn bộ chi tiết mạng phía sau, người lập trình chỉ tập trung vào logic.\nVì sao dùng Java RMI? Java RMI được sử dụng vì:\nTích hợp sẵn trong Java, dễ triển khai nếu cả client và server đều dùng Java Gọi phương thức từ xa đơn giản như gọi hàm thông thường Hỗ trợ dữ liệu phức tạp: đối tượng, mảng, class tự định nghĩa Tự động xử lý giao tiếp mạng thông qua cơ chế stub / skeleton Dựa trên TCP/IP nên tương đối ổn định và tin cậy Hạn chế của Java RMI Một số điểm hạn chế cần lưu ý:\nPhụ thuộc Java: chủ yếu phù hợp Java ↔ Java Thiết kế dịch vụ phức tạp vẫn cần tổ chức tốt (đặc biệt khi dùng callback) Quản lý phiên và kết nối không mạnh như các giải pháp hiện đại Bảo mật cần cấu hình cẩn thận trong môi trường thực tế Ý tưởng kiến trúc RMI (hiểu nhanh) Trong Java RMI có các thành phần chính:\nRemote Interface\nKhai báo các phương thức cho phép gọi từ xa\nServer Implementation\nLớp cài đặt interface, chứa logic xử lý thật\nRMI Registry\nNơi đăng ký service để client tìm thấy server\nClient\nTìm (lookup) service trong registry và gọi phương thức\nCác bước triển khai RMI (tóm tắt) Định nghĩa Remote Interface Cài đặt interface bằng một class server (remote object) Viết chương trình server: tạo object và bind vào registry Viết chương trình client: lookup registry và gọi method Chạy RMI registry, chạy server, sau đó chạy client Ví dụ ứng dụng RMI Một số ví dụ thường gặp:\nTính tổng 2 số từ xa Dịch vụ quản lý tài khoản ATM Dịch vụ giám sát nhiệt độ có callback (server gọi ngược lại client) Bài tập gợi ý theo đúng nội dung buổi 8 BT8.01: Mô phỏng streaming video\n(1 server phát, nhiều client nhận dữ liệu)\nBT8.02: Server quản lý tài khoản ATM bằng RMI\n(thêm user, đăng nhập, gửi/rút tiền, lưu lịch sử giao dịch)\nKết luận Qua bài học này, bạn đã:\nHiểu sự khác nhau giữa Unicast, Broadcast và Multicast Nắm được vì sao Multicast UDP phù hợp cho truyền dữ liệu nhóm và streaming Biết cách Java hỗ trợ multicast qua MulticastSocket Hiểu Java RMI và cơ chế gọi phương thức từ xa Chuẩn bị nền tảng cho các bài ứng dụng mạng phân tán và đồ án học phần ","permalink":"http://localhost:1313/blog/bai-viet-8/","summary":"Giải thích Multicast UDP (gửi 1-n) và Java RMI (gọi phương thức từ xa) – nền tảng cho ứng dụng nhóm và hệ phân tán.","title":"Bài 8: Multicast UDP và Java RMI"},{"content":"Sau khi hoàn thành các bài về TCP, UDP, đa tuyến và xử lý đồng thời,\nchúng ta đã có đủ nền tảng để xây dựng một ứng dụng mạng hoàn chỉnh.\nBài học này giúp bạn xâu chuỗi toàn bộ kiến thức đã học,\nhiểu rõ mỗi công nghệ dùng trong trường hợp nào,\nvà cách thiết kế một hệ thống mạng đúng tư duy kỹ sư.\nNhìn lại các mô hình giao tiếp mạng đã học Trong lập trình mạng, các ứng dụng thường được xây dựng dựa trên mô hình Client – Server.\nClient: gửi yêu cầu, nhập dữ liệu, hiển thị kết quả Server: xử lý logic, quản lý dữ liệu, trả kết quả Tùy bài toán, ta lựa chọn giao thức và mô hình phù hợp.\nSo sánh TCP, UDP và Multicast TCP – Giao tiếp tin cậy TCP phù hợp khi:\nCần đảm bảo dữ liệu đúng và đủ Cần kết nối ổn định, hai chiều Ví dụ: chat, truyền file, game theo lượt, hệ thống ngân hàng Đặc trưng:\nCó bắt tay 3 bước Có kiểm soát lỗi, kiểm soát luồng Tốn tài nguyên hơn UDP UDP – Giao tiếp nhanh, không kết nối UDP phù hợp khi:\nƯu tiên tốc độ Chấp nhận mất gói Ví dụ: game thời gian thực, streaming, cảm biến Đặc trưng:\nKhông kết nối Không đảm bảo thứ tự Ít độ trễ UDP Multicast – Truyền dữ liệu nhóm Multicast được dùng khi:\nMột nguồn → nhiều người nhận Dữ liệu giống nhau cho tất cả client Ví dụ: livestream, thông báo hệ thống, truyền trạng thái Ưu điểm:\nGiảm tải server Tiết kiệm băng thông Phù hợp mạng LAN Vai trò của đa tuyến (Multithreading) Trong thực tế, server không thể xử lý từng client một cách tuần tự.\nĐa tuyến giúp:\nNhiều client kết nối cùng lúc Không client nào bị “đóng băng” Tăng khả năng mở rộng hệ thống Ví dụ:\nServer chat: mỗi client là một thread Server TCP: mỗi socket được xử lý riêng Thiết kế một ứng dụng mạng hoàn chỉnh Khi thiết kế, cần xác định rõ:\nGiao thức: TCP hay UDP? Mô hình: 1–1, 1–n, n–n? Đồng thời hay tuần tự? Client gửi gì? Server xử lý gì? Một thiết kế tốt luôn:\nPhân tách rõ giao tiếp – xử lý – dữ liệu Dễ mở rộng Dễ bảo trì Liên hệ với đồ án học phần Các đồ án như:\nChat đa tuyến Oẳn Tù Tì client–server Streaming UDP Dịch vụ RMI Đều là sự kết hợp của các kiến thức đã học,\nkhông phải nội dung mới.\nKết luận Qua bài học này, bạn đã:\nHệ thống lại toàn bộ kiến thức lập trình mạng Hiểu rõ khi nào dùng TCP, UDP, Multicast Nắm được vai trò của đa tuyến Biết cách tư duy thiết kế một ứng dụng mạng hoàn chỉnh Đây là bước chuẩn bị quan trọng trước khi vận dụng toàn bộ kiến thức vào một hệ thống thực tế.\n","permalink":"http://localhost:1313/blog/bai-viet-9/","summary":"Tổng hợp kiến thức TCP, UDP, đa tuyến và cách thiết kế ứng dụng mạng Client–Server hoàn chỉnh.","title":"Bài 9: Tổng hợp kiến thức \u0026 thiết kế ứng dụng mạng"},{"content":"Bài cuối cùng của học phần không nhằm giới thiệu công nghệ mới,\nmà tập trung vào cách vận dụng kiến thức đã học vào thực tế.\nĐây là giai đoạn chuyển từ:\n“Biết dùng” → “Biết thiết kế” → “Biết đánh giá hệ thống”\nTư duy vận dụng kiến thức Một ứng dụng mạng hoàn chỉnh cần trả lời được các câu hỏi:\nVì sao chọn TCP mà không phải UDP? Vì sao cần đa tuyến? Server có chịu được nhiều client không? Hệ thống có mở rộng được không? Đây chính là tư duy kỹ sư, không phải chỉ “chạy được là xong”.\nĐánh giá một ứng dụng mạng Khi hoàn thiện hệ thống, cần xem xét:\n1. Tính đúng đắn Dữ liệu có truyền đúng không? Có mất gói không? Có xử lý lỗi không? 2. Tính đồng thời Nhiều client có dùng chung được không? Có bị treo server không? Có race condition không? 3. Hiệu năng Độ trễ thế nào? Server có bị quá tải không? Có tách luồng hợp lý không? Liên hệ với các mô hình phân tán Các hệ thống đã học là nền tảng cho:\nHệ thống client–server lớn Ứng dụng phân tán Microservices Cloud services Java RMI, TCP đa tuyến hay UDP Multicast\nđều là những viên gạch đầu tiên.\nTừ học phần đến thực tế Sau học phần này, bạn có thể tiếp cận:\nWebSocket REST API gRPC Message Queue (Kafka, RabbitMQ) Hệ thống realtime Tư duy lập trình mạng không thay đổi, chỉ công nghệ thay đổi.\nTổng kết toàn bộ học phần Qua toàn bộ chuỗi bài, bạn đã:\nHiểu cách dữ liệu đi qua mạng Làm việc với TCP, UDP, Multicast Xử lý đa tuyến và đồng thời Tiếp cận lập trình phân tán với RMI Có tư duy thiết kế hệ thống mạng Lời kết Lập trình mạng không chỉ là code socket,\nmà là hiểu cách các hệ thống nói chuyện với nhau.\nNếu bạn hiểu được điều đó,\nbạn đã vượt xa mức “học để qua môn”.\n","permalink":"http://localhost:1313/blog/bai-viet-10/","summary":"Vận dụng toàn bộ kiến thức lập trình mạng để xây dựng, đánh giá và hoàn thiện một ứng dụng thực tế.","title":"Bài 10: Hoàn thiện \u0026 vận dụng lập trình mạng"},{"content":"Lời mở đầu Có những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\nMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\nHọc tập Những năm đại học trôi qua nhanh hơn mình từng nghĩ. Ngày mới bước chân vào giảng đường, mình vẫn còn khá mơ hồ về ngành học, về tương lai, về chính bản thân mình sẽ trở thành ai sau bốn năm. Nhưng rồi từng môn học, từng bài tập nhóm, từng đồ án kéo mình lại gần hơn với cách một hệ thống được hình thành và vận hành.\nHệ thống thông tin không chỉ là lập trình, cũng không đơn thuần là công nghệ. Đó là câu chuyện về con người, quy trình và dữ liệu. Mình học cách đặt câu hỏi, học cách lắng nghe yêu cầu, học cách vẽ ra những sơ đồ tưởng chừng khô khan nhưng lại chứa rất nhiều suy nghĩ phía sau. Dần dần, mình nhận ra mình thích phần “hiểu vấn đề” hơn là chỉ chăm chăm vào lời giải.\nĐịnh hướng Ở thời điểm hiện tại, mình đang định hướng theo con đường Business Analyst (BA). Mình hứng thú với vai trò đứng giữa – không quá xa kỹ thuật, cũng không tách rời nghiệp vụ. Đó là nơi cần sự rõ ràng trong tư duy, sự kiên nhẫn trong giao tiếp và khả năng chuyển hóa những điều mơ hồ thành thứ có thể triển khai được.\nMình không nghĩ BA là một vị trí “nhẹ nhàng” hay “an toàn”. Ngược lại, đó là công việc đòi hỏi phải học rất nhiều, sai rất nhiều và sửa rất nhiều. Nhưng chính điều đó khiến mình thấy phù hợp. Mình muốn hiểu hệ thống trước khi xây dựng nó, muốn biết vì sao người ta see cần một chức năng, chứ không chỉ là nó được viết như thế nào.\nBlog Blog này ra đời khá tự nhiên, giống như một cuốn sổ mở rộng hơn là một trang thể hiện điều gì đó to tát. Mình viết để nhớ, để hệ thống lại những gì đã học, và đôi khi là để sắp xếp lại suy nghĩ của chính mình.\nỞ đây có thể là kiến thức về Hệ thống thông tin, về phân tích nghiệp vụ, về lập trình, hoặc đơn giản là những trải nghiệm học tập và va chạm trong quá trình làm đồ án, làm việc nhóm, và chuẩn bị bước ra môi trường thực tế. Mình không mong mọi thứ phải hoàn hảo, chỉ mong nó thật và có ích cho ai đó đang đi trên con đường tương tự.\nLời kết Mình đang ở một giai đoạn chưa thể gọi là trưởng thành, nhưng cũng không còn quá non nớt. Vẫn đang học, vẫn đang thử, vẫn đang sai và sửa mỗi ngày. Nếu có một điều mình mong giữ được lâu nhất, thì đó là sự tò mò và tinh thần học hỏi – những thứ giúp mình không đứng yên giữa rất nhiều lựa chọn ngoài kia.\nCảm ơn bạn đã ghé qua và đọc những dòng này. Hy vọng ở một thời điểm nào đó, những chia sẻ nhỏ ở đây sẽ chạm đến bạn – dù chỉ là một chút. \u0026ldquo;Học để chia sẻ, chia sẻ để học nhiều hơn.\u0026rdquo;\nLiên hệ Nếu bạn muốn gửi cho mình vài dòng trao đổi,\nbạn có thể liên hệ với mình qua Email hoặc GitHub ,Facebook dưới đây.\nCảm ơn bạn đã ghé thăm blog! ","permalink":"http://localhost:1313/about/","summary":"\u003ch2 id=\"lời-mở-đầu\"\u003eLời mở đầu\u003c/h2\u003e\n\u003cp\u003eCó những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\u003c/p\u003e\n\u003cp\u003eMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\u003c/p\u003e","title":"Giới thiệu"},{"content":"Trong lập trình mạng, trước khi kết nối, ta phải biết \u0026ldquo;địa chỉ nhà\u0026rdquo; (IP) của mình và đối phương. Java cung cấp class\nHình 1.1: Hiệu ứng Dunning–Kruger – mức độ tự tin thay đổi theo kinh nghiệm học tập\nGóc nhìn học tập: Hiệu ứng Dunning–Kruger InetAddress để làm việc này.\nĐịa chỉ IP là gì trong lập trình mạng? IP (Internet Protocol Address) là địa chỉ định danh của một thiết bị khi tham gia vào mạng máy tính.\nTrong lập trình mạng, IP đóng vai trò quan trọng trong việc:\nXác định máy gửi và máy nhận Định tuyến dữ liệu trong quá trình truyền thông Thiết lập kết nối giữa các tiến trình chạy trên những máy khác nhau Nếu không có địa chỉ IP, các máy tính sẽ không thể nhận biết và giao tiếp với nhau.\nVai trò của lớp InetAddress trong Java Lớp InetAddress đại diện cho một địa chỉ IP trong Java.\nThông qua lớp này, lập trình viên có thể:\nLấy địa chỉ IP của máy đang chạy chương trình Lấy tên máy (hostname) Phân giải tên miền sang địa chỉ IP Chuẩn bị thông tin để tạo Socket hoặc ServerSocket Hầu hết các chương trình lập trình mạng trong Java đều sử dụng InetAddress ở bước khởi tạo.\nPhân tích ý nghĩa các lệnh trong chương trình InetAddress.getLocalHost()\n→ Trả về đối tượng đại diện cho máy cục bộ (localhost).\ngetHostName()\n→ Lấy tên máy do hệ điều hành hoặc mạng gán.\ngetHostAddress()\n→ Lấy địa chỉ IP của máy dưới dạng chuỗi.\nViệc in ra hostname và IP giúp:\nKiểm tra cấu hình mạng Xác định đúng máy khi kết nối Client – Server Debug lỗi mạng Một số lưu ý khi lấy IP trong Java Khi máy không kết nối mạng, IP có thể là 127.0.0.1 Khi máy có nhiều card mạng (WiFi, LAN, VPN), IP trả về có thể không phải IP Internet Trên Server, hostname và IP thường khác máy cá nhân Ứng dụng thực tế Việc xác định IP của máy thường được sử dụng trong:\nChương trình Client – Server Thông báo IP Server cho Client kết nối Kiểm tra kết nối mạng LAN Ghi log và giám sát hệ thống Kết luận Qua bài học này, ta đã:\nHiểu vai trò của địa chỉ IP trong lập trình mạng Biết cách lấy IP bằng lớp InetAddress Chuẩn bị nền tảng cho các kỹ thuật TCP, UDP và RMI Liên hệ với học phần Lập trình Mạng máy tính Bài học này nằm trong nội dung mở đầu của học phần Lập trình Mạng máy tính (CMP180) tại Trường Đại học Công nghệ TP.HCM (HUTECH).\nTrong lộ trình môn học, sinh viên sẽ lần lượt tiếp cận các nội dung:\nKiến thức nền tảng về mạng và lập trình mạng Quản lý luồng nhập xuất (I/O) Quản lý địa chỉ và kết nối mạng Lập trình Socket TCP và UDP Xử lý đa tuyến, đa luồng Multicast UDP và Java RMI Thực hiện đồ án học phần cá nhân Mục tiêu của bài học Thông qua Bài 1, sinh viên sẽ:\nLàm quen với môi trường lập trình mạng bằng Java Hiểu được vai trò của địa chỉ IP trong giao tiếp mạng Biết cách sử dụng lớp InetAddress để lấy IP và hostname Chuẩn bị nền tảng cho các bài học tiếp theo về Socket và Server – Client ","permalink":"http://localhost:1313/blog/bai-viet-1/","summary":"GIỚI THIỆU HỌC PHẦN.","title":"Bài 1: Tổng quan khoá học"},{"content":"Trong lập trình mạng, nếu IP được xem như địa chỉ nhà của một máy tính trong mạng,\nthì Port (cổng) chính là số hiệu dùng để xác định chương trình hoặc dịch vụ cụ thể đang chạy trên máy đó.\nMột máy tính có thể chạy đồng thời nhiều ứng dụng mạng như Web Server, Database Server, Game Server hoặc Chat Server.\nMỗi ứng dụng bắt buộc phải gắn với một Port riêng để hệ điều hành có thể phân biệt và định tuyến dữ liệu chính xác.\nPort nằm ở đâu trong mô hình TCP/IP? Trong bộ giao thức TCP/IP, Port thuộc về Transport Layer (Tầng giao vận) và được sử dụng bởi hai giao thức chính là TCP và UDP.\nĐịa chỉ IP xác định máy nào sẽ nhận dữ liệu Port xác định ứng dụng nào trên máy đó sẽ xử lý dữ liệu Sự kết hợp giữa IP + Port tạo thành một Socket, là điểm cuối (endpoint) của quá trình giao tiếp mạng.\nCác loại Port phổ biến Port được đánh số từ 0 đến 65535 và được chia thành ba nhóm chính:\nInternet và các End Devices Trước khi tìm hiểu về Port, cần hiểu Internet được cấu thành từ hàng tỷ thiết bị đầu cuối (End Devices) như máy tính, điện thoại, máy chủ và các thiết bị IoT.\nCác thiết bị này kết nối với nhau thông qua nhiều lớp mạng khác nhau, và mỗi thiết bị khi tham gia giao tiếp mạng đều cần có địa chỉ IP và Port để định danh. Hình 2.1: Sơ đồ minh họa Internet và các thiết bị đầu cuối (End Devices) kết nối thông qua các mạng truy cập và mạng lõi.\nTrong quá trình giao tiếp mạng, một thiết bị không chỉ cần địa chỉ IP để xác định vị trí trong mạng, mà còn cần Port để xác định chính xác ứng dụng hoặc dịch vụ đang lắng nghe trên thiết bị đó.\nDo đó, Port đóng vai trò như “điểm tiếp nhận” (endpoint) cho các tiến trình mạng chạy trên cùng một máy.\nMô hình các tầng giao thức TCP/IP Để hiểu rõ Port hoạt động ở đâu và vì sao Server cần Port, ta cần nắm được mô hình giao thức TCP/IP – nền tảng của mọi ứng dụng mạng hiện nay.\nHình 2.2: Mô hình các tầng giao thức TCP/IP và các giao thức tiêu biểu tương ứng với từng tầng.\nTrong mô hình TCP/IP, địa chỉ IP hoạt động ở tầng Internet, giúp xác định thiết bị trong mạng.\nTrong khi đó, Port hoạt động ở tầng Transport (TCP/UDP), giúp xác định chính xác ứng dụng hoặc dịch vụ đang giao tiếp trên thiết bị đó.\nWell-known Ports (0 – 1023) Được dùng cho các dịch vụ chuẩn:\nPort 80: HTTP Port 443: HTTPS Port 21: FTP Port 25: SMTP Registered Ports (1024 – 49151) Thường dùng cho các ứng dụng phổ biến:\nPort 3306: MySQL Port 8080: Web Server thay thế port 80 Dynamic / Private Ports (49152 – 65535) Do hệ điều hành cấp phát tạm thời cho Client khi giao tiếp mạng.\nVì sao Server thường dùng cổng 8080? Cổng 8080 rất phổ biến trong quá trình phát triển và học tập vì:\nTránh xung đột với cổng 80 đang được hệ điều hành chiếm dụng Không cần quyền Administrator khi mở Server Phù hợp cho các Web Server thử nghiệm như: Apache Tomcat Spring Boot Node.js Lỗi thường gặp: “Address already in use” Lỗi này xảy ra khi Server cố gắng mở một Port đã bị chương trình khác chiếm dụng.\nNguyên nhân phổ biến:\nServer cũ chưa được tắt Port đang được dùng bởi dịch vụ khác Chạy nhiều Server cùng lúc Cách khắc phục:\nĐổi sang Port khác (ví dụ: 8080 → 9090) Kiểm tra Port đang sử dụng trong hệ điều hành Đảm bảo chỉ có một Server chạy tại một thời điểm Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), khái niệm Port sẽ được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Xây dựng mô hình Client – Server Java RMI và Multicast Việc hiểu rõ Port là nền tảng bắt buộc trước khi triển khai các ứng dụng mạng thực tế.\nKết luận Qua bài học này, ta đã:\nHiểu được Port là gì và vai trò của Port trong lập trình mạng Nắm được mối quan hệ giữa IP, Port và Socket Giải thích được lý do Server thường sử dụng cổng 8080 Chuẩn bị kiến thức nền cho các bài học tiếp theo về TCP và UDP ","permalink":"http://localhost:1313/blog/bai-viet-2/","summary":"MẠNG MÁY TÍNH \u0026amp; INTERNET.","title":"Bài 2: Kiến thức nền tảng?"},{"content":"Trong lập trình Java, luồng nhập xuất (Input / Output Streams) đóng vai trò trung gian giúp chương trình đọc và ghi dữ liệu từ nhiều nguồn khác nhau như bàn phím, file, console, bộ nhớ và sau này là socket mạng.\nHiểu rõ cơ chế luồng nhập xuất là bước nền bắt buộc trước khi đi vào lập trình Socket TCP, UDP hay Java RMI.\nLuồng (Stream) là gì? Luồng (Stream) là dòng dữ liệu di chuyển\ntừ nguồn → chương trình hoặc từ chương trình → đích.\nKhi Java đọc hoặc ghi dữ liệu, dữ liệu không đi trực tiếp mà luôn được đóng gói và truyền qua luồng.\nLuồng nhập xuất là gì? Luồng nhập xuất là cơ chế cho phép chương trình:\nNhận dữ liệu từ bên ngoài (Input) Ghi dữ liệu ra bên ngoài (Output) Luồng có thể kết nối với nhiều nguồn và đích khác nhau:\nFile Bàn phím Màn hình (console) Bộ nhớ Kết nối mạng (TCP / UDP) Dữ liệu trong luồng tồn tại dưới những dạng nào? Trong Java, dữ liệu trong luồng tồn tại dưới hai dạng chính:\nLuồng byte Luồng ký tự Việc chọn đúng loại luồng ảnh hưởng trực tiếp đến hiệu năng và tính chính xác của chương trình.\nLuồng byte trong Java Đặc điểm Dữ liệu được xử lý dưới dạng nhị phân Phù hợp với: File nhị phân Ảnh, video Socket mạng Dữ liệu phức tạp Các lớp gốc InputStream – luồng đọc byte OutputStream – luồng ghi byte Cả hai đều là lớp trừu tượng (abstract).\nCác luồng byte đọc phổ biến FileInputStream – đọc byte từ file ByteArrayInputStream – đọc từ mảng byte PipedInputStream – đọc từ luồng pipe Các luồng byte ghi phổ biến FileOutputStream – ghi byte vào file ByteArrayOutputStream – ghi vào mảng byte PipedOutputStream – ghi vào luồng pipe Mô hình đọc/ghi dữ liệu với Stream Quy trình chung khi làm việc với luồng:\nTạo đối tượng Stream Gắn Stream với nguồn hoặc đích Đọc/ghi dữ liệu trong vòng lặp Đóng Stream sau khi hoàn tất Luồng ký tự trong Java Đặc điểm Xử lý dữ liệu dạng Unicode Phù hợp với: File văn bản Chuỗi Dữ liệu hiển thị cho người dùng Các lớp gốc Reader – luồng đọc ký tự Writer – luồng ghi ký tự Các luồng ký tự đọc phổ biến FileReader – đọc file văn bản BufferedReader – đọc có bộ đệm StringReader – đọc chuỗi CharArrayReader – đọc mảng ký tự Các luồng ký tự ghi phổ biến FileWriter – ghi vào file văn bản BufferedWriter – ghi có bộ đệm PrintWriter – ghi dữ liệu dạng dễ đọc StringWriter – ghi chuỗi Luồng lọc dữ liệu (Filtered Streams) Luồng lọc dùng để chuyển đổi dữ liệu từ dạng byte/ký tự sang các kiểu dữ liệu khác.\nCác luồng lọc phổ biến DataInputStream DataOutputStream Cho phép đọc/ghi các kiểu dữ liệu nguyên thủy:\nint float double boolean char Đây là cầu nối giữa luồng thô và dữ liệu có kiểu trong Java.\nLưu trạng thái đối tượng – Serialization Serialization là gì? Serialization (chuỗi hóa) là quá trình chuyển đối tượng Java thành luồng byte để:\nLưu vào file Truyền qua mạng Phục hồi lại sau này Deserialization Ngược lại, Deserialization (giải chuỗi) là quá trình:\nĐọc byte Tái tạo lại đối tượng ban đầu Đây là nền tảng cho:\nLưu dữ liệu chương trình Java RMI Truyền object qua mạng Try-with-resources (TWR) Java hỗ trợ Try-with-resources để:\nTự động đóng stream Tránh rò rỉ tài nguyên Code gọn và an toàn hơn So với try-catch truyền thống, TWR:\nÍt lỗi hơn Dễ bảo trì hơn Được khuyến khích sử dụng Các lỗi I/O thường gặp Khi làm việc với luồng, một số exception phổ biến là:\nFileNotFoundException IOException EOFException UnsupportedEncodingException FileAlreadyExistsException AccessDeniedException SocketException MalformedURLException SerializationException InvalidPathException Việc bắt và xử lý exception đúng cách là yêu cầu bắt buộc trong lập trình Java.\nLiên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), luồng nhập xuất được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Truyền dữ liệu Client – Server Java RMI Multicast UDP Không hiểu I/O Stream → không thể làm mạng đúng cách.\nKết luận Qua bài học này, ta đã:\nHiểu khái niệm luồng nhập xuất trong Java Phân biệt luồng byte và luồng ký tự Nắm được cách đọc/ghi dữ liệu với Stream Biết vai trò của Serialization và Filtered Streams Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo Khi xử lý các tác vụ mạng (như gọi API), người mới học JS hay viết code lồng nhau kiểu này:\n1 2 3 4 5 6 7 8 9 10 // Cực hình Callback Hell getData(function(a) { getMoreData(a, function(b) { getMoreData(b, function(c) { getMoreData(c, function(d) { console.log(d); }); }); }); }); ","permalink":"http://localhost:1313/blog/bai-viet-3/","summary":"Tổng quan về Input/Output Streams trong Java – nền tảng cho xử lý file, console và lập trình mạng.","title":"Bài 3: Quản lý luồng nhập xuất trong Java"},{"content":"Trong lập trình mạng, trước khi chương trình có thể gửi hoặc nhận dữ liệu, điều quan trọng nhất là xác định đúng địa chỉ kết nối mạng. Nếu xác định sai địa chỉ, chương trình sẽ không thể giao tiếp, dù phần xử lý dữ liệu có đúng đến đâu.\nBài học này giúp bạn hiểu cách Java làm việc với địa chỉ IP, tên miền (DNS) và URL. Đây là nền tảng bắt buộc trước khi đi vào Socket TCP, UDP, Web Crawler và Java RMI.\nĐịa chỉ kết nối mạng là gì? Địa chỉ kết nối mạng là thông tin dùng để xác định máy nào trong mạng cần giao tiếp và dịch vụ nào trên máy đó sẽ xử lý dữ liệu.\nTrong Internet, địa chỉ kết nối thường bao gồm:\nĐịa chỉ IP Tên miền (Domain Name) Cổng (Port) Giao thức (Protocol) DNS – Domain Name System Hình 4.1 – Mô hình hoạt động của DNS (Domain Name System)\nClient gửi yêu cầu phân giải tên miền đến DNS Server, DNS trả về địa chỉ IP tương ứng để client kết nối đến server đích.*\nCon người dễ nhớ tên miền hơn các dãy số IP.\nDNS (Domain Name System) có nhiệm vụ ánh xạ tên miền sang địa chỉ IP, giúp client tìm đúng server cần kết nối.\nVí dụ:\ngoogle.com tương ứng với nhiều địa chỉ IP khác nhau www.cs.yale.edu tương ứng với 128.36.229.30 Nhờ DNS, người dùng không cần ghi nhớ địa chỉ IP khi truy cập Internet. *Hình 4.2 minh họa cấu trúc phân cấp của hệ thống DNS, bao gồm Root Domain, các Top-Level Domain (com, edu, org, vn, …) và các tên miền con phía dưới.\nCấu trúc phân cấp này giúp DNS hoạt động hiệu quả và dễ mở rộng trên toàn Internet.*\nĐịa chỉ IPv4 Hình 4.3 minh họa khái niệm Zone trong DNS.\nMỗi Zone là một phần của không gian tên miền và được quản lý bởi một DNS Server có thẩm quyền.\nViệc chia DNS thành các Zone giúp hệ thống dễ quản lý, phân quyền và tăng độ tin cậy.\nIPv4 là dạng địa chỉ phổ biến, gồm 32 bit, thường được viết thành bốn nhóm số.\nVí dụ:\n192.168.1.1 8.8.8.8 Một số dải địa chỉ đặc biệt:\n127.x.x.x là loopback (localhost) 224.0.0.0 – 239.255.255.255 là multicast Lớp InetAddress trong Java Java cung cấp lớp InetAddress để làm việc với địa chỉ IP và DNS.\nLớp này thường được dùng để:\nPhân giải tên miền sang IP Kiểm tra loại địa chỉ Kiểm tra khả năng kết nối mạng Ví dụ minh họa:\n1 InetAddress address = InetAddress.getByName(\u0026#34;google.com\u0026#34;); URL – Uniform Resource Locator URL được dùng để xác định tài nguyên trên Internet như trang web, file hoặc dịch vụ.\nMột URL đầy đủ thường bao gồm các thành phần sau:\nGiao thức (Protocol) Tên miền (Host) Cổng (Port) Đường dẫn (Path) Chuỗi truy vấn (Query) Ví dụ một URL đầy đủ: https://www.hutech.edu.vn/admission?id=123\nURL cho biết lấy dữ liệu ở đâu và bằng cách nào.\nLớp URL trong Java Lớp URL cho phép chương trình Java:\nPhân tích các thành phần của URL Kết nối tới server Đọc dữ liệu từ Internet Ví dụ minh họa:\n1 URL url = new URL(\u0026#34;https://www.example.com\u0026#34;); Ý nghĩa của việc quản lý địa chỉ kết nối mạng Hiểu rõ cách quản lý địa chỉ mạng giúp:\nTránh kết nối sai server Chuẩn bị đúng địa chỉ cho Socket TCP/UDP Hiểu cách Web Crawler hoạt động Nắm vững mô hình Client – Server Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm địa chỉ kết nối mạng Biết vai trò của DNS và IPv4 Nắm được cách Java làm việc với InetAddress Hiểu cấu trúc và vai trò của URL Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-4/","summary":"Tìm hiểu cách Java quản lý địa chỉ mạng thông qua InetAddress, URL, URLConnection và DNS.","title":"Bài 4: Quản lý địa chỉ kết nối mạng trong Java"},{"content":"Trong lập trình mạng, TCP Socket là cơ chế quan trọng nhất để xây dựng các ứng dụng Client – Server có độ tin cậy cao.\nBài học này giúp bạn hiểu TCP là gì, vì sao cần TCP, và cách Java triển khai TCP thông qua Socket và ServerSocket.\nĐây là bước chuyển tiếp trực tiếp từ kiến thức địa chỉ mạng (IP, DNS, URL) sang giao tiếp dữ liệu thực tế giữa các chương trình.\nTCP là gì? TCP (Transmission Control Protocol) là giao thức truyền thông hướng kết nối, đảm bảo dữ liệu được truyền:\nĐúng thứ tự Đầy đủ Không bị mất mát Không bị trùng lặp Trước khi truyền dữ liệu, TCP yêu cầu thiết lập kết nối giữa hai bên, và chỉ khi kết nối thành công thì dữ liệu mới được trao đổi.\nVì sao sử dụng TCP? TCP được sử dụng khi ứng dụng yêu cầu độ tin cậy cao, ví dụ:\nỨng dụng chat Ứng dụng client–server Truyền file Game online theo lượt Hệ thống ngân hàng, thương mại điện tử TCP cung cấp các cơ chế quan trọng:\nĐảm bảo dữ liệu: gói tin bị mất sẽ được gửi lại Kiểm soát lỗi: phát hiện và sửa lỗi trong quá trình truyền Kiểm soát luồng: tránh làm quá tải phía nhận Giao tiếp hai chiều: cho phép gửi và nhận dữ liệu đồng thời Cơ chế hoạt động của TCP Quá trình giao tiếp TCP gồm ba giai đoạn chính:\nThiết lập kết nối (Bắt tay 3 bước – Three-way Handshake) Truyền dữ liệu Giải phóng kết nối Nhờ cơ chế này, TCP đảm bảo rằng hai bên luôn sẵn sàng trước khi truyền và kết thúc an toàn sau khi hoàn tất.\nMô hình Client – Server Các ứng dụng TCP thường hoạt động theo mô hình Client – Server.\nServer:\nChạy trước Lắng nghe yêu cầu kết nối Cung cấp dịch vụ Trả kết quả cho client Client:\nChạy sau Chủ động kết nối tới server Gửi yêu cầu Nhận phản hồi từ server Quá trình giao tiếp gồm:\nClient gửi yêu cầu Server xử lý Server trả kết quả cho client Socket trong Java Trong Java, Socket đại diện cho điểm cuối giao tiếp giữa client và server khi sử dụng TCP.\nSocket cho phép:\nGửi dữ liệu tới server Nhận dữ liệu từ server Giao tiếp hai chiều thông qua luồng nhập/xuất Ví dụ minh họa tạo Socket phía client:\n1 Socket socket = new Socket(\u0026#34;localhost\u0026#34;, 8080); ServerSocket trong Java ServerSocket được sử dụng ở phía server để:\nMở một cổng lắng nghe Chờ client kết nối Chấp nhận kết nối và tạo Socket giao tiếp ServerSocket đóng vai trò như cửa ngõ, cho phép các client kết nối vào server.\nVí dụ minh họa:\n1 ServerSocket server = new ServerSocket(8080); Luồng dữ liệu trong TCP Socket Sau khi kết nối TCP được thiết lập, client và server trao đổi dữ liệu thông qua các luồng:\nInputStream: dùng để đọc dữ liệu từ socket OutputStream: dùng để ghi dữ liệu vào socket Luồng dữ liệu này hoạt động tương tự như I/O Stream đã học ở bài trước,\nnhưng nguồn và đích là mạng thay vì file hay bàn phím.\nVí dụ ứng dụng: Trò chơi Oẳn Tù Tì Một bài tập tiêu biểu sử dụng TCP Socket là trò chơi Oẳn Tù Tì theo mô hình Client – Server.\nĐặc điểm Server quản lý luật chơi và điểm số Hai client gửi lựa chọn (kéo – búa – bao) Server xác định kết quả và gửi lại cho client Dữ liệu được truyền qua TCP để đảm bảo chính xác Thông qua bài tập này, sinh viên hiểu rõ:\nCách thiết lập kết nối TCP Cách trao đổi dữ liệu giữa nhiều client Cách xử lý lỗi mạng và ngoại lệ Ý nghĩa của lập trình TCP Socket Việc nắm vững TCP Socket giúp bạn:\nHiểu bản chất giao tiếp mạng Xây dựng hệ thống Client – Server thực tế Chuẩn bị cho các bài nâng cao như: Đa tuyến (Multi-thread) Socket UDP Java RMI Ứng dụng mạng phân tán Kết luận Qua bài học này, bạn đã:\nHiểu TCP là gì và vì sao cần TCP Nắm được mô hình Client – Server Biết vai trò của Socket và ServerSocket trong Java Hiểu cách dữ liệu được truyền qua TCP Chuẩn bị nền tảng cho các bài học UDP và xử lý đồng thời tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-5/","summary":"Giải thích mô hình Client–Server và cách lập trình Socket TCP trong Java – nền tảng cho giao tiếp mạng tin cậy.","title":"Bài 5: Lập trình Socket TCP trong Java"},{"content":"#Trong lập trình mạng, không phải lúc nào ứng dụng cũng cần độ tin cậy tuyệt đối như TCP.\nTrong nhiều trường hợp, điều quan trọng hơn là tốc độ truyền nhanh và độ trễ thấp.\nBài học này giới thiệu UDP Socket – cơ chế truyền dữ liệu không kết nối, được sử dụng rộng rãi trong các ứng dụng thời gian thực.\nUDP là gì? UDP (User Datagram Protocol) là giao thức truyền thông không hướng kết nối.\nĐiều này có nghĩa là:\nKhông thiết lập kết nối trước khi truyền Không đảm bảo dữ liệu đến nơi Không đảm bảo thứ tự gói tin Không tự động gửi lại gói tin bị mất UDP gửi dữ liệu theo từng datagram (gói tin độc lập).\nSo sánh TCP và UDP TCP UDP Có kết nối Không kết nối Đảm bảo dữ liệu Không đảm bảo Truyền theo luồng Truyền theo gói Độ trễ cao hơn Độ trễ thấp Phù hợp dữ liệu quan trọng Phù hợp dữ liệu thời gian thực Khi nào sử dụng UDP? UDP được sử dụng khi:\nCần truyền nhanh Có thể chấp nhận mất gói tin Dữ liệu được gửi liên tục Ví dụ ứng dụng UDP:\nTruyền video, audio trực tuyến Game online thời gian thực Chat broadcast DNS Multicast, streaming UDP Socket trong Java Java hỗ trợ UDP thông qua hai lớp chính:\nDatagramSocket: quản lý socket UDP DatagramPacket: đại diện cho gói dữ liệu UDP UDP không phân biệt client hay server rõ ràng như TCP.\nMỗi chương trình chỉ cần một DatagramSocket để gửi và nhận dữ liệu.\nDatagramPacket là gì? DatagramPacket là gói dữ liệu UDP, bao gồm:\nDữ liệu cần gửi Địa chỉ IP đích Số hiệu cổng Mỗi lần gửi hoặc nhận dữ liệu, UDP làm việc với một DatagramPacket riêng biệt.\nLuồng dữ liệu trong UDP UDP không có luồng InputStream / OutputStream như TCP.\nQuy trình truyền dữ liệu UDP:\nTạo DatagramSocket Tạo DatagramPacket chứa dữ liệu Gửi packet đi Nhận packet về Đọc dữ liệu từ packet Mỗi gói tin là độc lập, không liên quan đến các gói khác.\nĐặc điểm quan trọng của UDP Không kiểm soát lỗi Không kiểm soát luồng Không bắt tay kết nối Gửi nhanh, xử lý đơn giản Phù hợp truyền broadcast và multicast Chính vì vậy, UDP thường được dùng khi tốc độ quan trọng hơn độ chính xác tuyệt đối.\nÝ nghĩa của lập trình Socket UDP Nắm vững UDP giúp bạn:\nHiểu bản chất truyền dữ liệu không kết nối Xây dựng ứng dụng thời gian thực Phân biệt rõ TCP và UDP trong thiết kế hệ thống Chuẩn bị cho các chủ đề nâng cao như: Multicast UDP Java RMI Hệ thống phân tán Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính, UDP được sử dụng trong:\nSocket UDP Multicast Ứng dụng truyền tin nhanh Game, streaming, broadcast Hiểu UDP giúp bạn chọn đúng giao thức cho từng bài toán thực tế.\nKết luận Qua bài học này, bạn đã:\nHiểu UDP là gì và cơ chế hoạt động Phân biệt được TCP và UDP Biết vai trò của DatagramSocket và DatagramPacket Hiểu cách truyền dữ liệu không kết nối Chuẩn bị nền tảng cho bài Multicast UDP \u0026amp; Java RMI tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-6/","summary":"Giải thích giao thức UDP và cách Java lập trình Socket UDP – nền tảng cho truyền dữ liệu nhanh, không kết nối.","title":"Bài 6: Lập trình Socket UDP trong Java"},{"content":"Trong các ứng dụng mạng thực tế, đặc biệt là Server, chương trình thường phải xử lý nhiều yêu cầu cùng lúc.\nNếu chỉ sử dụng một luồng thực thi, server sẽ bị tắc nghẽn, các client phải chờ đợi và hiệu năng giảm nghiêm trọng.\nVì vậy, lập trình đa tuyến (Multithreading) và xử lý đồng thời (Concurrency) là kỹ thuật bắt buộc trong lập trình mạng.\nTuyến (Thread) là gì? Thread là một dòng điều khiển tuần tự bên trong một chương trình.\nMột chương trình (process) có thể chứa nhiều thread Các thread có thể chạy đồng thời Mỗi thread thực hiện một nhiệm vụ riêng Thread không phải là một chương trình độc lập,\nnó luôn thuộc về một process.\nProcess và Thread Process:\nCó không gian bộ nhớ riêng Chạy độc lập với process khác Tạo và chuyển đổi tốn nhiều tài nguyên Thread:\nChia sẻ bộ nhớ với các thread khác trong cùng process Tạo nhanh hơn process Chuyển đổi nhanh hơn Nhờ thread, chương trình có thể thực hiện nhiều công việc cùng lúc trong cùng một ứng dụng.\nVì sao cần lập trình đa tuyến? Lập trình đa tuyến giúp:\nTăng hiệu suất và khả năng đáp ứng Tận dụng thời gian chờ đợi (I/O, mạng, tải file) Chia nhỏ tác vụ và xử lý đồng thời Cải thiện trải nghiệm người dùng Trong lập trình mạng, đa tuyến cho phép server phục vụ nhiều client cùng lúc.\nThực thi Thread trong Java Trong Java, một thread bắt đầu chạy khi gọi phương thức start().\nKhi thread chạy, JVM thực thi mã trong phương thức run() Khi run() kết thúc, thread cũng kết thúc Một thread không thể start lại, muốn chạy lại phải tạo thread mới Thread cần có điều kiện dừng rõ ràng để tránh chạy vô hạn.\nỨng dụng đa tuyến trong lập trình mạng Ứng dụng Chat đa tuyến Một ví dụ tiêu biểu của đa tuyến trong mạng là ứng dụng chat nhiều client – một server.\nĐặc điểm:\nServer chấp nhận nhiều client kết nối cùng lúc Mỗi client được xử lý bởi một thread riêng Tin nhắn từ một client được gửi tới tất cả client khác Server ghi lại nội dung chat vào file log Thông qua ví dụ này, sinh viên hiểu rõ:\nCách server xử lý nhiều kết nối đồng thời Cách phối hợp giữa socket và thread Vai trò của đa tuyến trong ứng dụng mạng Xử lý đồng thời (Concurrency) Xử lý đồng thời xảy ra khi nhiều thread:\nChạy cùng lúc Truy cập tài nguyên chung (biến, file, bộ nhớ) Nếu không kiểm soát tốt, chương trình có thể gặp các vấn đề nghiêm trọng.\nRace Condition Race Condition xảy ra khi:\nNhiều thread cùng truy cập và thay đổi dữ liệu chung Kết quả phụ thuộc vào thứ tự thực thi không xác định Điều này có thể dẫn đến:\nDữ liệu sai lệch Kết quả không nhất quán Lỗi khó phát hiện Đồng bộ hóa (Synchronization) Để tránh race condition, Java cung cấp cơ chế đồng bộ hóa:\nĐảm bảo chỉ một thread được truy cập tài nguyên tại một thời điểm Giữ cho dữ liệu luôn nhất quán Đồng bộ hóa là nền tảng để xây dựng các ứng dụng an toàn và ổn định khi chạy đa tuyến.\nCác vấn đề thường gặp trong xử lý đồng thời Một số vấn đề phổ biến:\nRace condition: tranh chấp dữ liệu Deadlock: các thread chờ nhau vô hạn Livelock: các thread liên tục phản ứng nhưng không tiến triển Starvation: thread không bao giờ được cấp tài nguyên Những vấn đề này khiến lập trình đa tuyến trở nên phức tạp và khó debug.\nLập lịch Thread trong Java Java sử dụng cơ chế lập lịch theo độ ưu tiên:\nMỗi thread có độ ưu tiên từ MIN_PRIORITY đến MAX_PRIORITY JVM chọn thread runnable có độ ưu tiên cao hơn để chạy Thread có thể nhường CPU cho thread khác bằng cách gọi yield() Việc hiểu cơ chế lập lịch giúp lập trình viên thiết kế thread hợp lý hơn.\nÝ nghĩa của lập trình đa tuyến và xử lý đồng thời Nắm vững kiến thức bài này giúp bạn:\nXây dựng server xử lý nhiều client Viết ứng dụng mạng hiệu năng cao Tránh lỗi tranh chấp dữ liệu Chuẩn bị cho các chủ đề nâng cao như: Server đa tuyến Pooling Threads Multicast UDP Java RMI Hệ thống phân tán Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm thread và multithreading Phân biệt process và thread Biết vai trò của đa tuyến trong lập trình mạng Hiểu các vấn đề xử lý đồng thời và race condition Chuẩn bị nền tảng cho các bài học nâng cao tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-7/","summary":"Giải thích lập trình đa tuyến và xử lý đồng thời trong Java – nền tảng cho các ứng dụng mạng nhiều client và hệ thống phân tán.","title":"Bài 7: Lập trình đa tuyến và xử lý đồng thời trong Java"},{"content":"Buổi 8 gồm 2 phần lớn:\nMulticast UDP: gửi dữ liệu từ một nguồn đến nhiều máy nhận cùng lúc (1 → N). Java RMI: gọi phương thức từ xa giữa các ứng dụng Java như gọi hàm bình thường (Remote Method Invocation). Đây là các kỹ thuật thường gặp trong streaming, trò chuyện nhóm, giám sát từ xa và hệ thống phân tán.\n1) UDP Multicast Unicast, Broadcast và Multicast Trong mạng máy tính có 3 kiểu gửi dữ liệu phổ biến:\nUnicast: 1 nguồn → 1 đích\nVí dụ: bạn mở một trang web, server trả dữ liệu cho riêng bạn.\nBroadcast: 1 nguồn → tất cả máy trong mạng nội bộ\nVí dụ: một thông báo phát cho toàn bộ LAN.\nMulticast: 1 nguồn → một nhóm máy đã đăng ký nhận dữ liệu\nVí dụ: server phát stream video cho nhóm người xem cùng lúc.\nMulticast là cách truyền hiệu quả khi nhiều máy cùng cần nhận một nội dung giống nhau.\nTại sao dùng UDP Multicast? UDP Multicast thường được dùng vì:\nHiệu suất cao: gửi 1 lần nhưng nhiều máy nhận → giảm tải mạng và server. Đơn giản, nhanh: UDP là kiểu “gửi và quên”, không phải chờ xác nhận. Tối ưu trong LAN: phù hợp môi trường mạng nội bộ (Local Area Network). Rất hợp streaming: audio/video cần tốc độ và độ trễ thấp hơn là đảm bảo tuyệt đối. Ứng dụng của Multicast Multicast có thể dùng trong:\nTruyền phát multimedia trực tiếp (audio/video streaming) Trò chuyện nhóm, hội thoại nhóm Quảng bá thông tin cấu hình mạng và cập nhật trong hệ thống mạng Game nhiều người chơi (gửi trạng thái game cho nhiều người) Phát thông tin trạng thái/cảnh báo cho nhiều thiết bị Phát tán cập nhật phần mềm trong mạng nội bộ Địa chỉ Multicast IPv4 Trong IPv4:\nClass D là dải địa chỉ dành cho multicast Dải địa chỉ multicast thường gặp: 224.0.0.0 – 239.255.255.255 Một số nhóm multicast hay được nhắc:\n224.0.0.1: tất cả host trong local subnet Multicast Group là gì? Multicast hoạt động theo “nhóm”:\nMột multicast group giống như một kênh. Máy nào muốn nhận dữ liệu phải tham gia nhóm (join group). Khi rời nhóm thì không nhận dữ liệu nữa. Multicast trong Java Java hỗ trợ multicast qua lớp:\njava.net.MulticastSocket (kế thừa từ DatagramSocket) Một số thao tác quan trọng:\njoinGroup(...): tham gia nhóm multicast leaveGroup(...): rời nhóm multicast setTimeToLive(ttl): đặt TTL (thời gian sống của gói tin, qua bao nhiêu router) Quy trình gửi dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket Tham gia nhóm multicast Tạo DatagramPacket chứa dữ liệu + địa chỉ nhóm + port Gửi packet Rời nhóm Ví dụ minh họa (ngắn, chỉ để hiểu):\n1 2 3 4 5 6 7 8 9 10 11 12 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(); socket.joinGroup(group); socket.setTimeToLive(5); byte[] data = \u0026#34;Hello Multicast\u0026#34;.getBytes(); DatagramPacket packet = new DatagramPacket(data, data.length, group, 9876); socket.send(packet); socket.leaveGroup(group); socket.close(); Quy trình nhận dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket lắng nghe trên port Tham gia nhóm multicast Tạo DatagramPacket rỗng để nhận dữ liệu Gọi receive() để chờ gói tin gửi về Đọc dữ liệu từ packet Rời nhóm và đóng socket Ví dụ minh họa (ngắn):\n1 2 3 4 5 6 7 8 9 10 11 12 13 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(9876); socket.joinGroup(group); byte[] buf = new byte[1024]; DatagramPacket packet = new DatagramPacket(buf, buf.length); socket.receive(packet); String msg = new String(packet.getData(), 0, packet.getLength()); System.out.println(\u0026#34;Received: \u0026#34; + msg); socket.leaveGroup(group); socket.close(); 2) Java RMI Java RMI là gì? RMI (Remote Method Invocation) cho phép chương trình Java:\nGọi phương thức của một đối tượng nằm trên máy khác Cảm giác giống như gọi method trong cùng chương trình Nói đơn giản:\nClient gọi: remoteObject.sum(1,2) Server thực thi thật và trả kết quả về cho client RMI giúp che giấu toàn bộ chi tiết mạng phía sau, người lập trình chỉ tập trung vào logic.\nVì sao dùng Java RMI? Java RMI được sử dụng vì:\nTích hợp sẵn trong Java, dễ triển khai nếu cả client và server đều dùng Java Gọi phương thức từ xa đơn giản như gọi hàm thông thường Hỗ trợ dữ liệu phức tạp: đối tượng, mảng, class tự định nghĩa Tự động xử lý giao tiếp mạng thông qua cơ chế stub / skeleton Dựa trên TCP/IP nên tương đối ổn định và tin cậy Hạn chế của Java RMI Một số điểm hạn chế cần lưu ý:\nPhụ thuộc Java: chủ yếu phù hợp Java ↔ Java Thiết kế dịch vụ phức tạp vẫn cần tổ chức tốt (đặc biệt khi dùng callback) Quản lý phiên và kết nối không mạnh như các giải pháp hiện đại Bảo mật cần cấu hình cẩn thận trong môi trường thực tế Ý tưởng kiến trúc RMI (hiểu nhanh) Trong Java RMI có các thành phần chính:\nRemote Interface\nKhai báo các phương thức cho phép gọi từ xa\nServer Implementation\nLớp cài đặt interface, chứa logic xử lý thật\nRMI Registry\nNơi đăng ký service để client tìm thấy server\nClient\nTìm (lookup) service trong registry và gọi phương thức\nCác bước triển khai RMI (tóm tắt) Định nghĩa Remote Interface Cài đặt interface bằng một class server (remote object) Viết chương trình server: tạo object và bind vào registry Viết chương trình client: lookup registry và gọi method Chạy RMI registry, chạy server, sau đó chạy client Ví dụ ứng dụng RMI Một số ví dụ thường gặp:\nTính tổng 2 số từ xa Dịch vụ quản lý tài khoản ATM Dịch vụ giám sát nhiệt độ có callback (server gọi ngược lại client) Bài tập gợi ý theo đúng nội dung buổi 8 BT8.01: Mô phỏng streaming video\n(1 server phát, nhiều client nhận dữ liệu)\nBT8.02: Server quản lý tài khoản ATM bằng RMI\n(thêm user, đăng nhập, gửi/rút tiền, lưu lịch sử giao dịch)\nKết luận Qua bài học này, bạn đã:\nHiểu sự khác nhau giữa Unicast, Broadcast và Multicast Nắm được vì sao Multicast UDP phù hợp cho truyền dữ liệu nhóm và streaming Biết cách Java hỗ trợ multicast qua MulticastSocket Hiểu Java RMI và cơ chế gọi phương thức từ xa Chuẩn bị nền tảng cho các bài ứng dụng mạng phân tán và đồ án học phần ","permalink":"http://localhost:1313/blog/bai-viet-8/","summary":"Giải thích Multicast UDP (gửi 1-n) và Java RMI (gọi phương thức từ xa) – nền tảng cho ứng dụng nhóm và hệ phân tán.","title":"Bài 8: Multicast UDP và Java RMI"},{"content":"Sau khi hoàn thành các bài về TCP, UDP, đa tuyến và xử lý đồng thời,\nchúng ta đã có đủ nền tảng để xây dựng một ứng dụng mạng hoàn chỉnh.\nBài học này giúp bạn xâu chuỗi toàn bộ kiến thức đã học,\nhiểu rõ mỗi công nghệ dùng trong trường hợp nào,\nvà cách thiết kế một hệ thống mạng đúng tư duy kỹ sư.\nNhìn lại các mô hình giao tiếp mạng đã học Trong lập trình mạng, các ứng dụng thường được xây dựng dựa trên mô hình Client – Server.\nClient: gửi yêu cầu, nhập dữ liệu, hiển thị kết quả Server: xử lý logic, quản lý dữ liệu, trả kết quả Tùy bài toán, ta lựa chọn giao thức và mô hình phù hợp.\nSo sánh TCP, UDP và Multicast TCP – Giao tiếp tin cậy TCP phù hợp khi:\nCần đảm bảo dữ liệu đúng và đủ Cần kết nối ổn định, hai chiều Ví dụ: chat, truyền file, game theo lượt, hệ thống ngân hàng Đặc trưng:\nCó bắt tay 3 bước Có kiểm soát lỗi, kiểm soát luồng Tốn tài nguyên hơn UDP UDP – Giao tiếp nhanh, không kết nối UDP phù hợp khi:\nƯu tiên tốc độ Chấp nhận mất gói Ví dụ: game thời gian thực, streaming, cảm biến Đặc trưng:\nKhông kết nối Không đảm bảo thứ tự Ít độ trễ UDP Multicast – Truyền dữ liệu nhóm Multicast được dùng khi:\nMột nguồn → nhiều người nhận Dữ liệu giống nhau cho tất cả client Ví dụ: livestream, thông báo hệ thống, truyền trạng thái Ưu điểm:\nGiảm tải server Tiết kiệm băng thông Phù hợp mạng LAN Vai trò của đa tuyến (Multithreading) Trong thực tế, server không thể xử lý từng client một cách tuần tự.\nĐa tuyến giúp:\nNhiều client kết nối cùng lúc Không client nào bị “đóng băng” Tăng khả năng mở rộng hệ thống Ví dụ:\nServer chat: mỗi client là một thread Server TCP: mỗi socket được xử lý riêng Thiết kế một ứng dụng mạng hoàn chỉnh Khi thiết kế, cần xác định rõ:\nGiao thức: TCP hay UDP? Mô hình: 1–1, 1–n, n–n? Đồng thời hay tuần tự? Client gửi gì? Server xử lý gì? Một thiết kế tốt luôn:\nPhân tách rõ giao tiếp – xử lý – dữ liệu Dễ mở rộng Dễ bảo trì Liên hệ với đồ án học phần Các đồ án như:\nChat đa tuyến Oẳn Tù Tì client–server Streaming UDP Dịch vụ RMI Đều là sự kết hợp của các kiến thức đã học,\nkhông phải nội dung mới.\nKết luận Qua bài học này, bạn đã:\nHệ thống lại toàn bộ kiến thức lập trình mạng Hiểu rõ khi nào dùng TCP, UDP, Multicast Nắm được vai trò của đa tuyến Biết cách tư duy thiết kế một ứng dụng mạng hoàn chỉnh Đây là bước chuẩn bị quan trọng trước khi vận dụng toàn bộ kiến thức vào một hệ thống thực tế.\n","permalink":"http://localhost:1313/blog/bai-viet-9/","summary":"Tổng hợp kiến thức TCP, UDP, đa tuyến và cách thiết kế ứng dụng mạng Client–Server hoàn chỉnh.","title":"Bài 9: Tổng hợp kiến thức \u0026 thiết kế ứng dụng mạng"},{"content":"Bài cuối cùng của học phần không nhằm giới thiệu công nghệ mới,\nmà tập trung vào cách vận dụng kiến thức đã học vào thực tế.\nĐây là giai đoạn chuyển từ:\n“Biết dùng” → “Biết thiết kế” → “Biết đánh giá hệ thống”\nTư duy vận dụng kiến thức Một ứng dụng mạng hoàn chỉnh cần trả lời được các câu hỏi:\nVì sao chọn TCP mà không phải UDP? Vì sao cần đa tuyến? Server có chịu được nhiều client không? Hệ thống có mở rộng được không? Đây chính là tư duy kỹ sư, không phải chỉ “chạy được là xong”.\nĐánh giá một ứng dụng mạng Khi hoàn thiện hệ thống, cần xem xét:\n1. Tính đúng đắn Dữ liệu có truyền đúng không? Có mất gói không? Có xử lý lỗi không? 2. Tính đồng thời Nhiều client có dùng chung được không? Có bị treo server không? Có race condition không? 3. Hiệu năng Độ trễ thế nào? Server có bị quá tải không? Có tách luồng hợp lý không? Liên hệ với các mô hình phân tán Các hệ thống đã học là nền tảng cho:\nHệ thống client–server lớn Ứng dụng phân tán Microservices Cloud services Java RMI, TCP đa tuyến hay UDP Multicast\nđều là những viên gạch đầu tiên.\nTừ học phần đến thực tế Sau học phần này, bạn có thể tiếp cận:\nWebSocket REST API gRPC Message Queue (Kafka, RabbitMQ) Hệ thống realtime Tư duy lập trình mạng không thay đổi, chỉ công nghệ thay đổi.\nTổng kết toàn bộ học phần Qua toàn bộ chuỗi bài, bạn đã:\nHiểu cách dữ liệu đi qua mạng Làm việc với TCP, UDP, Multicast Xử lý đa tuyến và đồng thời Tiếp cận lập trình phân tán với RMI Có tư duy thiết kế hệ thống mạng Lời kết Lập trình mạng không chỉ là code socket,\nmà là hiểu cách các hệ thống nói chuyện với nhau.\nNếu bạn hiểu được điều đó,\nbạn đã vượt xa mức “học để qua môn”.\n","permalink":"http://localhost:1313/blog/bai-viet-10/","summary":"Vận dụng toàn bộ kiến thức lập trình mạng để xây dựng, đánh giá và hoàn thiện một ứng dụng thực tế.","title":"Bài 10: Hoàn thiện \u0026 vận dụng lập trình mạng"},{"content":"Lời mở đầu Có những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\nMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\nHọc tập Những năm đại học trôi qua nhanh hơn mình từng nghĩ. Ngày mới bước chân vào giảng đường, mình vẫn còn khá mơ hồ về ngành học, về tương lai, về chính bản thân mình sẽ trở thành ai sau bốn năm. Nhưng rồi từng môn học, từng bài tập nhóm, từng đồ án kéo mình lại gần hơn với cách một hệ thống được hình thành và vận hành.\nHệ thống thông tin không chỉ là lập trình, cũng không đơn thuần là công nghệ. Đó là câu chuyện về con người, quy trình và dữ liệu. Mình học cách đặt câu hỏi, học cách lắng nghe yêu cầu, học cách vẽ ra những sơ đồ tưởng chừng khô khan nhưng lại chứa rất nhiều suy nghĩ phía sau. Dần dần, mình nhận ra mình thích phần “hiểu vấn đề” hơn là chỉ chăm chăm vào lời giải.\nĐịnh hướng Ở thời điểm hiện tại, mình đang định hướng theo con đường Business Analyst (BA). Mình hứng thú với vai trò đứng giữa – không quá xa kỹ thuật, cũng không tách rời nghiệp vụ. Đó là nơi cần sự rõ ràng trong tư duy, sự kiên nhẫn trong giao tiếp và khả năng chuyển hóa những điều mơ hồ thành thứ có thể triển khai được.\nMình không nghĩ BA là một vị trí “nhẹ nhàng” hay “an toàn”. Ngược lại, đó là công việc đòi hỏi phải học rất nhiều, sai rất nhiều và sửa rất nhiều. Nhưng chính điều đó khiến mình thấy phù hợp. Mình muốn hiểu hệ thống trước khi xây dựng nó, muốn biết vì sao người ta see cần một chức năng, chứ không chỉ là nó được viết như thế nào.\nBlog Blog này ra đời khá tự nhiên, giống như một cuốn sổ mở rộng hơn là một trang thể hiện điều gì đó to tát. Mình viết để nhớ, để hệ thống lại những gì đã học, và đôi khi là để sắp xếp lại suy nghĩ của chính mình.\nỞ đây có thể là kiến thức về Hệ thống thông tin, về phân tích nghiệp vụ, về lập trình, hoặc đơn giản là những trải nghiệm học tập và va chạm trong quá trình làm đồ án, làm việc nhóm, và chuẩn bị bước ra môi trường thực tế. Mình không mong mọi thứ phải hoàn hảo, chỉ mong nó thật và có ích cho ai đó đang đi trên con đường tương tự.\nLời kết Mình đang ở một giai đoạn chưa thể gọi là trưởng thành, nhưng cũng không còn quá non nớt. Vẫn đang học, vẫn đang thử, vẫn đang sai và sửa mỗi ngày. Nếu có một điều mình mong giữ được lâu nhất, thì đó là sự tò mò và tinh thần học hỏi – những thứ giúp mình không đứng yên giữa rất nhiều lựa chọn ngoài kia.\nCảm ơn bạn đã ghé qua và đọc những dòng này. Hy vọng ở một thời điểm nào đó, những chia sẻ nhỏ ở đây sẽ chạm đến bạn – dù chỉ là một chút. \u0026ldquo;Học để chia sẻ, chia sẻ để học nhiều hơn.\u0026rdquo;\nLiên hệ Nếu bạn muốn gửi cho mình vài dòng trao đổi,\nbạn có thể liên hệ với mình qua Email hoặc GitHub ,Facebook dưới đây.\nCảm ơn bạn đã ghé thăm blog! ","permalink":"http://localhost:1313/about/","summary":"\u003ch2 id=\"lời-mở-đầu\"\u003eLời mở đầu\u003c/h2\u003e\n\u003cp\u003eCó những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\u003c/p\u003e\n\u003cp\u003eMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\u003c/p\u003e","title":"Giới thiệu"},{"content":"Trong lập trình mạng, trước khi kết nối, ta phải biết \u0026ldquo;địa chỉ nhà\u0026rdquo; (IP) của mình và đối phương. Java cung cấp class\nHình 1.1: Hiệu ứng Dunning–Kruger – mức độ tự tin thay đổi theo kinh nghiệm học tập\nGóc nhìn học tập: Hiệu ứng Dunning–Kruger InetAddress để làm việc này.\nĐịa chỉ IP là gì trong lập trình mạng? IP (Internet Protocol Address) là địa chỉ định danh của một thiết bị khi tham gia vào mạng máy tính.\nTrong lập trình mạng, IP đóng vai trò quan trọng trong việc:\nXác định máy gửi và máy nhận Định tuyến dữ liệu trong quá trình truyền thông Thiết lập kết nối giữa các tiến trình chạy trên những máy khác nhau Nếu không có địa chỉ IP, các máy tính sẽ không thể nhận biết và giao tiếp với nhau.\nVai trò của lớp InetAddress trong Java Lớp InetAddress đại diện cho một địa chỉ IP trong Java.\nThông qua lớp này, lập trình viên có thể:\nLấy địa chỉ IP của máy đang chạy chương trình Lấy tên máy (hostname) Phân giải tên miền sang địa chỉ IP Chuẩn bị thông tin để tạo Socket hoặc ServerSocket Hầu hết các chương trình lập trình mạng trong Java đều sử dụng InetAddress ở bước khởi tạo.\nPhân tích ý nghĩa các lệnh trong chương trình InetAddress.getLocalHost()\n→ Trả về đối tượng đại diện cho máy cục bộ (localhost).\ngetHostName()\n→ Lấy tên máy do hệ điều hành hoặc mạng gán.\ngetHostAddress()\n→ Lấy địa chỉ IP của máy dưới dạng chuỗi.\nViệc in ra hostname và IP giúp:\nKiểm tra cấu hình mạng Xác định đúng máy khi kết nối Client – Server Debug lỗi mạng Một số lưu ý khi lấy IP trong Java Khi máy không kết nối mạng, IP có thể là 127.0.0.1 Khi máy có nhiều card mạng (WiFi, LAN, VPN), IP trả về có thể không phải IP Internet Trên Server, hostname và IP thường khác máy cá nhân Ứng dụng thực tế Việc xác định IP của máy thường được sử dụng trong:\nChương trình Client – Server Thông báo IP Server cho Client kết nối Kiểm tra kết nối mạng LAN Ghi log và giám sát hệ thống Kết luận Qua bài học này, ta đã:\nHiểu vai trò của địa chỉ IP trong lập trình mạng Biết cách lấy IP bằng lớp InetAddress Chuẩn bị nền tảng cho các kỹ thuật TCP, UDP và RMI Liên hệ với học phần Lập trình Mạng máy tính Bài học này nằm trong nội dung mở đầu của học phần Lập trình Mạng máy tính (CMP180) tại Trường Đại học Công nghệ TP.HCM (HUTECH).\nTrong lộ trình môn học, sinh viên sẽ lần lượt tiếp cận các nội dung:\nKiến thức nền tảng về mạng và lập trình mạng Quản lý luồng nhập xuất (I/O) Quản lý địa chỉ và kết nối mạng Lập trình Socket TCP và UDP Xử lý đa tuyến, đa luồng Multicast UDP và Java RMI Thực hiện đồ án học phần cá nhân Mục tiêu của bài học Thông qua Bài 1, sinh viên sẽ:\nLàm quen với môi trường lập trình mạng bằng Java Hiểu được vai trò của địa chỉ IP trong giao tiếp mạng Biết cách sử dụng lớp InetAddress để lấy IP và hostname Chuẩn bị nền tảng cho các bài học tiếp theo về Socket và Server – Client ","permalink":"http://localhost:1313/blog/bai-viet-1/","summary":"GIỚI THIỆU HỌC PHẦN.","title":"Bài 1: Tổng quan khoá học"},{"content":"Trong lập trình mạng, nếu IP được xem như địa chỉ nhà của một máy tính trong mạng,\nthì Port (cổng) chính là số hiệu dùng để xác định chương trình hoặc dịch vụ cụ thể đang chạy trên máy đó.\nMột máy tính có thể chạy đồng thời nhiều ứng dụng mạng như Web Server, Database Server, Game Server hoặc Chat Server.\nMỗi ứng dụng bắt buộc phải gắn với một Port riêng để hệ điều hành có thể phân biệt và định tuyến dữ liệu chính xác.\nPort nằm ở đâu trong mô hình TCP/IP? Trong bộ giao thức TCP/IP, Port thuộc về Transport Layer (Tầng giao vận) và được sử dụng bởi hai giao thức chính là TCP và UDP.\nĐịa chỉ IP xác định máy nào sẽ nhận dữ liệu Port xác định ứng dụng nào trên máy đó sẽ xử lý dữ liệu Sự kết hợp giữa IP + Port tạo thành một Socket, là điểm cuối (endpoint) của quá trình giao tiếp mạng.\nCác loại Port phổ biến Port được đánh số từ 0 đến 65535 và được chia thành ba nhóm chính:\nInternet và các End Devices Trước khi tìm hiểu về Port, cần hiểu Internet được cấu thành từ hàng tỷ thiết bị đầu cuối (End Devices) như máy tính, điện thoại, máy chủ và các thiết bị IoT.\nCác thiết bị này kết nối với nhau thông qua nhiều lớp mạng khác nhau, và mỗi thiết bị khi tham gia giao tiếp mạng đều cần có địa chỉ IP và Port để định danh. Hình 2.1: Sơ đồ minh họa Internet và các thiết bị đầu cuối (End Devices) kết nối thông qua các mạng truy cập và mạng lõi.\nTrong quá trình giao tiếp mạng, một thiết bị không chỉ cần địa chỉ IP để xác định vị trí trong mạng, mà còn cần Port để xác định chính xác ứng dụng hoặc dịch vụ đang lắng nghe trên thiết bị đó.\nDo đó, Port đóng vai trò như “điểm tiếp nhận” (endpoint) cho các tiến trình mạng chạy trên cùng một máy.\nMô hình các tầng giao thức TCP/IP Để hiểu rõ Port hoạt động ở đâu và vì sao Server cần Port, ta cần nắm được mô hình giao thức TCP/IP – nền tảng của mọi ứng dụng mạng hiện nay.\nHình 2.2: Mô hình các tầng giao thức TCP/IP và các giao thức tiêu biểu tương ứng với từng tầng.\nTrong mô hình TCP/IP, địa chỉ IP hoạt động ở tầng Internet, giúp xác định thiết bị trong mạng.\nTrong khi đó, Port hoạt động ở tầng Transport (TCP/UDP), giúp xác định chính xác ứng dụng hoặc dịch vụ đang giao tiếp trên thiết bị đó.\nWell-known Ports (0 – 1023) Được dùng cho các dịch vụ chuẩn:\nPort 80: HTTP Port 443: HTTPS Port 21: FTP Port 25: SMTP Registered Ports (1024 – 49151) Thường dùng cho các ứng dụng phổ biến:\nPort 3306: MySQL Port 8080: Web Server thay thế port 80 Dynamic / Private Ports (49152 – 65535) Do hệ điều hành cấp phát tạm thời cho Client khi giao tiếp mạng.\nVì sao Server thường dùng cổng 8080? Cổng 8080 rất phổ biến trong quá trình phát triển và học tập vì:\nTránh xung đột với cổng 80 đang được hệ điều hành chiếm dụng Không cần quyền Administrator khi mở Server Phù hợp cho các Web Server thử nghiệm như: Apache Tomcat Spring Boot Node.js Lỗi thường gặp: “Address already in use” Lỗi này xảy ra khi Server cố gắng mở một Port đã bị chương trình khác chiếm dụng.\nNguyên nhân phổ biến:\nServer cũ chưa được tắt Port đang được dùng bởi dịch vụ khác Chạy nhiều Server cùng lúc Cách khắc phục:\nĐổi sang Port khác (ví dụ: 8080 → 9090) Kiểm tra Port đang sử dụng trong hệ điều hành Đảm bảo chỉ có một Server chạy tại một thời điểm Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), khái niệm Port sẽ được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Xây dựng mô hình Client – Server Java RMI và Multicast Việc hiểu rõ Port là nền tảng bắt buộc trước khi triển khai các ứng dụng mạng thực tế.\nKết luận Qua bài học này, ta đã:\nHiểu được Port là gì và vai trò của Port trong lập trình mạng Nắm được mối quan hệ giữa IP, Port và Socket Giải thích được lý do Server thường sử dụng cổng 8080 Chuẩn bị kiến thức nền cho các bài học tiếp theo về TCP và UDP ","permalink":"http://localhost:1313/blog/bai-viet-2/","summary":"MẠNG MÁY TÍNH \u0026amp; INTERNET.","title":"Bài 2: Kiến thức nền tảng?"},{"content":"Trong lập trình Java, luồng nhập xuất (Input / Output Streams) đóng vai trò trung gian giúp chương trình đọc và ghi dữ liệu từ nhiều nguồn khác nhau như bàn phím, file, console, bộ nhớ và sau này là socket mạng.\nHiểu rõ cơ chế luồng nhập xuất là bước nền bắt buộc trước khi đi vào lập trình Socket TCP, UDP hay Java RMI.\nLuồng (Stream) là gì? Luồng (Stream) là dòng dữ liệu di chuyển\ntừ nguồn → chương trình hoặc từ chương trình → đích.\nKhi Java đọc hoặc ghi dữ liệu, dữ liệu không đi trực tiếp mà luôn được đóng gói và truyền qua luồng.\nLuồng nhập xuất là gì? Luồng nhập xuất là cơ chế cho phép chương trình:\nNhận dữ liệu từ bên ngoài (Input) Ghi dữ liệu ra bên ngoài (Output) Luồng có thể kết nối với nhiều nguồn và đích khác nhau:\nFile Bàn phím Màn hình (console) Bộ nhớ Kết nối mạng (TCP / UDP) Dữ liệu trong luồng tồn tại dưới những dạng nào? Trong Java, dữ liệu trong luồng tồn tại dưới hai dạng chính:\nLuồng byte Luồng ký tự Việc chọn đúng loại luồng ảnh hưởng trực tiếp đến hiệu năng và tính chính xác của chương trình.\nLuồng byte trong Java Đặc điểm Dữ liệu được xử lý dưới dạng nhị phân Phù hợp với: File nhị phân Ảnh, video Socket mạng Dữ liệu phức tạp Các lớp gốc InputStream – luồng đọc byte OutputStream – luồng ghi byte Cả hai đều là lớp trừu tượng (abstract).\nCác luồng byte đọc phổ biến FileInputStream – đọc byte từ file ByteArrayInputStream – đọc từ mảng byte PipedInputStream – đọc từ luồng pipe Các luồng byte ghi phổ biến FileOutputStream – ghi byte vào file ByteArrayOutputStream – ghi vào mảng byte PipedOutputStream – ghi vào luồng pipe Mô hình đọc/ghi dữ liệu với Stream Quy trình chung khi làm việc với luồng:\nTạo đối tượng Stream Gắn Stream với nguồn hoặc đích Đọc/ghi dữ liệu trong vòng lặp Đóng Stream sau khi hoàn tất Luồng ký tự trong Java Đặc điểm Xử lý dữ liệu dạng Unicode Phù hợp với: File văn bản Chuỗi Dữ liệu hiển thị cho người dùng Các lớp gốc Reader – luồng đọc ký tự Writer – luồng ghi ký tự Các luồng ký tự đọc phổ biến FileReader – đọc file văn bản BufferedReader – đọc có bộ đệm StringReader – đọc chuỗi CharArrayReader – đọc mảng ký tự Các luồng ký tự ghi phổ biến FileWriter – ghi vào file văn bản BufferedWriter – ghi có bộ đệm PrintWriter – ghi dữ liệu dạng dễ đọc StringWriter – ghi chuỗi Luồng lọc dữ liệu (Filtered Streams) Luồng lọc dùng để chuyển đổi dữ liệu từ dạng byte/ký tự sang các kiểu dữ liệu khác.\nCác luồng lọc phổ biến DataInputStream DataOutputStream Cho phép đọc/ghi các kiểu dữ liệu nguyên thủy:\nint float double boolean char Đây là cầu nối giữa luồng thô và dữ liệu có kiểu trong Java.\nLưu trạng thái đối tượng – Serialization Serialization là gì? Serialization (chuỗi hóa) là quá trình chuyển đối tượng Java thành luồng byte để:\nLưu vào file Truyền qua mạng Phục hồi lại sau này Deserialization Ngược lại, Deserialization (giải chuỗi) là quá trình:\nĐọc byte Tái tạo lại đối tượng ban đầu Đây là nền tảng cho:\nLưu dữ liệu chương trình Java RMI Truyền object qua mạng Try-with-resources (TWR) Java hỗ trợ Try-with-resources để:\nTự động đóng stream Tránh rò rỉ tài nguyên Code gọn và an toàn hơn So với try-catch truyền thống, TWR:\nÍt lỗi hơn Dễ bảo trì hơn Được khuyến khích sử dụng Các lỗi I/O thường gặp Khi làm việc với luồng, một số exception phổ biến là:\nFileNotFoundException IOException EOFException UnsupportedEncodingException FileAlreadyExistsException AccessDeniedException SocketException MalformedURLException SerializationException InvalidPathException Việc bắt và xử lý exception đúng cách là yêu cầu bắt buộc trong lập trình Java.\nLiên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), luồng nhập xuất được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Truyền dữ liệu Client – Server Java RMI Multicast UDP Không hiểu I/O Stream → không thể làm mạng đúng cách.\nKết luận Qua bài học này, ta đã:\nHiểu khái niệm luồng nhập xuất trong Java Phân biệt luồng byte và luồng ký tự Nắm được cách đọc/ghi dữ liệu với Stream Biết vai trò của Serialization và Filtered Streams Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo Khi xử lý các tác vụ mạng (như gọi API), người mới học JS hay viết code lồng nhau kiểu này:\n1 2 3 4 5 6 7 8 9 10 // Cực hình Callback Hell getData(function(a) { getMoreData(a, function(b) { getMoreData(b, function(c) { getMoreData(c, function(d) { console.log(d); }); }); }); }); ","permalink":"http://localhost:1313/blog/bai-viet-3/","summary":"Tổng quan về Input/Output Streams trong Java – nền tảng cho xử lý file, console và lập trình mạng.","title":"Bài 3: Quản lý luồng nhập xuất trong Java"},{"content":"Trong lập trình mạng, trước khi chương trình có thể gửi hoặc nhận dữ liệu, điều quan trọng nhất là xác định đúng địa chỉ kết nối mạng. Nếu xác định sai địa chỉ, chương trình sẽ không thể giao tiếp, dù phần xử lý dữ liệu có đúng đến đâu.\nBài học này giúp bạn hiểu cách Java làm việc với địa chỉ IP, tên miền (DNS) và URL. Đây là nền tảng bắt buộc trước khi đi vào Socket TCP, UDP, Web Crawler và Java RMI.\nĐịa chỉ kết nối mạng là gì? Địa chỉ kết nối mạng là thông tin dùng để xác định máy nào trong mạng cần giao tiếp và dịch vụ nào trên máy đó sẽ xử lý dữ liệu.\nTrong Internet, địa chỉ kết nối thường bao gồm:\nĐịa chỉ IP Tên miền (Domain Name) Cổng (Port) Giao thức (Protocol) DNS – Domain Name System Hình 4.1 – Mô hình hoạt động của DNS (Domain Name System)\nClient gửi yêu cầu phân giải tên miền đến DNS Server, DNS trả về địa chỉ IP tương ứng để client kết nối đến server đích.*\nCon người dễ nhớ tên miền hơn các dãy số IP.\nDNS (Domain Name System) có nhiệm vụ ánh xạ tên miền sang địa chỉ IP, giúp client tìm đúng server cần kết nối.\nVí dụ:\ngoogle.com tương ứng với nhiều địa chỉ IP khác nhau www.cs.yale.edu tương ứng với 128.36.229.30 Nhờ DNS, người dùng không cần ghi nhớ địa chỉ IP khi truy cập Internet. *Hình 4.2 minh họa cấu trúc phân cấp của hệ thống DNS, bao gồm Root Domain, các Top-Level Domain (com, edu, org, vn, …) và các tên miền con phía dưới.\nCấu trúc phân cấp này giúp DNS hoạt động hiệu quả và dễ mở rộng trên toàn Internet.*\nĐịa chỉ IPv4 Hình 4.3 minh họa khái niệm Zone trong DNS. Mỗi Zone là một phần của không gian tên miền và được quản lý bởi một DNS Server có thẩm quyền.\nViệc chia DNS thành các Zone giúp hệ thống dễ quản lý, phân quyền và tăng độ tin cậy.\nIPv4 là dạng địa chỉ phổ biến, gồm 32 bit, thường được viết thành bốn nhóm số.\nVí dụ:\n192.168.1.1 8.8.8.8 Một số dải địa chỉ đặc biệt:\n127.x.x.x là loopback (localhost) 224.0.0.0 – 239.255.255.255 là multicast Lớp InetAddress trong Java Java cung cấp lớp InetAddress để làm việc với địa chỉ IP và DNS.\nLớp này thường được dùng để:\nPhân giải tên miền sang IP Kiểm tra loại địa chỉ Kiểm tra khả năng kết nối mạng Ví dụ minh họa:\n1 InetAddress address = InetAddress.getByName(\u0026#34;google.com\u0026#34;); URL – Uniform Resource Locator URL được dùng để xác định tài nguyên trên Internet như trang web, file hoặc dịch vụ.\nMột URL đầy đủ thường bao gồm các thành phần sau:\nGiao thức (Protocol) Tên miền (Host) Cổng (Port) Đường dẫn (Path) Chuỗi truy vấn (Query) Ví dụ một URL đầy đủ: https://www.hutech.edu.vn/admission?id=123\nURL cho biết lấy dữ liệu ở đâu và bằng cách nào.\nLớp URL trong Java Lớp URL cho phép chương trình Java:\nPhân tích các thành phần của URL Kết nối tới server Đọc dữ liệu từ Internet Ví dụ minh họa:\n1 URL url = new URL(\u0026#34;https://www.example.com\u0026#34;); Ý nghĩa của việc quản lý địa chỉ kết nối mạng Hiểu rõ cách quản lý địa chỉ mạng giúp:\nTránh kết nối sai server Chuẩn bị đúng địa chỉ cho Socket TCP/UDP Hiểu cách Web Crawler hoạt động Nắm vững mô hình Client – Server Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm địa chỉ kết nối mạng Biết vai trò của DNS và IPv4 Nắm được cách Java làm việc với InetAddress Hiểu cấu trúc và vai trò của URL Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-4/","summary":"Tìm hiểu cách Java quản lý địa chỉ mạng thông qua InetAddress, URL, URLConnection và DNS.","title":"Bài 4: Quản lý địa chỉ kết nối mạng trong Java"},{"content":"Trong lập trình mạng, TCP Socket là cơ chế quan trọng nhất để xây dựng các ứng dụng Client – Server có độ tin cậy cao.\nBài học này giúp bạn hiểu TCP là gì, vì sao cần TCP, và cách Java triển khai TCP thông qua Socket và ServerSocket.\nĐây là bước chuyển tiếp trực tiếp từ kiến thức địa chỉ mạng (IP, DNS, URL) sang giao tiếp dữ liệu thực tế giữa các chương trình.\nTCP là gì? TCP (Transmission Control Protocol) là giao thức truyền thông hướng kết nối, đảm bảo dữ liệu được truyền:\nĐúng thứ tự Đầy đủ Không bị mất mát Không bị trùng lặp Trước khi truyền dữ liệu, TCP yêu cầu thiết lập kết nối giữa hai bên, và chỉ khi kết nối thành công thì dữ liệu mới được trao đổi.\nVì sao sử dụng TCP? TCP được sử dụng khi ứng dụng yêu cầu độ tin cậy cao, ví dụ:\nỨng dụng chat Ứng dụng client–server Truyền file Game online theo lượt Hệ thống ngân hàng, thương mại điện tử TCP cung cấp các cơ chế quan trọng:\nĐảm bảo dữ liệu: gói tin bị mất sẽ được gửi lại Kiểm soát lỗi: phát hiện và sửa lỗi trong quá trình truyền Kiểm soát luồng: tránh làm quá tải phía nhận Giao tiếp hai chiều: cho phép gửi và nhận dữ liệu đồng thời Cơ chế hoạt động của TCP Quá trình giao tiếp TCP gồm ba giai đoạn chính:\nThiết lập kết nối (Bắt tay 3 bước – Three-way Handshake) Truyền dữ liệu Giải phóng kết nối Nhờ cơ chế này, TCP đảm bảo rằng hai bên luôn sẵn sàng trước khi truyền và kết thúc an toàn sau khi hoàn tất.\nMô hình Client – Server Các ứng dụng TCP thường hoạt động theo mô hình Client – Server.\nServer:\nChạy trước Lắng nghe yêu cầu kết nối Cung cấp dịch vụ Trả kết quả cho client Client:\nChạy sau Chủ động kết nối tới server Gửi yêu cầu Nhận phản hồi từ server Quá trình giao tiếp gồm:\nClient gửi yêu cầu Server xử lý Server trả kết quả cho client Socket trong Java Trong Java, Socket đại diện cho điểm cuối giao tiếp giữa client và server khi sử dụng TCP.\nSocket cho phép:\nGửi dữ liệu tới server Nhận dữ liệu từ server Giao tiếp hai chiều thông qua luồng nhập/xuất Ví dụ minh họa tạo Socket phía client:\n1 Socket socket = new Socket(\u0026#34;localhost\u0026#34;, 8080); ServerSocket trong Java ServerSocket được sử dụng ở phía server để:\nMở một cổng lắng nghe Chờ client kết nối Chấp nhận kết nối và tạo Socket giao tiếp ServerSocket đóng vai trò như cửa ngõ, cho phép các client kết nối vào server.\nVí dụ minh họa:\n1 ServerSocket server = new ServerSocket(8080); Luồng dữ liệu trong TCP Socket Sau khi kết nối TCP được thiết lập, client và server trao đổi dữ liệu thông qua các luồng:\nInputStream: dùng để đọc dữ liệu từ socket OutputStream: dùng để ghi dữ liệu vào socket Luồng dữ liệu này hoạt động tương tự như I/O Stream đã học ở bài trước,\nnhưng nguồn và đích là mạng thay vì file hay bàn phím.\nVí dụ ứng dụng: Trò chơi Oẳn Tù Tì Một bài tập tiêu biểu sử dụng TCP Socket là trò chơi Oẳn Tù Tì theo mô hình Client – Server.\nĐặc điểm Server quản lý luật chơi và điểm số Hai client gửi lựa chọn (kéo – búa – bao) Server xác định kết quả và gửi lại cho client Dữ liệu được truyền qua TCP để đảm bảo chính xác Thông qua bài tập này, sinh viên hiểu rõ:\nCách thiết lập kết nối TCP Cách trao đổi dữ liệu giữa nhiều client Cách xử lý lỗi mạng và ngoại lệ Ý nghĩa của lập trình TCP Socket Việc nắm vững TCP Socket giúp bạn:\nHiểu bản chất giao tiếp mạng Xây dựng hệ thống Client – Server thực tế Chuẩn bị cho các bài nâng cao như: Đa tuyến (Multi-thread) Socket UDP Java RMI Ứng dụng mạng phân tán Kết luận Qua bài học này, bạn đã:\nHiểu TCP là gì và vì sao cần TCP Nắm được mô hình Client – Server Biết vai trò của Socket và ServerSocket trong Java Hiểu cách dữ liệu được truyền qua TCP Chuẩn bị nền tảng cho các bài học UDP và xử lý đồng thời tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-5/","summary":"Giải thích mô hình Client–Server và cách lập trình Socket TCP trong Java – nền tảng cho giao tiếp mạng tin cậy.","title":"Bài 5: Lập trình Socket TCP trong Java"},{"content":"#Trong lập trình mạng, không phải lúc nào ứng dụng cũng cần độ tin cậy tuyệt đối như TCP.\nTrong nhiều trường hợp, điều quan trọng hơn là tốc độ truyền nhanh và độ trễ thấp.\nBài học này giới thiệu UDP Socket – cơ chế truyền dữ liệu không kết nối, được sử dụng rộng rãi trong các ứng dụng thời gian thực.\nUDP là gì? UDP (User Datagram Protocol) là giao thức truyền thông không hướng kết nối.\nĐiều này có nghĩa là:\nKhông thiết lập kết nối trước khi truyền Không đảm bảo dữ liệu đến nơi Không đảm bảo thứ tự gói tin Không tự động gửi lại gói tin bị mất UDP gửi dữ liệu theo từng datagram (gói tin độc lập).\nSo sánh TCP và UDP TCP UDP Có kết nối Không kết nối Đảm bảo dữ liệu Không đảm bảo Truyền theo luồng Truyền theo gói Độ trễ cao hơn Độ trễ thấp Phù hợp dữ liệu quan trọng Phù hợp dữ liệu thời gian thực Khi nào sử dụng UDP? UDP được sử dụng khi:\nCần truyền nhanh Có thể chấp nhận mất gói tin Dữ liệu được gửi liên tục Ví dụ ứng dụng UDP:\nTruyền video, audio trực tuyến Game online thời gian thực Chat broadcast DNS Multicast, streaming UDP Socket trong Java Java hỗ trợ UDP thông qua hai lớp chính:\nDatagramSocket: quản lý socket UDP DatagramPacket: đại diện cho gói dữ liệu UDP UDP không phân biệt client hay server rõ ràng như TCP.\nMỗi chương trình chỉ cần một DatagramSocket để gửi và nhận dữ liệu.\nDatagramPacket là gì? DatagramPacket là gói dữ liệu UDP, bao gồm:\nDữ liệu cần gửi Địa chỉ IP đích Số hiệu cổng Mỗi lần gửi hoặc nhận dữ liệu, UDP làm việc với một DatagramPacket riêng biệt.\nLuồng dữ liệu trong UDP UDP không có luồng InputStream / OutputStream như TCP.\nQuy trình truyền dữ liệu UDP:\nTạo DatagramSocket Tạo DatagramPacket chứa dữ liệu Gửi packet đi Nhận packet về Đọc dữ liệu từ packet Mỗi gói tin là độc lập, không liên quan đến các gói khác.\nĐặc điểm quan trọng của UDP Không kiểm soát lỗi Không kiểm soát luồng Không bắt tay kết nối Gửi nhanh, xử lý đơn giản Phù hợp truyền broadcast và multicast Chính vì vậy, UDP thường được dùng khi tốc độ quan trọng hơn độ chính xác tuyệt đối.\nÝ nghĩa của lập trình Socket UDP Nắm vững UDP giúp bạn:\nHiểu bản chất truyền dữ liệu không kết nối Xây dựng ứng dụng thời gian thực Phân biệt rõ TCP và UDP trong thiết kế hệ thống Chuẩn bị cho các chủ đề nâng cao như: Multicast UDP Java RMI Hệ thống phân tán Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính, UDP được sử dụng trong:\nSocket UDP Multicast Ứng dụng truyền tin nhanh Game, streaming, broadcast Hiểu UDP giúp bạn chọn đúng giao thức cho từng bài toán thực tế.\nKết luận Qua bài học này, bạn đã:\nHiểu UDP là gì và cơ chế hoạt động Phân biệt được TCP và UDP Biết vai trò của DatagramSocket và DatagramPacket Hiểu cách truyền dữ liệu không kết nối Chuẩn bị nền tảng cho bài Multicast UDP \u0026amp; Java RMI tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-6/","summary":"Giải thích giao thức UDP và cách Java lập trình Socket UDP – nền tảng cho truyền dữ liệu nhanh, không kết nối.","title":"Bài 6: Lập trình Socket UDP trong Java"},{"content":"Trong các ứng dụng mạng thực tế, đặc biệt là Server, chương trình thường phải xử lý nhiều yêu cầu cùng lúc.\nNếu chỉ sử dụng một luồng thực thi, server sẽ bị tắc nghẽn, các client phải chờ đợi và hiệu năng giảm nghiêm trọng.\nVì vậy, lập trình đa tuyến (Multithreading) và xử lý đồng thời (Concurrency) là kỹ thuật bắt buộc trong lập trình mạng.\nTuyến (Thread) là gì? Thread là một dòng điều khiển tuần tự bên trong một chương trình.\nMột chương trình (process) có thể chứa nhiều thread Các thread có thể chạy đồng thời Mỗi thread thực hiện một nhiệm vụ riêng Thread không phải là một chương trình độc lập,\nnó luôn thuộc về một process.\nProcess và Thread Process:\nCó không gian bộ nhớ riêng Chạy độc lập với process khác Tạo và chuyển đổi tốn nhiều tài nguyên Thread:\nChia sẻ bộ nhớ với các thread khác trong cùng process Tạo nhanh hơn process Chuyển đổi nhanh hơn Nhờ thread, chương trình có thể thực hiện nhiều công việc cùng lúc trong cùng một ứng dụng.\nVì sao cần lập trình đa tuyến? Lập trình đa tuyến giúp:\nTăng hiệu suất và khả năng đáp ứng Tận dụng thời gian chờ đợi (I/O, mạng, tải file) Chia nhỏ tác vụ và xử lý đồng thời Cải thiện trải nghiệm người dùng Trong lập trình mạng, đa tuyến cho phép server phục vụ nhiều client cùng lúc.\nThực thi Thread trong Java Trong Java, một thread bắt đầu chạy khi gọi phương thức start().\nKhi thread chạy, JVM thực thi mã trong phương thức run() Khi run() kết thúc, thread cũng kết thúc Một thread không thể start lại, muốn chạy lại phải tạo thread mới Thread cần có điều kiện dừng rõ ràng để tránh chạy vô hạn.\nỨng dụng đa tuyến trong lập trình mạng Ứng dụng Chat đa tuyến Một ví dụ tiêu biểu của đa tuyến trong mạng là ứng dụng chat nhiều client – một server.\nĐặc điểm:\nServer chấp nhận nhiều client kết nối cùng lúc Mỗi client được xử lý bởi một thread riêng Tin nhắn từ một client được gửi tới tất cả client khác Server ghi lại nội dung chat vào file log Thông qua ví dụ này, sinh viên hiểu rõ:\nCách server xử lý nhiều kết nối đồng thời Cách phối hợp giữa socket và thread Vai trò của đa tuyến trong ứng dụng mạng Xử lý đồng thời (Concurrency) Xử lý đồng thời xảy ra khi nhiều thread:\nChạy cùng lúc Truy cập tài nguyên chung (biến, file, bộ nhớ) Nếu không kiểm soát tốt, chương trình có thể gặp các vấn đề nghiêm trọng.\nRace Condition Race Condition xảy ra khi:\nNhiều thread cùng truy cập và thay đổi dữ liệu chung Kết quả phụ thuộc vào thứ tự thực thi không xác định Điều này có thể dẫn đến:\nDữ liệu sai lệch Kết quả không nhất quán Lỗi khó phát hiện Đồng bộ hóa (Synchronization) Để tránh race condition, Java cung cấp cơ chế đồng bộ hóa:\nĐảm bảo chỉ một thread được truy cập tài nguyên tại một thời điểm Giữ cho dữ liệu luôn nhất quán Đồng bộ hóa là nền tảng để xây dựng các ứng dụng an toàn và ổn định khi chạy đa tuyến.\nCác vấn đề thường gặp trong xử lý đồng thời Một số vấn đề phổ biến:\nRace condition: tranh chấp dữ liệu Deadlock: các thread chờ nhau vô hạn Livelock: các thread liên tục phản ứng nhưng không tiến triển Starvation: thread không bao giờ được cấp tài nguyên Những vấn đề này khiến lập trình đa tuyến trở nên phức tạp và khó debug.\nLập lịch Thread trong Java Java sử dụng cơ chế lập lịch theo độ ưu tiên:\nMỗi thread có độ ưu tiên từ MIN_PRIORITY đến MAX_PRIORITY JVM chọn thread runnable có độ ưu tiên cao hơn để chạy Thread có thể nhường CPU cho thread khác bằng cách gọi yield() Việc hiểu cơ chế lập lịch giúp lập trình viên thiết kế thread hợp lý hơn.\nÝ nghĩa của lập trình đa tuyến và xử lý đồng thời Nắm vững kiến thức bài này giúp bạn:\nXây dựng server xử lý nhiều client Viết ứng dụng mạng hiệu năng cao Tránh lỗi tranh chấp dữ liệu Chuẩn bị cho các chủ đề nâng cao như: Server đa tuyến Pooling Threads Multicast UDP Java RMI Hệ thống phân tán Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm thread và multithreading Phân biệt process và thread Biết vai trò của đa tuyến trong lập trình mạng Hiểu các vấn đề xử lý đồng thời và race condition Chuẩn bị nền tảng cho các bài học nâng cao tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-7/","summary":"Giải thích lập trình đa tuyến và xử lý đồng thời trong Java – nền tảng cho các ứng dụng mạng nhiều client và hệ thống phân tán.","title":"Bài 7: Lập trình đa tuyến và xử lý đồng thời trong Java"},{"content":"Buổi 8 gồm 2 phần lớn:\nMulticast UDP: gửi dữ liệu từ một nguồn đến nhiều máy nhận cùng lúc (1 → N). Java RMI: gọi phương thức từ xa giữa các ứng dụng Java như gọi hàm bình thường (Remote Method Invocation). Đây là các kỹ thuật thường gặp trong streaming, trò chuyện nhóm, giám sát từ xa và hệ thống phân tán.\n1) UDP Multicast Unicast, Broadcast và Multicast Trong mạng máy tính có 3 kiểu gửi dữ liệu phổ biến:\nUnicast: 1 nguồn → 1 đích\nVí dụ: bạn mở một trang web, server trả dữ liệu cho riêng bạn.\nBroadcast: 1 nguồn → tất cả máy trong mạng nội bộ\nVí dụ: một thông báo phát cho toàn bộ LAN.\nMulticast: 1 nguồn → một nhóm máy đã đăng ký nhận dữ liệu\nVí dụ: server phát stream video cho nhóm người xem cùng lúc.\nMulticast là cách truyền hiệu quả khi nhiều máy cùng cần nhận một nội dung giống nhau.\nTại sao dùng UDP Multicast? UDP Multicast thường được dùng vì:\nHiệu suất cao: gửi 1 lần nhưng nhiều máy nhận → giảm tải mạng và server. Đơn giản, nhanh: UDP là kiểu “gửi và quên”, không phải chờ xác nhận. Tối ưu trong LAN: phù hợp môi trường mạng nội bộ (Local Area Network). Rất hợp streaming: audio/video cần tốc độ và độ trễ thấp hơn là đảm bảo tuyệt đối. Ứng dụng của Multicast Multicast có thể dùng trong:\nTruyền phát multimedia trực tiếp (audio/video streaming) Trò chuyện nhóm, hội thoại nhóm Quảng bá thông tin cấu hình mạng và cập nhật trong hệ thống mạng Game nhiều người chơi (gửi trạng thái game cho nhiều người) Phát thông tin trạng thái/cảnh báo cho nhiều thiết bị Phát tán cập nhật phần mềm trong mạng nội bộ Địa chỉ Multicast IPv4 Trong IPv4:\nClass D là dải địa chỉ dành cho multicast Dải địa chỉ multicast thường gặp: 224.0.0.0 – 239.255.255.255 Một số nhóm multicast hay được nhắc:\n224.0.0.1: tất cả host trong local subnet Multicast Group là gì? Multicast hoạt động theo “nhóm”:\nMột multicast group giống như một kênh. Máy nào muốn nhận dữ liệu phải tham gia nhóm (join group). Khi rời nhóm thì không nhận dữ liệu nữa. Multicast trong Java Java hỗ trợ multicast qua lớp:\njava.net.MulticastSocket (kế thừa từ DatagramSocket) Một số thao tác quan trọng:\njoinGroup(...): tham gia nhóm multicast leaveGroup(...): rời nhóm multicast setTimeToLive(ttl): đặt TTL (thời gian sống của gói tin, qua bao nhiêu router) Quy trình gửi dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket Tham gia nhóm multicast Tạo DatagramPacket chứa dữ liệu + địa chỉ nhóm + port Gửi packet Rời nhóm Ví dụ minh họa (ngắn, chỉ để hiểu):\n1 2 3 4 5 6 7 8 9 10 11 12 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(); socket.joinGroup(group); socket.setTimeToLive(5); byte[] data = \u0026#34;Hello Multicast\u0026#34;.getBytes(); DatagramPacket packet = new DatagramPacket(data, data.length, group, 9876); socket.send(packet); socket.leaveGroup(group); socket.close(); Quy trình nhận dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket lắng nghe trên port Tham gia nhóm multicast Tạo DatagramPacket rỗng để nhận dữ liệu Gọi receive() để chờ gói tin gửi về Đọc dữ liệu từ packet Rời nhóm và đóng socket Ví dụ minh họa (ngắn):\n1 2 3 4 5 6 7 8 9 10 11 12 13 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(9876); socket.joinGroup(group); byte[] buf = new byte[1024]; DatagramPacket packet = new DatagramPacket(buf, buf.length); socket.receive(packet); String msg = new String(packet.getData(), 0, packet.getLength()); System.out.println(\u0026#34;Received: \u0026#34; + msg); socket.leaveGroup(group); socket.close(); 2) Java RMI Java RMI là gì? RMI (Remote Method Invocation) cho phép chương trình Java:\nGọi phương thức của một đối tượng nằm trên máy khác Cảm giác giống như gọi method trong cùng chương trình Nói đơn giản:\nClient gọi: remoteObject.sum(1,2) Server thực thi thật và trả kết quả về cho client RMI giúp che giấu toàn bộ chi tiết mạng phía sau, người lập trình chỉ tập trung vào logic.\nVì sao dùng Java RMI? Java RMI được sử dụng vì:\nTích hợp sẵn trong Java, dễ triển khai nếu cả client và server đều dùng Java Gọi phương thức từ xa đơn giản như gọi hàm thông thường Hỗ trợ dữ liệu phức tạp: đối tượng, mảng, class tự định nghĩa Tự động xử lý giao tiếp mạng thông qua cơ chế stub / skeleton Dựa trên TCP/IP nên tương đối ổn định và tin cậy Hạn chế của Java RMI Một số điểm hạn chế cần lưu ý:\nPhụ thuộc Java: chủ yếu phù hợp Java ↔ Java Thiết kế dịch vụ phức tạp vẫn cần tổ chức tốt (đặc biệt khi dùng callback) Quản lý phiên và kết nối không mạnh như các giải pháp hiện đại Bảo mật cần cấu hình cẩn thận trong môi trường thực tế Ý tưởng kiến trúc RMI (hiểu nhanh) Trong Java RMI có các thành phần chính:\nRemote Interface\nKhai báo các phương thức cho phép gọi từ xa\nServer Implementation\nLớp cài đặt interface, chứa logic xử lý thật\nRMI Registry\nNơi đăng ký service để client tìm thấy server\nClient\nTìm (lookup) service trong registry và gọi phương thức\nCác bước triển khai RMI (tóm tắt) Định nghĩa Remote Interface Cài đặt interface bằng một class server (remote object) Viết chương trình server: tạo object và bind vào registry Viết chương trình client: lookup registry và gọi method Chạy RMI registry, chạy server, sau đó chạy client Ví dụ ứng dụng RMI Một số ví dụ thường gặp:\nTính tổng 2 số từ xa Dịch vụ quản lý tài khoản ATM Dịch vụ giám sát nhiệt độ có callback (server gọi ngược lại client) Bài tập gợi ý theo đúng nội dung buổi 8 BT8.01: Mô phỏng streaming video\n(1 server phát, nhiều client nhận dữ liệu)\nBT8.02: Server quản lý tài khoản ATM bằng RMI\n(thêm user, đăng nhập, gửi/rút tiền, lưu lịch sử giao dịch)\nKết luận Qua bài học này, bạn đã:\nHiểu sự khác nhau giữa Unicast, Broadcast và Multicast Nắm được vì sao Multicast UDP phù hợp cho truyền dữ liệu nhóm và streaming Biết cách Java hỗ trợ multicast qua MulticastSocket Hiểu Java RMI và cơ chế gọi phương thức từ xa Chuẩn bị nền tảng cho các bài ứng dụng mạng phân tán và đồ án học phần ","permalink":"http://localhost:1313/blog/bai-viet-8/","summary":"Giải thích Multicast UDP (gửi 1-n) và Java RMI (gọi phương thức từ xa) – nền tảng cho ứng dụng nhóm và hệ phân tán.","title":"Bài 8: Multicast UDP và Java RMI"},{"content":"Sau khi hoàn thành các bài về TCP, UDP, đa tuyến và xử lý đồng thời,\nchúng ta đã có đủ nền tảng để xây dựng một ứng dụng mạng hoàn chỉnh.\nBài học này giúp bạn xâu chuỗi toàn bộ kiến thức đã học,\nhiểu rõ mỗi công nghệ dùng trong trường hợp nào,\nvà cách thiết kế một hệ thống mạng đúng tư duy kỹ sư.\nNhìn lại các mô hình giao tiếp mạng đã học Trong lập trình mạng, các ứng dụng thường được xây dựng dựa trên mô hình Client – Server.\nClient: gửi yêu cầu, nhập dữ liệu, hiển thị kết quả Server: xử lý logic, quản lý dữ liệu, trả kết quả Tùy bài toán, ta lựa chọn giao thức và mô hình phù hợp.\nSo sánh TCP, UDP và Multicast TCP – Giao tiếp tin cậy TCP phù hợp khi:\nCần đảm bảo dữ liệu đúng và đủ Cần kết nối ổn định, hai chiều Ví dụ: chat, truyền file, game theo lượt, hệ thống ngân hàng Đặc trưng:\nCó bắt tay 3 bước Có kiểm soát lỗi, kiểm soát luồng Tốn tài nguyên hơn UDP UDP – Giao tiếp nhanh, không kết nối UDP phù hợp khi:\nƯu tiên tốc độ Chấp nhận mất gói Ví dụ: game thời gian thực, streaming, cảm biến Đặc trưng:\nKhông kết nối Không đảm bảo thứ tự Ít độ trễ UDP Multicast – Truyền dữ liệu nhóm Multicast được dùng khi:\nMột nguồn → nhiều người nhận Dữ liệu giống nhau cho tất cả client Ví dụ: livestream, thông báo hệ thống, truyền trạng thái Ưu điểm:\nGiảm tải server Tiết kiệm băng thông Phù hợp mạng LAN Vai trò của đa tuyến (Multithreading) Trong thực tế, server không thể xử lý từng client một cách tuần tự.\nĐa tuyến giúp:\nNhiều client kết nối cùng lúc Không client nào bị “đóng băng” Tăng khả năng mở rộng hệ thống Ví dụ:\nServer chat: mỗi client là một thread Server TCP: mỗi socket được xử lý riêng Thiết kế một ứng dụng mạng hoàn chỉnh Khi thiết kế, cần xác định rõ:\nGiao thức: TCP hay UDP? Mô hình: 1–1, 1–n, n–n? Đồng thời hay tuần tự? Client gửi gì? Server xử lý gì? Một thiết kế tốt luôn:\nPhân tách rõ giao tiếp – xử lý – dữ liệu Dễ mở rộng Dễ bảo trì Liên hệ với đồ án học phần Các đồ án như:\nChat đa tuyến Oẳn Tù Tì client–server Streaming UDP Dịch vụ RMI Đều là sự kết hợp của các kiến thức đã học,\nkhông phải nội dung mới.\nKết luận Qua bài học này, bạn đã:\nHệ thống lại toàn bộ kiến thức lập trình mạng Hiểu rõ khi nào dùng TCP, UDP, Multicast Nắm được vai trò của đa tuyến Biết cách tư duy thiết kế một ứng dụng mạng hoàn chỉnh Đây là bước chuẩn bị quan trọng trước khi vận dụng toàn bộ kiến thức vào một hệ thống thực tế.\n","permalink":"http://localhost:1313/blog/bai-viet-9/","summary":"Tổng hợp kiến thức TCP, UDP, đa tuyến và cách thiết kế ứng dụng mạng Client–Server hoàn chỉnh.","title":"Bài 9: Tổng hợp kiến thức \u0026 thiết kế ứng dụng mạng"},{"content":"Bài cuối cùng của học phần không nhằm giới thiệu công nghệ mới,\nmà tập trung vào cách vận dụng kiến thức đã học vào thực tế.\nĐây là giai đoạn chuyển từ:\n“Biết dùng” → “Biết thiết kế” → “Biết đánh giá hệ thống”\nTư duy vận dụng kiến thức Một ứng dụng mạng hoàn chỉnh cần trả lời được các câu hỏi:\nVì sao chọn TCP mà không phải UDP? Vì sao cần đa tuyến? Server có chịu được nhiều client không? Hệ thống có mở rộng được không? Đây chính là tư duy kỹ sư, không phải chỉ “chạy được là xong”.\nĐánh giá một ứng dụng mạng Khi hoàn thiện hệ thống, cần xem xét:\n1. Tính đúng đắn Dữ liệu có truyền đúng không? Có mất gói không? Có xử lý lỗi không? 2. Tính đồng thời Nhiều client có dùng chung được không? Có bị treo server không? Có race condition không? 3. Hiệu năng Độ trễ thế nào? Server có bị quá tải không? Có tách luồng hợp lý không? Liên hệ với các mô hình phân tán Các hệ thống đã học là nền tảng cho:\nHệ thống client–server lớn Ứng dụng phân tán Microservices Cloud services Java RMI, TCP đa tuyến hay UDP Multicast\nđều là những viên gạch đầu tiên.\nTừ học phần đến thực tế Sau học phần này, bạn có thể tiếp cận:\nWebSocket REST API gRPC Message Queue (Kafka, RabbitMQ) Hệ thống realtime Tư duy lập trình mạng không thay đổi, chỉ công nghệ thay đổi.\nTổng kết toàn bộ học phần Qua toàn bộ chuỗi bài, bạn đã:\nHiểu cách dữ liệu đi qua mạng Làm việc với TCP, UDP, Multicast Xử lý đa tuyến và đồng thời Tiếp cận lập trình phân tán với RMI Có tư duy thiết kế hệ thống mạng Lời kết Lập trình mạng không chỉ là code socket,\nmà là hiểu cách các hệ thống nói chuyện với nhau.\nNếu bạn hiểu được điều đó,\nbạn đã vượt xa mức “học để qua môn”.\n","permalink":"http://localhost:1313/blog/bai-viet-10/","summary":"Vận dụng toàn bộ kiến thức lập trình mạng để xây dựng, đánh giá và hoàn thiện một ứng dụng thực tế.","title":"Bài 10: Hoàn thiện \u0026 vận dụng lập trình mạng"},{"content":"Lời mở đầu Có những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\nMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\nHọc tập Những năm đại học trôi qua nhanh hơn mình từng nghĩ. Ngày mới bước chân vào giảng đường, mình vẫn còn khá mơ hồ về ngành học, về tương lai, về chính bản thân mình sẽ trở thành ai sau bốn năm. Nhưng rồi từng môn học, từng bài tập nhóm, từng đồ án kéo mình lại gần hơn với cách một hệ thống được hình thành và vận hành.\nHệ thống thông tin không chỉ là lập trình, cũng không đơn thuần là công nghệ. Đó là câu chuyện về con người, quy trình và dữ liệu. Mình học cách đặt câu hỏi, học cách lắng nghe yêu cầu, học cách vẽ ra những sơ đồ tưởng chừng khô khan nhưng lại chứa rất nhiều suy nghĩ phía sau. Dần dần, mình nhận ra mình thích phần “hiểu vấn đề” hơn là chỉ chăm chăm vào lời giải.\nĐịnh hướng Ở thời điểm hiện tại, mình đang định hướng theo con đường Business Analyst (BA). Mình hứng thú với vai trò đứng giữa – không quá xa kỹ thuật, cũng không tách rời nghiệp vụ. Đó là nơi cần sự rõ ràng trong tư duy, sự kiên nhẫn trong giao tiếp và khả năng chuyển hóa những điều mơ hồ thành thứ có thể triển khai được.\nMình không nghĩ BA là một vị trí “nhẹ nhàng” hay “an toàn”. Ngược lại, đó là công việc đòi hỏi phải học rất nhiều, sai rất nhiều và sửa rất nhiều. Nhưng chính điều đó khiến mình thấy phù hợp. Mình muốn hiểu hệ thống trước khi xây dựng nó, muốn biết vì sao người ta see cần một chức năng, chứ không chỉ là nó được viết như thế nào.\nBlog Blog này ra đời khá tự nhiên, giống như một cuốn sổ mở rộng hơn là một trang thể hiện điều gì đó to tát. Mình viết để nhớ, để hệ thống lại những gì đã học, và đôi khi là để sắp xếp lại suy nghĩ của chính mình.\nỞ đây có thể là kiến thức về Hệ thống thông tin, về phân tích nghiệp vụ, về lập trình, hoặc đơn giản là những trải nghiệm học tập và va chạm trong quá trình làm đồ án, làm việc nhóm, và chuẩn bị bước ra môi trường thực tế. Mình không mong mọi thứ phải hoàn hảo, chỉ mong nó thật và có ích cho ai đó đang đi trên con đường tương tự.\nLời kết Mình đang ở một giai đoạn chưa thể gọi là trưởng thành, nhưng cũng không còn quá non nớt. Vẫn đang học, vẫn đang thử, vẫn đang sai và sửa mỗi ngày. Nếu có một điều mình mong giữ được lâu nhất, thì đó là sự tò mò và tinh thần học hỏi – những thứ giúp mình không đứng yên giữa rất nhiều lựa chọn ngoài kia.\nCảm ơn bạn đã ghé qua và đọc những dòng này. Hy vọng ở một thời điểm nào đó, những chia sẻ nhỏ ở đây sẽ chạm đến bạn – dù chỉ là một chút. \u0026ldquo;Học để chia sẻ, chia sẻ để học nhiều hơn.\u0026rdquo;\nLiên hệ Nếu bạn muốn gửi cho mình vài dòng trao đổi,\nbạn có thể liên hệ với mình qua Email hoặc GitHub ,Facebook dưới đây.\nCảm ơn bạn đã ghé thăm blog! ","permalink":"http://localhost:1313/about/","summary":"\u003ch2 id=\"lời-mở-đầu\"\u003eLời mở đầu\u003c/h2\u003e\n\u003cp\u003eCó những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\u003c/p\u003e\n\u003cp\u003eMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\u003c/p\u003e","title":"Giới thiệu"},{"content":"Trong lập trình mạng, trước khi kết nối, ta phải biết \u0026ldquo;địa chỉ nhà\u0026rdquo; (IP) của mình và đối phương. Java cung cấp class\nHình 1.1: Hiệu ứng Dunning–Kruger – mức độ tự tin thay đổi theo kinh nghiệm học tập\nGóc nhìn học tập: Hiệu ứng Dunning–Kruger InetAddress để làm việc này.\nĐịa chỉ IP là gì trong lập trình mạng? IP (Internet Protocol Address) là địa chỉ định danh của một thiết bị khi tham gia vào mạng máy tính.\nTrong lập trình mạng, IP đóng vai trò quan trọng trong việc:\nXác định máy gửi và máy nhận Định tuyến dữ liệu trong quá trình truyền thông Thiết lập kết nối giữa các tiến trình chạy trên những máy khác nhau Nếu không có địa chỉ IP, các máy tính sẽ không thể nhận biết và giao tiếp với nhau.\nVai trò của lớp InetAddress trong Java Lớp InetAddress đại diện cho một địa chỉ IP trong Java.\nThông qua lớp này, lập trình viên có thể:\nLấy địa chỉ IP của máy đang chạy chương trình Lấy tên máy (hostname) Phân giải tên miền sang địa chỉ IP Chuẩn bị thông tin để tạo Socket hoặc ServerSocket Hầu hết các chương trình lập trình mạng trong Java đều sử dụng InetAddress ở bước khởi tạo.\nPhân tích ý nghĩa các lệnh trong chương trình InetAddress.getLocalHost()\n→ Trả về đối tượng đại diện cho máy cục bộ (localhost).\ngetHostName()\n→ Lấy tên máy do hệ điều hành hoặc mạng gán.\ngetHostAddress()\n→ Lấy địa chỉ IP của máy dưới dạng chuỗi.\nViệc in ra hostname và IP giúp:\nKiểm tra cấu hình mạng Xác định đúng máy khi kết nối Client – Server Debug lỗi mạng Một số lưu ý khi lấy IP trong Java Khi máy không kết nối mạng, IP có thể là 127.0.0.1 Khi máy có nhiều card mạng (WiFi, LAN, VPN), IP trả về có thể không phải IP Internet Trên Server, hostname và IP thường khác máy cá nhân Ứng dụng thực tế Việc xác định IP của máy thường được sử dụng trong:\nChương trình Client – Server Thông báo IP Server cho Client kết nối Kiểm tra kết nối mạng LAN Ghi log và giám sát hệ thống Kết luận Qua bài học này, ta đã:\nHiểu vai trò của địa chỉ IP trong lập trình mạng Biết cách lấy IP bằng lớp InetAddress Chuẩn bị nền tảng cho các kỹ thuật TCP, UDP và RMI Liên hệ với học phần Lập trình Mạng máy tính Bài học này nằm trong nội dung mở đầu của học phần Lập trình Mạng máy tính (CMP180) tại Trường Đại học Công nghệ TP.HCM (HUTECH).\nTrong lộ trình môn học, sinh viên sẽ lần lượt tiếp cận các nội dung:\nKiến thức nền tảng về mạng và lập trình mạng Quản lý luồng nhập xuất (I/O) Quản lý địa chỉ và kết nối mạng Lập trình Socket TCP và UDP Xử lý đa tuyến, đa luồng Multicast UDP và Java RMI Thực hiện đồ án học phần cá nhân Mục tiêu của bài học Thông qua Bài 1, sinh viên sẽ:\nLàm quen với môi trường lập trình mạng bằng Java Hiểu được vai trò của địa chỉ IP trong giao tiếp mạng Biết cách sử dụng lớp InetAddress để lấy IP và hostname Chuẩn bị nền tảng cho các bài học tiếp theo về Socket và Server – Client ","permalink":"http://localhost:1313/blog/bai-viet-1/","summary":"GIỚI THIỆU HỌC PHẦN.","title":"Bài 1: Tổng quan khoá học"},{"content":"Trong lập trình mạng, nếu IP được xem như địa chỉ nhà của một máy tính trong mạng,\nthì Port (cổng) chính là số hiệu dùng để xác định chương trình hoặc dịch vụ cụ thể đang chạy trên máy đó.\nMột máy tính có thể chạy đồng thời nhiều ứng dụng mạng như Web Server, Database Server, Game Server hoặc Chat Server.\nMỗi ứng dụng bắt buộc phải gắn với một Port riêng để hệ điều hành có thể phân biệt và định tuyến dữ liệu chính xác.\nPort nằm ở đâu trong mô hình TCP/IP? Trong bộ giao thức TCP/IP, Port thuộc về Transport Layer (Tầng giao vận) và được sử dụng bởi hai giao thức chính là TCP và UDP.\nĐịa chỉ IP xác định máy nào sẽ nhận dữ liệu Port xác định ứng dụng nào trên máy đó sẽ xử lý dữ liệu Sự kết hợp giữa IP + Port tạo thành một Socket, là điểm cuối (endpoint) của quá trình giao tiếp mạng.\nCác loại Port phổ biến Port được đánh số từ 0 đến 65535 và được chia thành ba nhóm chính:\nInternet và các End Devices Trước khi tìm hiểu về Port, cần hiểu Internet được cấu thành từ hàng tỷ thiết bị đầu cuối (End Devices) như máy tính, điện thoại, máy chủ và các thiết bị IoT.\nCác thiết bị này kết nối với nhau thông qua nhiều lớp mạng khác nhau, và mỗi thiết bị khi tham gia giao tiếp mạng đều cần có địa chỉ IP và Port để định danh. Hình 2.1: Sơ đồ minh họa Internet và các thiết bị đầu cuối (End Devices) kết nối thông qua các mạng truy cập và mạng lõi.\nTrong quá trình giao tiếp mạng, một thiết bị không chỉ cần địa chỉ IP để xác định vị trí trong mạng, mà còn cần Port để xác định chính xác ứng dụng hoặc dịch vụ đang lắng nghe trên thiết bị đó.\nDo đó, Port đóng vai trò như “điểm tiếp nhận” (endpoint) cho các tiến trình mạng chạy trên cùng một máy.\nMô hình các tầng giao thức TCP/IP Để hiểu rõ Port hoạt động ở đâu và vì sao Server cần Port, ta cần nắm được mô hình giao thức TCP/IP – nền tảng của mọi ứng dụng mạng hiện nay.\nHình 2.2: Mô hình các tầng giao thức TCP/IP và các giao thức tiêu biểu tương ứng với từng tầng.\nTrong mô hình TCP/IP, địa chỉ IP hoạt động ở tầng Internet, giúp xác định thiết bị trong mạng.\nTrong khi đó, Port hoạt động ở tầng Transport (TCP/UDP), giúp xác định chính xác ứng dụng hoặc dịch vụ đang giao tiếp trên thiết bị đó.\nWell-known Ports (0 – 1023) Được dùng cho các dịch vụ chuẩn:\nPort 80: HTTP Port 443: HTTPS Port 21: FTP Port 25: SMTP Registered Ports (1024 – 49151) Thường dùng cho các ứng dụng phổ biến:\nPort 3306: MySQL Port 8080: Web Server thay thế port 80 Dynamic / Private Ports (49152 – 65535) Do hệ điều hành cấp phát tạm thời cho Client khi giao tiếp mạng.\nVì sao Server thường dùng cổng 8080? Cổng 8080 rất phổ biến trong quá trình phát triển và học tập vì:\nTránh xung đột với cổng 80 đang được hệ điều hành chiếm dụng Không cần quyền Administrator khi mở Server Phù hợp cho các Web Server thử nghiệm như: Apache Tomcat Spring Boot Node.js Lỗi thường gặp: “Address already in use” Lỗi này xảy ra khi Server cố gắng mở một Port đã bị chương trình khác chiếm dụng.\nNguyên nhân phổ biến:\nServer cũ chưa được tắt Port đang được dùng bởi dịch vụ khác Chạy nhiều Server cùng lúc Cách khắc phục:\nĐổi sang Port khác (ví dụ: 8080 → 9090) Kiểm tra Port đang sử dụng trong hệ điều hành Đảm bảo chỉ có một Server chạy tại một thời điểm Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), khái niệm Port sẽ được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Xây dựng mô hình Client – Server Java RMI và Multicast Việc hiểu rõ Port là nền tảng bắt buộc trước khi triển khai các ứng dụng mạng thực tế.\nKết luận Qua bài học này, ta đã:\nHiểu được Port là gì và vai trò của Port trong lập trình mạng Nắm được mối quan hệ giữa IP, Port và Socket Giải thích được lý do Server thường sử dụng cổng 8080 Chuẩn bị kiến thức nền cho các bài học tiếp theo về TCP và UDP ","permalink":"http://localhost:1313/blog/bai-viet-2/","summary":"MẠNG MÁY TÍNH \u0026amp; INTERNET.","title":"Bài 2: Kiến thức nền tảng?"},{"content":"Trong lập trình Java, luồng nhập xuất (Input / Output Streams) đóng vai trò trung gian giúp chương trình đọc và ghi dữ liệu từ nhiều nguồn khác nhau như bàn phím, file, console, bộ nhớ và sau này là socket mạng.\nHiểu rõ cơ chế luồng nhập xuất là bước nền bắt buộc trước khi đi vào lập trình Socket TCP, UDP hay Java RMI.\nLuồng (Stream) là gì? Luồng (Stream) là dòng dữ liệu di chuyển\ntừ nguồn → chương trình hoặc từ chương trình → đích.\nKhi Java đọc hoặc ghi dữ liệu, dữ liệu không đi trực tiếp mà luôn được đóng gói và truyền qua luồng.\nLuồng nhập xuất là gì? Luồng nhập xuất là cơ chế cho phép chương trình:\nNhận dữ liệu từ bên ngoài (Input) Ghi dữ liệu ra bên ngoài (Output) Luồng có thể kết nối với nhiều nguồn và đích khác nhau:\nFile Bàn phím Màn hình (console) Bộ nhớ Kết nối mạng (TCP / UDP) Dữ liệu trong luồng tồn tại dưới những dạng nào? Trong Java, dữ liệu trong luồng tồn tại dưới hai dạng chính:\nLuồng byte Luồng ký tự Việc chọn đúng loại luồng ảnh hưởng trực tiếp đến hiệu năng và tính chính xác của chương trình.\nLuồng byte trong Java Đặc điểm Dữ liệu được xử lý dưới dạng nhị phân Phù hợp với: File nhị phân Ảnh, video Socket mạng Dữ liệu phức tạp Các lớp gốc InputStream – luồng đọc byte OutputStream – luồng ghi byte Cả hai đều là lớp trừu tượng (abstract).\nCác luồng byte đọc phổ biến FileInputStream – đọc byte từ file ByteArrayInputStream – đọc từ mảng byte PipedInputStream – đọc từ luồng pipe Các luồng byte ghi phổ biến FileOutputStream – ghi byte vào file ByteArrayOutputStream – ghi vào mảng byte PipedOutputStream – ghi vào luồng pipe Mô hình đọc/ghi dữ liệu với Stream Quy trình chung khi làm việc với luồng:\nTạo đối tượng Stream Gắn Stream với nguồn hoặc đích Đọc/ghi dữ liệu trong vòng lặp Đóng Stream sau khi hoàn tất Luồng ký tự trong Java Đặc điểm Xử lý dữ liệu dạng Unicode Phù hợp với: File văn bản Chuỗi Dữ liệu hiển thị cho người dùng Các lớp gốc Reader – luồng đọc ký tự Writer – luồng ghi ký tự Các luồng ký tự đọc phổ biến FileReader – đọc file văn bản BufferedReader – đọc có bộ đệm StringReader – đọc chuỗi CharArrayReader – đọc mảng ký tự Các luồng ký tự ghi phổ biến FileWriter – ghi vào file văn bản BufferedWriter – ghi có bộ đệm PrintWriter – ghi dữ liệu dạng dễ đọc StringWriter – ghi chuỗi Luồng lọc dữ liệu (Filtered Streams) Luồng lọc dùng để chuyển đổi dữ liệu từ dạng byte/ký tự sang các kiểu dữ liệu khác.\nCác luồng lọc phổ biến DataInputStream DataOutputStream Cho phép đọc/ghi các kiểu dữ liệu nguyên thủy:\nint float double boolean char Đây là cầu nối giữa luồng thô và dữ liệu có kiểu trong Java.\nLưu trạng thái đối tượng – Serialization Serialization là gì? Serialization (chuỗi hóa) là quá trình chuyển đối tượng Java thành luồng byte để:\nLưu vào file Truyền qua mạng Phục hồi lại sau này Deserialization Ngược lại, Deserialization (giải chuỗi) là quá trình:\nĐọc byte Tái tạo lại đối tượng ban đầu Đây là nền tảng cho:\nLưu dữ liệu chương trình Java RMI Truyền object qua mạng Try-with-resources (TWR) Java hỗ trợ Try-with-resources để:\nTự động đóng stream Tránh rò rỉ tài nguyên Code gọn và an toàn hơn So với try-catch truyền thống, TWR:\nÍt lỗi hơn Dễ bảo trì hơn Được khuyến khích sử dụng Các lỗi I/O thường gặp Khi làm việc với luồng, một số exception phổ biến là:\nFileNotFoundException IOException EOFException UnsupportedEncodingException FileAlreadyExistsException AccessDeniedException SocketException MalformedURLException SerializationException InvalidPathException Việc bắt và xử lý exception đúng cách là yêu cầu bắt buộc trong lập trình Java.\nLiên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), luồng nhập xuất được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Truyền dữ liệu Client – Server Java RMI Multicast UDP Không hiểu I/O Stream → không thể làm mạng đúng cách.\nKết luận Qua bài học này, ta đã:\nHiểu khái niệm luồng nhập xuất trong Java Phân biệt luồng byte và luồng ký tự Nắm được cách đọc/ghi dữ liệu với Stream Biết vai trò của Serialization và Filtered Streams Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo Khi xử lý các tác vụ mạng (như gọi API), người mới học JS hay viết code lồng nhau kiểu này:\n1 2 3 4 5 6 7 8 9 10 // Cực hình Callback Hell getData(function(a) { getMoreData(a, function(b) { getMoreData(b, function(c) { getMoreData(c, function(d) { console.log(d); }); }); }); }); ","permalink":"http://localhost:1313/blog/bai-viet-3/","summary":"Tổng quan về Input/Output Streams trong Java – nền tảng cho xử lý file, console và lập trình mạng.","title":"Bài 3: Quản lý luồng nhập xuất trong Java"},{"content":"Trong lập trình mạng, trước khi chương trình có thể gửi hoặc nhận dữ liệu, điều quan trọng nhất là xác định đúng địa chỉ kết nối mạng. Nếu xác định sai địa chỉ, chương trình sẽ không thể giao tiếp, dù phần xử lý dữ liệu có đúng đến đâu.\nBài học này giúp bạn hiểu cách Java làm việc với địa chỉ IP, tên miền (DNS) và URL. Đây là nền tảng bắt buộc trước khi đi vào Socket TCP, UDP, Web Crawler và Java RMI.\nĐịa chỉ kết nối mạng là gì? Địa chỉ kết nối mạng là thông tin dùng để xác định máy nào trong mạng cần giao tiếp và dịch vụ nào trên máy đó sẽ xử lý dữ liệu.\nTrong Internet, địa chỉ kết nối thường bao gồm:\nĐịa chỉ IP Tên miền (Domain Name) Cổng (Port) Giao thức (Protocol) DNS – Domain Name System Hình 4.1 – Mô hình hoạt động của DNS (Domain Name System)\nClient gửi yêu cầu phân giải tên miền đến DNS Server, DNS trả về địa chỉ IP tương ứng để client kết nối đến server đích.*\nCon người dễ nhớ tên miền hơn các dãy số IP.\nDNS (Domain Name System) có nhiệm vụ ánh xạ tên miền sang địa chỉ IP, giúp client tìm đúng server cần kết nối.\nVí dụ:\ngoogle.com tương ứng với nhiều địa chỉ IP khác nhau www.cs.yale.edu tương ứng với 128.36.229.30 Nhờ DNS, người dùng không cần ghi nhớ địa chỉ IP khi truy cập Internet. *Hình 4.2 minh họa cấu trúc phân cấp của hệ thống DNS, bao gồm Root Domain, các Top-Level Domain (com, edu, org, vn, …) và các tên miền con phía dưới.\nCấu trúc phân cấp này giúp DNS hoạt động hiệu quả và dễ mở rộng trên toàn Internet.*\nĐịa chỉ IPv4 *Hình 4.3 minh họa khái niệm Zone trong DNS.\nMỗi Zone là một phần của không gian tên miền và được quản lý bởi một DNS Server có thẩm quyền.\nViệc chia DNS thành các Zone giúp hệ thống dễ quản lý, phân quyền và tăng độ tin cậy.*\nIPv4 là dạng địa chỉ phổ biến, gồm 32 bit, thường được viết thành bốn nhóm số.\nVí dụ:\n192.168.1.1 8.8.8.8 Một số dải địa chỉ đặc biệt:\n127.x.x.x là loopback (localhost) 224.0.0.0 – 239.255.255.255 là multicast Lớp InetAddress trong Java Java cung cấp lớp InetAddress để làm việc với địa chỉ IP và DNS.\nLớp này thường được dùng để:\nPhân giải tên miền sang IP Kiểm tra loại địa chỉ Kiểm tra khả năng kết nối mạng Ví dụ minh họa:\n1 InetAddress address = InetAddress.getByName(\u0026#34;google.com\u0026#34;); URL – Uniform Resource Locator URL được dùng để xác định tài nguyên trên Internet như trang web, file hoặc dịch vụ.\nMột URL đầy đủ thường bao gồm các thành phần sau:\nGiao thức (Protocol) Tên miền (Host) Cổng (Port) Đường dẫn (Path) Chuỗi truy vấn (Query) Ví dụ một URL đầy đủ: https://www.hutech.edu.vn/admission?id=123\nURL cho biết lấy dữ liệu ở đâu và bằng cách nào.\nLớp URL trong Java Lớp URL cho phép chương trình Java:\nPhân tích các thành phần của URL Kết nối tới server Đọc dữ liệu từ Internet Ví dụ minh họa:\n1 URL url = new URL(\u0026#34;https://www.example.com\u0026#34;); Ý nghĩa của việc quản lý địa chỉ kết nối mạng Hiểu rõ cách quản lý địa chỉ mạng giúp:\nTránh kết nối sai server Chuẩn bị đúng địa chỉ cho Socket TCP/UDP Hiểu cách Web Crawler hoạt động Nắm vững mô hình Client – Server Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm địa chỉ kết nối mạng Biết vai trò của DNS và IPv4 Nắm được cách Java làm việc với InetAddress Hiểu cấu trúc và vai trò của URL Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-4/","summary":"Tìm hiểu cách Java quản lý địa chỉ mạng thông qua InetAddress, URL, URLConnection và DNS.","title":"Bài 4: Quản lý địa chỉ kết nối mạng trong Java"},{"content":"Trong lập trình mạng, TCP Socket là cơ chế quan trọng nhất để xây dựng các ứng dụng Client – Server có độ tin cậy cao.\nBài học này giúp bạn hiểu TCP là gì, vì sao cần TCP, và cách Java triển khai TCP thông qua Socket và ServerSocket.\nĐây là bước chuyển tiếp trực tiếp từ kiến thức địa chỉ mạng (IP, DNS, URL) sang giao tiếp dữ liệu thực tế giữa các chương trình.\nTCP là gì? TCP (Transmission Control Protocol) là giao thức truyền thông hướng kết nối, đảm bảo dữ liệu được truyền:\nĐúng thứ tự Đầy đủ Không bị mất mát Không bị trùng lặp Trước khi truyền dữ liệu, TCP yêu cầu thiết lập kết nối giữa hai bên, và chỉ khi kết nối thành công thì dữ liệu mới được trao đổi.\nVì sao sử dụng TCP? TCP được sử dụng khi ứng dụng yêu cầu độ tin cậy cao, ví dụ:\nỨng dụng chat Ứng dụng client–server Truyền file Game online theo lượt Hệ thống ngân hàng, thương mại điện tử TCP cung cấp các cơ chế quan trọng:\nĐảm bảo dữ liệu: gói tin bị mất sẽ được gửi lại Kiểm soát lỗi: phát hiện và sửa lỗi trong quá trình truyền Kiểm soát luồng: tránh làm quá tải phía nhận Giao tiếp hai chiều: cho phép gửi và nhận dữ liệu đồng thời Cơ chế hoạt động của TCP Quá trình giao tiếp TCP gồm ba giai đoạn chính:\nThiết lập kết nối (Bắt tay 3 bước – Three-way Handshake) Truyền dữ liệu Giải phóng kết nối Nhờ cơ chế này, TCP đảm bảo rằng hai bên luôn sẵn sàng trước khi truyền và kết thúc an toàn sau khi hoàn tất.\nMô hình Client – Server Các ứng dụng TCP thường hoạt động theo mô hình Client – Server.\nServer:\nChạy trước Lắng nghe yêu cầu kết nối Cung cấp dịch vụ Trả kết quả cho client Client:\nChạy sau Chủ động kết nối tới server Gửi yêu cầu Nhận phản hồi từ server Quá trình giao tiếp gồm:\nClient gửi yêu cầu Server xử lý Server trả kết quả cho client Socket trong Java Trong Java, Socket đại diện cho điểm cuối giao tiếp giữa client và server khi sử dụng TCP.\nSocket cho phép:\nGửi dữ liệu tới server Nhận dữ liệu từ server Giao tiếp hai chiều thông qua luồng nhập/xuất Ví dụ minh họa tạo Socket phía client:\n1 Socket socket = new Socket(\u0026#34;localhost\u0026#34;, 8080); ServerSocket trong Java ServerSocket được sử dụng ở phía server để:\nMở một cổng lắng nghe Chờ client kết nối Chấp nhận kết nối và tạo Socket giao tiếp ServerSocket đóng vai trò như cửa ngõ, cho phép các client kết nối vào server.\nVí dụ minh họa:\n1 ServerSocket server = new ServerSocket(8080); Luồng dữ liệu trong TCP Socket Sau khi kết nối TCP được thiết lập, client và server trao đổi dữ liệu thông qua các luồng:\nInputStream: dùng để đọc dữ liệu từ socket OutputStream: dùng để ghi dữ liệu vào socket Luồng dữ liệu này hoạt động tương tự như I/O Stream đã học ở bài trước,\nnhưng nguồn và đích là mạng thay vì file hay bàn phím.\nVí dụ ứng dụng: Trò chơi Oẳn Tù Tì Một bài tập tiêu biểu sử dụng TCP Socket là trò chơi Oẳn Tù Tì theo mô hình Client – Server.\nĐặc điểm Server quản lý luật chơi và điểm số Hai client gửi lựa chọn (kéo – búa – bao) Server xác định kết quả và gửi lại cho client Dữ liệu được truyền qua TCP để đảm bảo chính xác Thông qua bài tập này, sinh viên hiểu rõ:\nCách thiết lập kết nối TCP Cách trao đổi dữ liệu giữa nhiều client Cách xử lý lỗi mạng và ngoại lệ Ý nghĩa của lập trình TCP Socket Việc nắm vững TCP Socket giúp bạn:\nHiểu bản chất giao tiếp mạng Xây dựng hệ thống Client – Server thực tế Chuẩn bị cho các bài nâng cao như: Đa tuyến (Multi-thread) Socket UDP Java RMI Ứng dụng mạng phân tán Kết luận Qua bài học này, bạn đã:\nHiểu TCP là gì và vì sao cần TCP Nắm được mô hình Client – Server Biết vai trò của Socket và ServerSocket trong Java Hiểu cách dữ liệu được truyền qua TCP Chuẩn bị nền tảng cho các bài học UDP và xử lý đồng thời tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-5/","summary":"Giải thích mô hình Client–Server và cách lập trình Socket TCP trong Java – nền tảng cho giao tiếp mạng tin cậy.","title":"Bài 5: Lập trình Socket TCP trong Java"},{"content":"#Trong lập trình mạng, không phải lúc nào ứng dụng cũng cần độ tin cậy tuyệt đối như TCP.\nTrong nhiều trường hợp, điều quan trọng hơn là tốc độ truyền nhanh và độ trễ thấp.\nBài học này giới thiệu UDP Socket – cơ chế truyền dữ liệu không kết nối, được sử dụng rộng rãi trong các ứng dụng thời gian thực.\nUDP là gì? UDP (User Datagram Protocol) là giao thức truyền thông không hướng kết nối.\nĐiều này có nghĩa là:\nKhông thiết lập kết nối trước khi truyền Không đảm bảo dữ liệu đến nơi Không đảm bảo thứ tự gói tin Không tự động gửi lại gói tin bị mất UDP gửi dữ liệu theo từng datagram (gói tin độc lập).\nSo sánh TCP và UDP TCP UDP Có kết nối Không kết nối Đảm bảo dữ liệu Không đảm bảo Truyền theo luồng Truyền theo gói Độ trễ cao hơn Độ trễ thấp Phù hợp dữ liệu quan trọng Phù hợp dữ liệu thời gian thực Khi nào sử dụng UDP? UDP được sử dụng khi:\nCần truyền nhanh Có thể chấp nhận mất gói tin Dữ liệu được gửi liên tục Ví dụ ứng dụng UDP:\nTruyền video, audio trực tuyến Game online thời gian thực Chat broadcast DNS Multicast, streaming UDP Socket trong Java Java hỗ trợ UDP thông qua hai lớp chính:\nDatagramSocket: quản lý socket UDP DatagramPacket: đại diện cho gói dữ liệu UDP UDP không phân biệt client hay server rõ ràng như TCP.\nMỗi chương trình chỉ cần một DatagramSocket để gửi và nhận dữ liệu.\nDatagramPacket là gì? DatagramPacket là gói dữ liệu UDP, bao gồm:\nDữ liệu cần gửi Địa chỉ IP đích Số hiệu cổng Mỗi lần gửi hoặc nhận dữ liệu, UDP làm việc với một DatagramPacket riêng biệt.\nLuồng dữ liệu trong UDP UDP không có luồng InputStream / OutputStream như TCP.\nQuy trình truyền dữ liệu UDP:\nTạo DatagramSocket Tạo DatagramPacket chứa dữ liệu Gửi packet đi Nhận packet về Đọc dữ liệu từ packet Mỗi gói tin là độc lập, không liên quan đến các gói khác.\nĐặc điểm quan trọng của UDP Không kiểm soát lỗi Không kiểm soát luồng Không bắt tay kết nối Gửi nhanh, xử lý đơn giản Phù hợp truyền broadcast và multicast Chính vì vậy, UDP thường được dùng khi tốc độ quan trọng hơn độ chính xác tuyệt đối.\nÝ nghĩa của lập trình Socket UDP Nắm vững UDP giúp bạn:\nHiểu bản chất truyền dữ liệu không kết nối Xây dựng ứng dụng thời gian thực Phân biệt rõ TCP và UDP trong thiết kế hệ thống Chuẩn bị cho các chủ đề nâng cao như: Multicast UDP Java RMI Hệ thống phân tán Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính, UDP được sử dụng trong:\nSocket UDP Multicast Ứng dụng truyền tin nhanh Game, streaming, broadcast Hiểu UDP giúp bạn chọn đúng giao thức cho từng bài toán thực tế.\nKết luận Qua bài học này, bạn đã:\nHiểu UDP là gì và cơ chế hoạt động Phân biệt được TCP và UDP Biết vai trò của DatagramSocket và DatagramPacket Hiểu cách truyền dữ liệu không kết nối Chuẩn bị nền tảng cho bài Multicast UDP \u0026amp; Java RMI tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-6/","summary":"Giải thích giao thức UDP và cách Java lập trình Socket UDP – nền tảng cho truyền dữ liệu nhanh, không kết nối.","title":"Bài 6: Lập trình Socket UDP trong Java"},{"content":"Trong các ứng dụng mạng thực tế, đặc biệt là Server, chương trình thường phải xử lý nhiều yêu cầu cùng lúc.\nNếu chỉ sử dụng một luồng thực thi, server sẽ bị tắc nghẽn, các client phải chờ đợi và hiệu năng giảm nghiêm trọng.\nVì vậy, lập trình đa tuyến (Multithreading) và xử lý đồng thời (Concurrency) là kỹ thuật bắt buộc trong lập trình mạng.\nTuyến (Thread) là gì? Thread là một dòng điều khiển tuần tự bên trong một chương trình.\nMột chương trình (process) có thể chứa nhiều thread Các thread có thể chạy đồng thời Mỗi thread thực hiện một nhiệm vụ riêng Thread không phải là một chương trình độc lập,\nnó luôn thuộc về một process.\nProcess và Thread Process:\nCó không gian bộ nhớ riêng Chạy độc lập với process khác Tạo và chuyển đổi tốn nhiều tài nguyên Thread:\nChia sẻ bộ nhớ với các thread khác trong cùng process Tạo nhanh hơn process Chuyển đổi nhanh hơn Nhờ thread, chương trình có thể thực hiện nhiều công việc cùng lúc trong cùng một ứng dụng.\nVì sao cần lập trình đa tuyến? Lập trình đa tuyến giúp:\nTăng hiệu suất và khả năng đáp ứng Tận dụng thời gian chờ đợi (I/O, mạng, tải file) Chia nhỏ tác vụ và xử lý đồng thời Cải thiện trải nghiệm người dùng Trong lập trình mạng, đa tuyến cho phép server phục vụ nhiều client cùng lúc.\nThực thi Thread trong Java Trong Java, một thread bắt đầu chạy khi gọi phương thức start().\nKhi thread chạy, JVM thực thi mã trong phương thức run() Khi run() kết thúc, thread cũng kết thúc Một thread không thể start lại, muốn chạy lại phải tạo thread mới Thread cần có điều kiện dừng rõ ràng để tránh chạy vô hạn.\nỨng dụng đa tuyến trong lập trình mạng Ứng dụng Chat đa tuyến Một ví dụ tiêu biểu của đa tuyến trong mạng là ứng dụng chat nhiều client – một server.\nĐặc điểm:\nServer chấp nhận nhiều client kết nối cùng lúc Mỗi client được xử lý bởi một thread riêng Tin nhắn từ một client được gửi tới tất cả client khác Server ghi lại nội dung chat vào file log Thông qua ví dụ này, sinh viên hiểu rõ:\nCách server xử lý nhiều kết nối đồng thời Cách phối hợp giữa socket và thread Vai trò của đa tuyến trong ứng dụng mạng Xử lý đồng thời (Concurrency) Xử lý đồng thời xảy ra khi nhiều thread:\nChạy cùng lúc Truy cập tài nguyên chung (biến, file, bộ nhớ) Nếu không kiểm soát tốt, chương trình có thể gặp các vấn đề nghiêm trọng.\nRace Condition Race Condition xảy ra khi:\nNhiều thread cùng truy cập và thay đổi dữ liệu chung Kết quả phụ thuộc vào thứ tự thực thi không xác định Điều này có thể dẫn đến:\nDữ liệu sai lệch Kết quả không nhất quán Lỗi khó phát hiện Đồng bộ hóa (Synchronization) Để tránh race condition, Java cung cấp cơ chế đồng bộ hóa:\nĐảm bảo chỉ một thread được truy cập tài nguyên tại một thời điểm Giữ cho dữ liệu luôn nhất quán Đồng bộ hóa là nền tảng để xây dựng các ứng dụng an toàn và ổn định khi chạy đa tuyến.\nCác vấn đề thường gặp trong xử lý đồng thời Một số vấn đề phổ biến:\nRace condition: tranh chấp dữ liệu Deadlock: các thread chờ nhau vô hạn Livelock: các thread liên tục phản ứng nhưng không tiến triển Starvation: thread không bao giờ được cấp tài nguyên Những vấn đề này khiến lập trình đa tuyến trở nên phức tạp và khó debug.\nLập lịch Thread trong Java Java sử dụng cơ chế lập lịch theo độ ưu tiên:\nMỗi thread có độ ưu tiên từ MIN_PRIORITY đến MAX_PRIORITY JVM chọn thread runnable có độ ưu tiên cao hơn để chạy Thread có thể nhường CPU cho thread khác bằng cách gọi yield() Việc hiểu cơ chế lập lịch giúp lập trình viên thiết kế thread hợp lý hơn.\nÝ nghĩa của lập trình đa tuyến và xử lý đồng thời Nắm vững kiến thức bài này giúp bạn:\nXây dựng server xử lý nhiều client Viết ứng dụng mạng hiệu năng cao Tránh lỗi tranh chấp dữ liệu Chuẩn bị cho các chủ đề nâng cao như: Server đa tuyến Pooling Threads Multicast UDP Java RMI Hệ thống phân tán Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm thread và multithreading Phân biệt process và thread Biết vai trò của đa tuyến trong lập trình mạng Hiểu các vấn đề xử lý đồng thời và race condition Chuẩn bị nền tảng cho các bài học nâng cao tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-7/","summary":"Giải thích lập trình đa tuyến và xử lý đồng thời trong Java – nền tảng cho các ứng dụng mạng nhiều client và hệ thống phân tán.","title":"Bài 7: Lập trình đa tuyến và xử lý đồng thời trong Java"},{"content":"Buổi 8 gồm 2 phần lớn:\nMulticast UDP: gửi dữ liệu từ một nguồn đến nhiều máy nhận cùng lúc (1 → N). Java RMI: gọi phương thức từ xa giữa các ứng dụng Java như gọi hàm bình thường (Remote Method Invocation). Đây là các kỹ thuật thường gặp trong streaming, trò chuyện nhóm, giám sát từ xa và hệ thống phân tán.\n1) UDP Multicast Unicast, Broadcast và Multicast Trong mạng máy tính có 3 kiểu gửi dữ liệu phổ biến:\nUnicast: 1 nguồn → 1 đích\nVí dụ: bạn mở một trang web, server trả dữ liệu cho riêng bạn.\nBroadcast: 1 nguồn → tất cả máy trong mạng nội bộ\nVí dụ: một thông báo phát cho toàn bộ LAN.\nMulticast: 1 nguồn → một nhóm máy đã đăng ký nhận dữ liệu\nVí dụ: server phát stream video cho nhóm người xem cùng lúc.\nMulticast là cách truyền hiệu quả khi nhiều máy cùng cần nhận một nội dung giống nhau.\nTại sao dùng UDP Multicast? UDP Multicast thường được dùng vì:\nHiệu suất cao: gửi 1 lần nhưng nhiều máy nhận → giảm tải mạng và server. Đơn giản, nhanh: UDP là kiểu “gửi và quên”, không phải chờ xác nhận. Tối ưu trong LAN: phù hợp môi trường mạng nội bộ (Local Area Network). Rất hợp streaming: audio/video cần tốc độ và độ trễ thấp hơn là đảm bảo tuyệt đối. Ứng dụng của Multicast Multicast có thể dùng trong:\nTruyền phát multimedia trực tiếp (audio/video streaming) Trò chuyện nhóm, hội thoại nhóm Quảng bá thông tin cấu hình mạng và cập nhật trong hệ thống mạng Game nhiều người chơi (gửi trạng thái game cho nhiều người) Phát thông tin trạng thái/cảnh báo cho nhiều thiết bị Phát tán cập nhật phần mềm trong mạng nội bộ Địa chỉ Multicast IPv4 Trong IPv4:\nClass D là dải địa chỉ dành cho multicast Dải địa chỉ multicast thường gặp: 224.0.0.0 – 239.255.255.255 Một số nhóm multicast hay được nhắc:\n224.0.0.1: tất cả host trong local subnet Multicast Group là gì? Multicast hoạt động theo “nhóm”:\nMột multicast group giống như một kênh. Máy nào muốn nhận dữ liệu phải tham gia nhóm (join group). Khi rời nhóm thì không nhận dữ liệu nữa. Multicast trong Java Java hỗ trợ multicast qua lớp:\njava.net.MulticastSocket (kế thừa từ DatagramSocket) Một số thao tác quan trọng:\njoinGroup(...): tham gia nhóm multicast leaveGroup(...): rời nhóm multicast setTimeToLive(ttl): đặt TTL (thời gian sống của gói tin, qua bao nhiêu router) Quy trình gửi dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket Tham gia nhóm multicast Tạo DatagramPacket chứa dữ liệu + địa chỉ nhóm + port Gửi packet Rời nhóm Ví dụ minh họa (ngắn, chỉ để hiểu):\n1 2 3 4 5 6 7 8 9 10 11 12 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(); socket.joinGroup(group); socket.setTimeToLive(5); byte[] data = \u0026#34;Hello Multicast\u0026#34;.getBytes(); DatagramPacket packet = new DatagramPacket(data, data.length, group, 9876); socket.send(packet); socket.leaveGroup(group); socket.close(); Quy trình nhận dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket lắng nghe trên port Tham gia nhóm multicast Tạo DatagramPacket rỗng để nhận dữ liệu Gọi receive() để chờ gói tin gửi về Đọc dữ liệu từ packet Rời nhóm và đóng socket Ví dụ minh họa (ngắn):\n1 2 3 4 5 6 7 8 9 10 11 12 13 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(9876); socket.joinGroup(group); byte[] buf = new byte[1024]; DatagramPacket packet = new DatagramPacket(buf, buf.length); socket.receive(packet); String msg = new String(packet.getData(), 0, packet.getLength()); System.out.println(\u0026#34;Received: \u0026#34; + msg); socket.leaveGroup(group); socket.close(); 2) Java RMI Java RMI là gì? RMI (Remote Method Invocation) cho phép chương trình Java:\nGọi phương thức của một đối tượng nằm trên máy khác Cảm giác giống như gọi method trong cùng chương trình Nói đơn giản:\nClient gọi: remoteObject.sum(1,2) Server thực thi thật và trả kết quả về cho client RMI giúp che giấu toàn bộ chi tiết mạng phía sau, người lập trình chỉ tập trung vào logic.\nVì sao dùng Java RMI? Java RMI được sử dụng vì:\nTích hợp sẵn trong Java, dễ triển khai nếu cả client và server đều dùng Java Gọi phương thức từ xa đơn giản như gọi hàm thông thường Hỗ trợ dữ liệu phức tạp: đối tượng, mảng, class tự định nghĩa Tự động xử lý giao tiếp mạng thông qua cơ chế stub / skeleton Dựa trên TCP/IP nên tương đối ổn định và tin cậy Hạn chế của Java RMI Một số điểm hạn chế cần lưu ý:\nPhụ thuộc Java: chủ yếu phù hợp Java ↔ Java Thiết kế dịch vụ phức tạp vẫn cần tổ chức tốt (đặc biệt khi dùng callback) Quản lý phiên và kết nối không mạnh như các giải pháp hiện đại Bảo mật cần cấu hình cẩn thận trong môi trường thực tế Ý tưởng kiến trúc RMI (hiểu nhanh) Trong Java RMI có các thành phần chính:\nRemote Interface\nKhai báo các phương thức cho phép gọi từ xa\nServer Implementation\nLớp cài đặt interface, chứa logic xử lý thật\nRMI Registry\nNơi đăng ký service để client tìm thấy server\nClient\nTìm (lookup) service trong registry và gọi phương thức\nCác bước triển khai RMI (tóm tắt) Định nghĩa Remote Interface Cài đặt interface bằng một class server (remote object) Viết chương trình server: tạo object và bind vào registry Viết chương trình client: lookup registry và gọi method Chạy RMI registry, chạy server, sau đó chạy client Ví dụ ứng dụng RMI Một số ví dụ thường gặp:\nTính tổng 2 số từ xa Dịch vụ quản lý tài khoản ATM Dịch vụ giám sát nhiệt độ có callback (server gọi ngược lại client) Bài tập gợi ý theo đúng nội dung buổi 8 BT8.01: Mô phỏng streaming video\n(1 server phát, nhiều client nhận dữ liệu)\nBT8.02: Server quản lý tài khoản ATM bằng RMI\n(thêm user, đăng nhập, gửi/rút tiền, lưu lịch sử giao dịch)\nKết luận Qua bài học này, bạn đã:\nHiểu sự khác nhau giữa Unicast, Broadcast và Multicast Nắm được vì sao Multicast UDP phù hợp cho truyền dữ liệu nhóm và streaming Biết cách Java hỗ trợ multicast qua MulticastSocket Hiểu Java RMI và cơ chế gọi phương thức từ xa Chuẩn bị nền tảng cho các bài ứng dụng mạng phân tán và đồ án học phần ","permalink":"http://localhost:1313/blog/bai-viet-8/","summary":"Giải thích Multicast UDP (gửi 1-n) và Java RMI (gọi phương thức từ xa) – nền tảng cho ứng dụng nhóm và hệ phân tán.","title":"Bài 8: Multicast UDP và Java RMI"},{"content":"Sau khi hoàn thành các bài về TCP, UDP, đa tuyến và xử lý đồng thời,\nchúng ta đã có đủ nền tảng để xây dựng một ứng dụng mạng hoàn chỉnh.\nBài học này giúp bạn xâu chuỗi toàn bộ kiến thức đã học,\nhiểu rõ mỗi công nghệ dùng trong trường hợp nào,\nvà cách thiết kế một hệ thống mạng đúng tư duy kỹ sư.\nNhìn lại các mô hình giao tiếp mạng đã học Trong lập trình mạng, các ứng dụng thường được xây dựng dựa trên mô hình Client – Server.\nClient: gửi yêu cầu, nhập dữ liệu, hiển thị kết quả Server: xử lý logic, quản lý dữ liệu, trả kết quả Tùy bài toán, ta lựa chọn giao thức và mô hình phù hợp.\nSo sánh TCP, UDP và Multicast TCP – Giao tiếp tin cậy TCP phù hợp khi:\nCần đảm bảo dữ liệu đúng và đủ Cần kết nối ổn định, hai chiều Ví dụ: chat, truyền file, game theo lượt, hệ thống ngân hàng Đặc trưng:\nCó bắt tay 3 bước Có kiểm soát lỗi, kiểm soát luồng Tốn tài nguyên hơn UDP UDP – Giao tiếp nhanh, không kết nối UDP phù hợp khi:\nƯu tiên tốc độ Chấp nhận mất gói Ví dụ: game thời gian thực, streaming, cảm biến Đặc trưng:\nKhông kết nối Không đảm bảo thứ tự Ít độ trễ UDP Multicast – Truyền dữ liệu nhóm Multicast được dùng khi:\nMột nguồn → nhiều người nhận Dữ liệu giống nhau cho tất cả client Ví dụ: livestream, thông báo hệ thống, truyền trạng thái Ưu điểm:\nGiảm tải server Tiết kiệm băng thông Phù hợp mạng LAN Vai trò của đa tuyến (Multithreading) Trong thực tế, server không thể xử lý từng client một cách tuần tự.\nĐa tuyến giúp:\nNhiều client kết nối cùng lúc Không client nào bị “đóng băng” Tăng khả năng mở rộng hệ thống Ví dụ:\nServer chat: mỗi client là một thread Server TCP: mỗi socket được xử lý riêng Thiết kế một ứng dụng mạng hoàn chỉnh Khi thiết kế, cần xác định rõ:\nGiao thức: TCP hay UDP? Mô hình: 1–1, 1–n, n–n? Đồng thời hay tuần tự? Client gửi gì? Server xử lý gì? Một thiết kế tốt luôn:\nPhân tách rõ giao tiếp – xử lý – dữ liệu Dễ mở rộng Dễ bảo trì Liên hệ với đồ án học phần Các đồ án như:\nChat đa tuyến Oẳn Tù Tì client–server Streaming UDP Dịch vụ RMI Đều là sự kết hợp của các kiến thức đã học,\nkhông phải nội dung mới.\nKết luận Qua bài học này, bạn đã:\nHệ thống lại toàn bộ kiến thức lập trình mạng Hiểu rõ khi nào dùng TCP, UDP, Multicast Nắm được vai trò của đa tuyến Biết cách tư duy thiết kế một ứng dụng mạng hoàn chỉnh Đây là bước chuẩn bị quan trọng trước khi vận dụng toàn bộ kiến thức vào một hệ thống thực tế.\n","permalink":"http://localhost:1313/blog/bai-viet-9/","summary":"Tổng hợp kiến thức TCP, UDP, đa tuyến và cách thiết kế ứng dụng mạng Client–Server hoàn chỉnh.","title":"Bài 9: Tổng hợp kiến thức \u0026 thiết kế ứng dụng mạng"},{"content":"Bài cuối cùng của học phần không nhằm giới thiệu công nghệ mới,\nmà tập trung vào cách vận dụng kiến thức đã học vào thực tế.\nĐây là giai đoạn chuyển từ:\n“Biết dùng” → “Biết thiết kế” → “Biết đánh giá hệ thống”\nTư duy vận dụng kiến thức Một ứng dụng mạng hoàn chỉnh cần trả lời được các câu hỏi:\nVì sao chọn TCP mà không phải UDP? Vì sao cần đa tuyến? Server có chịu được nhiều client không? Hệ thống có mở rộng được không? Đây chính là tư duy kỹ sư, không phải chỉ “chạy được là xong”.\nĐánh giá một ứng dụng mạng Khi hoàn thiện hệ thống, cần xem xét:\n1. Tính đúng đắn Dữ liệu có truyền đúng không? Có mất gói không? Có xử lý lỗi không? 2. Tính đồng thời Nhiều client có dùng chung được không? Có bị treo server không? Có race condition không? 3. Hiệu năng Độ trễ thế nào? Server có bị quá tải không? Có tách luồng hợp lý không? Liên hệ với các mô hình phân tán Các hệ thống đã học là nền tảng cho:\nHệ thống client–server lớn Ứng dụng phân tán Microservices Cloud services Java RMI, TCP đa tuyến hay UDP Multicast\nđều là những viên gạch đầu tiên.\nTừ học phần đến thực tế Sau học phần này, bạn có thể tiếp cận:\nWebSocket REST API gRPC Message Queue (Kafka, RabbitMQ) Hệ thống realtime Tư duy lập trình mạng không thay đổi, chỉ công nghệ thay đổi.\nTổng kết toàn bộ học phần Qua toàn bộ chuỗi bài, bạn đã:\nHiểu cách dữ liệu đi qua mạng Làm việc với TCP, UDP, Multicast Xử lý đa tuyến và đồng thời Tiếp cận lập trình phân tán với RMI Có tư duy thiết kế hệ thống mạng Lời kết Lập trình mạng không chỉ là code socket,\nmà là hiểu cách các hệ thống nói chuyện với nhau.\nNếu bạn hiểu được điều đó,\nbạn đã vượt xa mức “học để qua môn”.\n","permalink":"http://localhost:1313/blog/bai-viet-10/","summary":"Vận dụng toàn bộ kiến thức lập trình mạng để xây dựng, đánh giá và hoàn thiện một ứng dụng thực tế.","title":"Bài 10: Hoàn thiện \u0026 vận dụng lập trình mạng"},{"content":"Lời mở đầu Có những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\nMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\nHọc tập Những năm đại học trôi qua nhanh hơn mình từng nghĩ. Ngày mới bước chân vào giảng đường, mình vẫn còn khá mơ hồ về ngành học, về tương lai, về chính bản thân mình sẽ trở thành ai sau bốn năm. Nhưng rồi từng môn học, từng bài tập nhóm, từng đồ án kéo mình lại gần hơn với cách một hệ thống được hình thành và vận hành.\nHệ thống thông tin không chỉ là lập trình, cũng không đơn thuần là công nghệ. Đó là câu chuyện về con người, quy trình và dữ liệu. Mình học cách đặt câu hỏi, học cách lắng nghe yêu cầu, học cách vẽ ra những sơ đồ tưởng chừng khô khan nhưng lại chứa rất nhiều suy nghĩ phía sau. Dần dần, mình nhận ra mình thích phần “hiểu vấn đề” hơn là chỉ chăm chăm vào lời giải.\nĐịnh hướng Ở thời điểm hiện tại, mình đang định hướng theo con đường Business Analyst (BA). Mình hứng thú với vai trò đứng giữa – không quá xa kỹ thuật, cũng không tách rời nghiệp vụ. Đó là nơi cần sự rõ ràng trong tư duy, sự kiên nhẫn trong giao tiếp và khả năng chuyển hóa những điều mơ hồ thành thứ có thể triển khai được.\nMình không nghĩ BA là một vị trí “nhẹ nhàng” hay “an toàn”. Ngược lại, đó là công việc đòi hỏi phải học rất nhiều, sai rất nhiều và sửa rất nhiều. Nhưng chính điều đó khiến mình thấy phù hợp. Mình muốn hiểu hệ thống trước khi xây dựng nó, muốn biết vì sao người ta see cần một chức năng, chứ không chỉ là nó được viết như thế nào.\nBlog Blog này ra đời khá tự nhiên, giống như một cuốn sổ mở rộng hơn là một trang thể hiện điều gì đó to tát. Mình viết để nhớ, để hệ thống lại những gì đã học, và đôi khi là để sắp xếp lại suy nghĩ của chính mình.\nỞ đây có thể là kiến thức về Hệ thống thông tin, về phân tích nghiệp vụ, về lập trình, hoặc đơn giản là những trải nghiệm học tập và va chạm trong quá trình làm đồ án, làm việc nhóm, và chuẩn bị bước ra môi trường thực tế. Mình không mong mọi thứ phải hoàn hảo, chỉ mong nó thật và có ích cho ai đó đang đi trên con đường tương tự.\nLời kết Mình đang ở một giai đoạn chưa thể gọi là trưởng thành, nhưng cũng không còn quá non nớt. Vẫn đang học, vẫn đang thử, vẫn đang sai và sửa mỗi ngày. Nếu có một điều mình mong giữ được lâu nhất, thì đó là sự tò mò và tinh thần học hỏi – những thứ giúp mình không đứng yên giữa rất nhiều lựa chọn ngoài kia.\nCảm ơn bạn đã ghé qua và đọc những dòng này. Hy vọng ở một thời điểm nào đó, những chia sẻ nhỏ ở đây sẽ chạm đến bạn – dù chỉ là một chút. \u0026ldquo;Học để chia sẻ, chia sẻ để học nhiều hơn.\u0026rdquo;\nLiên hệ Nếu bạn muốn gửi cho mình vài dòng trao đổi,\nbạn có thể liên hệ với mình qua Email hoặc GitHub ,Facebook dưới đây.\nCảm ơn bạn đã ghé thăm blog! ","permalink":"http://localhost:1313/about/","summary":"\u003ch2 id=\"lời-mở-đầu\"\u003eLời mở đầu\u003c/h2\u003e\n\u003cp\u003eCó những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\u003c/p\u003e\n\u003cp\u003eMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\u003c/p\u003e","title":"Giới thiệu"},{"content":"Trong lập trình mạng, trước khi kết nối, ta phải biết \u0026ldquo;địa chỉ nhà\u0026rdquo; (IP) của mình và đối phương. Java cung cấp class\nHình 1.1: Hiệu ứng Dunning–Kruger – mức độ tự tin thay đổi theo kinh nghiệm học tập\nGóc nhìn học tập: Hiệu ứng Dunning–Kruger InetAddress để làm việc này.\nĐịa chỉ IP là gì trong lập trình mạng? IP (Internet Protocol Address) là địa chỉ định danh của một thiết bị khi tham gia vào mạng máy tính.\nTrong lập trình mạng, IP đóng vai trò quan trọng trong việc:\nXác định máy gửi và máy nhận Định tuyến dữ liệu trong quá trình truyền thông Thiết lập kết nối giữa các tiến trình chạy trên những máy khác nhau Nếu không có địa chỉ IP, các máy tính sẽ không thể nhận biết và giao tiếp với nhau.\nVai trò của lớp InetAddress trong Java Lớp InetAddress đại diện cho một địa chỉ IP trong Java.\nThông qua lớp này, lập trình viên có thể:\nLấy địa chỉ IP của máy đang chạy chương trình Lấy tên máy (hostname) Phân giải tên miền sang địa chỉ IP Chuẩn bị thông tin để tạo Socket hoặc ServerSocket Hầu hết các chương trình lập trình mạng trong Java đều sử dụng InetAddress ở bước khởi tạo.\nPhân tích ý nghĩa các lệnh trong chương trình InetAddress.getLocalHost()\n→ Trả về đối tượng đại diện cho máy cục bộ (localhost).\ngetHostName()\n→ Lấy tên máy do hệ điều hành hoặc mạng gán.\ngetHostAddress()\n→ Lấy địa chỉ IP của máy dưới dạng chuỗi.\nViệc in ra hostname và IP giúp:\nKiểm tra cấu hình mạng Xác định đúng máy khi kết nối Client – Server Debug lỗi mạng Một số lưu ý khi lấy IP trong Java Khi máy không kết nối mạng, IP có thể là 127.0.0.1 Khi máy có nhiều card mạng (WiFi, LAN, VPN), IP trả về có thể không phải IP Internet Trên Server, hostname và IP thường khác máy cá nhân Ứng dụng thực tế Việc xác định IP của máy thường được sử dụng trong:\nChương trình Client – Server Thông báo IP Server cho Client kết nối Kiểm tra kết nối mạng LAN Ghi log và giám sát hệ thống Kết luận Qua bài học này, ta đã:\nHiểu vai trò của địa chỉ IP trong lập trình mạng Biết cách lấy IP bằng lớp InetAddress Chuẩn bị nền tảng cho các kỹ thuật TCP, UDP và RMI Liên hệ với học phần Lập trình Mạng máy tính Bài học này nằm trong nội dung mở đầu của học phần Lập trình Mạng máy tính (CMP180) tại Trường Đại học Công nghệ TP.HCM (HUTECH).\nTrong lộ trình môn học, sinh viên sẽ lần lượt tiếp cận các nội dung:\nKiến thức nền tảng về mạng và lập trình mạng Quản lý luồng nhập xuất (I/O) Quản lý địa chỉ và kết nối mạng Lập trình Socket TCP và UDP Xử lý đa tuyến, đa luồng Multicast UDP và Java RMI Thực hiện đồ án học phần cá nhân Mục tiêu của bài học Thông qua Bài 1, sinh viên sẽ:\nLàm quen với môi trường lập trình mạng bằng Java Hiểu được vai trò của địa chỉ IP trong giao tiếp mạng Biết cách sử dụng lớp InetAddress để lấy IP và hostname Chuẩn bị nền tảng cho các bài học tiếp theo về Socket và Server – Client ","permalink":"http://localhost:1313/blog/bai-viet-1/","summary":"GIỚI THIỆU HỌC PHẦN.","title":"Bài 1: Tổng quan khoá học"},{"content":"Trong lập trình mạng, nếu IP được xem như địa chỉ nhà của một máy tính trong mạng,\nthì Port (cổng) chính là số hiệu dùng để xác định chương trình hoặc dịch vụ cụ thể đang chạy trên máy đó.\nMột máy tính có thể chạy đồng thời nhiều ứng dụng mạng như Web Server, Database Server, Game Server hoặc Chat Server.\nMỗi ứng dụng bắt buộc phải gắn với một Port riêng để hệ điều hành có thể phân biệt và định tuyến dữ liệu chính xác.\nPort nằm ở đâu trong mô hình TCP/IP? Trong bộ giao thức TCP/IP, Port thuộc về Transport Layer (Tầng giao vận) và được sử dụng bởi hai giao thức chính là TCP và UDP.\nĐịa chỉ IP xác định máy nào sẽ nhận dữ liệu Port xác định ứng dụng nào trên máy đó sẽ xử lý dữ liệu Sự kết hợp giữa IP + Port tạo thành một Socket, là điểm cuối (endpoint) của quá trình giao tiếp mạng.\nCác loại Port phổ biến Port được đánh số từ 0 đến 65535 và được chia thành ba nhóm chính:\nInternet và các End Devices Trước khi tìm hiểu về Port, cần hiểu Internet được cấu thành từ hàng tỷ thiết bị đầu cuối (End Devices) như máy tính, điện thoại, máy chủ và các thiết bị IoT.\nCác thiết bị này kết nối với nhau thông qua nhiều lớp mạng khác nhau, và mỗi thiết bị khi tham gia giao tiếp mạng đều cần có địa chỉ IP và Port để định danh. Hình 2.1: Sơ đồ minh họa Internet và các thiết bị đầu cuối (End Devices) kết nối thông qua các mạng truy cập và mạng lõi.\nTrong quá trình giao tiếp mạng, một thiết bị không chỉ cần địa chỉ IP để xác định vị trí trong mạng, mà còn cần Port để xác định chính xác ứng dụng hoặc dịch vụ đang lắng nghe trên thiết bị đó.\nDo đó, Port đóng vai trò như “điểm tiếp nhận” (endpoint) cho các tiến trình mạng chạy trên cùng một máy.\nMô hình các tầng giao thức TCP/IP Để hiểu rõ Port hoạt động ở đâu và vì sao Server cần Port, ta cần nắm được mô hình giao thức TCP/IP – nền tảng của mọi ứng dụng mạng hiện nay.\nHình 2.2: Mô hình các tầng giao thức TCP/IP và các giao thức tiêu biểu tương ứng với từng tầng.\nTrong mô hình TCP/IP, địa chỉ IP hoạt động ở tầng Internet, giúp xác định thiết bị trong mạng.\nTrong khi đó, Port hoạt động ở tầng Transport (TCP/UDP), giúp xác định chính xác ứng dụng hoặc dịch vụ đang giao tiếp trên thiết bị đó.\nWell-known Ports (0 – 1023) Được dùng cho các dịch vụ chuẩn:\nPort 80: HTTP Port 443: HTTPS Port 21: FTP Port 25: SMTP Registered Ports (1024 – 49151) Thường dùng cho các ứng dụng phổ biến:\nPort 3306: MySQL Port 8080: Web Server thay thế port 80 Dynamic / Private Ports (49152 – 65535) Do hệ điều hành cấp phát tạm thời cho Client khi giao tiếp mạng.\nVì sao Server thường dùng cổng 8080? Cổng 8080 rất phổ biến trong quá trình phát triển và học tập vì:\nTránh xung đột với cổng 80 đang được hệ điều hành chiếm dụng Không cần quyền Administrator khi mở Server Phù hợp cho các Web Server thử nghiệm như: Apache Tomcat Spring Boot Node.js Lỗi thường gặp: “Address already in use” Lỗi này xảy ra khi Server cố gắng mở một Port đã bị chương trình khác chiếm dụng.\nNguyên nhân phổ biến:\nServer cũ chưa được tắt Port đang được dùng bởi dịch vụ khác Chạy nhiều Server cùng lúc Cách khắc phục:\nĐổi sang Port khác (ví dụ: 8080 → 9090) Kiểm tra Port đang sử dụng trong hệ điều hành Đảm bảo chỉ có một Server chạy tại một thời điểm Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), khái niệm Port sẽ được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Xây dựng mô hình Client – Server Java RMI và Multicast Việc hiểu rõ Port là nền tảng bắt buộc trước khi triển khai các ứng dụng mạng thực tế.\nKết luận Qua bài học này, ta đã:\nHiểu được Port là gì và vai trò của Port trong lập trình mạng Nắm được mối quan hệ giữa IP, Port và Socket Giải thích được lý do Server thường sử dụng cổng 8080 Chuẩn bị kiến thức nền cho các bài học tiếp theo về TCP và UDP ","permalink":"http://localhost:1313/blog/bai-viet-2/","summary":"MẠNG MÁY TÍNH \u0026amp; INTERNET.","title":"Bài 2: Kiến thức nền tảng?"},{"content":"Trong lập trình Java, luồng nhập xuất (Input / Output Streams) đóng vai trò trung gian giúp chương trình đọc và ghi dữ liệu từ nhiều nguồn khác nhau như bàn phím, file, console, bộ nhớ và sau này là socket mạng.\nHiểu rõ cơ chế luồng nhập xuất là bước nền bắt buộc trước khi đi vào lập trình Socket TCP, UDP hay Java RMI.\nLuồng (Stream) là gì? Luồng (Stream) là dòng dữ liệu di chuyển\ntừ nguồn → chương trình hoặc từ chương trình → đích.\nKhi Java đọc hoặc ghi dữ liệu, dữ liệu không đi trực tiếp mà luôn được đóng gói và truyền qua luồng.\nLuồng nhập xuất là gì? Luồng nhập xuất là cơ chế cho phép chương trình:\nNhận dữ liệu từ bên ngoài (Input) Ghi dữ liệu ra bên ngoài (Output) Luồng có thể kết nối với nhiều nguồn và đích khác nhau:\nFile Bàn phím Màn hình (console) Bộ nhớ Kết nối mạng (TCP / UDP) Dữ liệu trong luồng tồn tại dưới những dạng nào? Trong Java, dữ liệu trong luồng tồn tại dưới hai dạng chính:\nLuồng byte Luồng ký tự Việc chọn đúng loại luồng ảnh hưởng trực tiếp đến hiệu năng và tính chính xác của chương trình.\nLuồng byte trong Java Đặc điểm Dữ liệu được xử lý dưới dạng nhị phân Phù hợp với: File nhị phân Ảnh, video Socket mạng Dữ liệu phức tạp Các lớp gốc InputStream – luồng đọc byte OutputStream – luồng ghi byte Cả hai đều là lớp trừu tượng (abstract).\nCác luồng byte đọc phổ biến FileInputStream – đọc byte từ file ByteArrayInputStream – đọc từ mảng byte PipedInputStream – đọc từ luồng pipe Các luồng byte ghi phổ biến FileOutputStream – ghi byte vào file ByteArrayOutputStream – ghi vào mảng byte PipedOutputStream – ghi vào luồng pipe Mô hình đọc/ghi dữ liệu với Stream Quy trình chung khi làm việc với luồng:\nTạo đối tượng Stream Gắn Stream với nguồn hoặc đích Đọc/ghi dữ liệu trong vòng lặp Đóng Stream sau khi hoàn tất Luồng ký tự trong Java Đặc điểm Xử lý dữ liệu dạng Unicode Phù hợp với: File văn bản Chuỗi Dữ liệu hiển thị cho người dùng Các lớp gốc Reader – luồng đọc ký tự Writer – luồng ghi ký tự Các luồng ký tự đọc phổ biến FileReader – đọc file văn bản BufferedReader – đọc có bộ đệm StringReader – đọc chuỗi CharArrayReader – đọc mảng ký tự Các luồng ký tự ghi phổ biến FileWriter – ghi vào file văn bản BufferedWriter – ghi có bộ đệm PrintWriter – ghi dữ liệu dạng dễ đọc StringWriter – ghi chuỗi Luồng lọc dữ liệu (Filtered Streams) Luồng lọc dùng để chuyển đổi dữ liệu từ dạng byte/ký tự sang các kiểu dữ liệu khác.\nCác luồng lọc phổ biến DataInputStream DataOutputStream Cho phép đọc/ghi các kiểu dữ liệu nguyên thủy:\nint float double boolean char Đây là cầu nối giữa luồng thô và dữ liệu có kiểu trong Java.\nLưu trạng thái đối tượng – Serialization Serialization là gì? Serialization (chuỗi hóa) là quá trình chuyển đối tượng Java thành luồng byte để:\nLưu vào file Truyền qua mạng Phục hồi lại sau này Deserialization Ngược lại, Deserialization (giải chuỗi) là quá trình:\nĐọc byte Tái tạo lại đối tượng ban đầu Đây là nền tảng cho:\nLưu dữ liệu chương trình Java RMI Truyền object qua mạng Try-with-resources (TWR) Java hỗ trợ Try-with-resources để:\nTự động đóng stream Tránh rò rỉ tài nguyên Code gọn và an toàn hơn So với try-catch truyền thống, TWR:\nÍt lỗi hơn Dễ bảo trì hơn Được khuyến khích sử dụng Các lỗi I/O thường gặp Khi làm việc với luồng, một số exception phổ biến là:\nFileNotFoundException IOException EOFException UnsupportedEncodingException FileAlreadyExistsException AccessDeniedException SocketException MalformedURLException SerializationException InvalidPathException Việc bắt và xử lý exception đúng cách là yêu cầu bắt buộc trong lập trình Java.\nLiên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), luồng nhập xuất được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Truyền dữ liệu Client – Server Java RMI Multicast UDP Không hiểu I/O Stream → không thể làm mạng đúng cách.\nKết luận Qua bài học này, ta đã:\nHiểu khái niệm luồng nhập xuất trong Java Phân biệt luồng byte và luồng ký tự Nắm được cách đọc/ghi dữ liệu với Stream Biết vai trò của Serialization và Filtered Streams Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo Khi xử lý các tác vụ mạng (như gọi API), người mới học JS hay viết code lồng nhau kiểu này:\n1 2 3 4 5 6 7 8 9 10 // Cực hình Callback Hell getData(function(a) { getMoreData(a, function(b) { getMoreData(b, function(c) { getMoreData(c, function(d) { console.log(d); }); }); }); }); ","permalink":"http://localhost:1313/blog/bai-viet-3/","summary":"Tổng quan về Input/Output Streams trong Java – nền tảng cho xử lý file, console và lập trình mạng.","title":"Bài 3: Quản lý luồng nhập xuất trong Java"},{"content":"Trong lập trình mạng, trước khi chương trình có thể gửi hoặc nhận dữ liệu, điều quan trọng nhất là xác định đúng địa chỉ kết nối mạng. Nếu xác định sai địa chỉ, chương trình sẽ không thể giao tiếp, dù phần xử lý dữ liệu có đúng đến đâu.\nBài học này giúp bạn hiểu cách Java làm việc với địa chỉ IP, tên miền (DNS) và URL. Đây là nền tảng bắt buộc trước khi đi vào Socket TCP, UDP, Web Crawler và Java RMI.\nĐịa chỉ kết nối mạng là gì? Địa chỉ kết nối mạng là thông tin dùng để xác định máy nào trong mạng cần giao tiếp và dịch vụ nào trên máy đó sẽ xử lý dữ liệu.\nTrong Internet, địa chỉ kết nối thường bao gồm:\nĐịa chỉ IP Tên miền (Domain Name) Cổng (Port) Giao thức (Protocol) DNS – Domain Name System Hình 4.1 – Mô hình hoạt động của DNS (Domain Name System)\nClient gửi yêu cầu phân giải tên miền đến DNS Server, DNS trả về địa chỉ IP tương ứng để client kết nối đến server đích.*\nCon người dễ nhớ tên miền hơn các dãy số IP.\nDNS (Domain Name System) có nhiệm vụ ánh xạ tên miền sang địa chỉ IP, giúp client tìm đúng server cần kết nối.\nVí dụ:\ngoogle.com tương ứng với nhiều địa chỉ IP khác nhau www.cs.yale.edu tương ứng với 128.36.229.30 Nhờ DNS, người dùng không cần ghi nhớ địa chỉ IP khi truy cập Internet. *Hình 4.2 minh họa cấu trúc phân cấp của hệ thống DNS, bao gồm Root Domain, các Top-Level Domain (com, edu, org, vn, …) và các tên miền con phía dưới.\nCấu trúc phân cấp này giúp DNS hoạt động hiệu quả và dễ mở rộng trên toàn Internet.*\nĐịa chỉ IPv4 *Hình 4.3 minh họa khái niệm Zone trong DNS.\nMỗi Zone là một phần của không gian tên miền và được quản lý bởi một DNS Server có thẩm quyền.\nViệc chia DNS thành các Zone giúp hệ thống dễ quản lý, phân quyền và tăng độ tin cậy.*\nIPv4 là dạng địa chỉ phổ biến, gồm 32 bit, thường được viết thành bốn nhóm số.\nVí dụ:\n192.168.1.1 8.8.8.8 Một số dải địa chỉ đặc biệt:\n127.x.x.x là loopback (localhost) 224.0.0.0 – 239.255.255.255 là multicast Lớp InetAddress trong Java Java cung cấp lớp InetAddress để làm việc với địa chỉ IP và DNS.\nLớp này thường được dùng để:\nPhân giải tên miền sang IP Kiểm tra loại địa chỉ Kiểm tra khả năng kết nối mạng Ví dụ minh họa:\n1 InetAddress address = InetAddress.getByName(\u0026#34;google.com\u0026#34;); URL – Uniform Resource Locator URL được dùng để xác định tài nguyên trên Internet như trang web, file hoặc dịch vụ.\nMột URL đầy đủ thường bao gồm các thành phần sau:\nGiao thức (Protocol) Tên miền (Host) Cổng (Port) Đường dẫn (Path) Chuỗi truy vấn (Query) Ví dụ một URL đầy đủ: https://www.hutech.edu.vn/admission?id=123\nURL cho biết lấy dữ liệu ở đâu và bằng cách nào.\nLớp URL trong Java Lớp URL cho phép chương trình Java:\nPhân tích các thành phần của URL Kết nối tới server Đọc dữ liệu từ Internet Ví dụ minh họa:\n1 URL url = new URL(\u0026#34;https://www.example.com\u0026#34;); Ý nghĩa của việc quản lý địa chỉ kết nối mạng Hiểu rõ cách quản lý địa chỉ mạng giúp:\nTránh kết nối sai server Chuẩn bị đúng địa chỉ cho Socket TCP/UDP Hiểu cách Web Crawler hoạt động Nắm vững mô hình Client – Server Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm địa chỉ kết nối mạng Biết vai trò của DNS và IPv4 Nắm được cách Java làm việc với InetAddress Hiểu cấu trúc và vai trò của URL Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-4/","summary":"Tìm hiểu cách Java quản lý địa chỉ mạng thông qua InetAddress, URL, URLConnection và DNS.","title":"Bài 4: Quản lý địa chỉ kết nối mạng trong Java"},{"content":"Trong lập trình mạng, TCP Socket là cơ chế quan trọng nhất để xây dựng các ứng dụng Client – Server có độ tin cậy cao.\nBài học này giúp bạn hiểu TCP là gì, vì sao cần TCP, và cách Java triển khai TCP thông qua Socket và ServerSocket.\nĐây là bước chuyển tiếp trực tiếp từ kiến thức địa chỉ mạng (IP, DNS, URL) sang giao tiếp dữ liệu thực tế giữa các chương trình.\nTCP là gì? TCP (Transmission Control Protocol) là giao thức truyền thông hướng kết nối, đảm bảo dữ liệu được truyền:\nĐúng thứ tự Đầy đủ Không bị mất mát Không bị trùng lặp Trước khi truyền dữ liệu, TCP yêu cầu thiết lập kết nối giữa hai bên, và chỉ khi kết nối thành công thì dữ liệu mới được trao đổi.\nVì sao sử dụng TCP? TCP được sử dụng khi ứng dụng yêu cầu độ tin cậy cao, ví dụ:\nỨng dụng chat Ứng dụng client–server Truyền file Game online theo lượt Hệ thống ngân hàng, thương mại điện tử TCP cung cấp các cơ chế quan trọng:\nĐảm bảo dữ liệu: gói tin bị mất sẽ được gửi lại Kiểm soát lỗi: phát hiện và sửa lỗi trong quá trình truyền Kiểm soát luồng: tránh làm quá tải phía nhận Giao tiếp hai chiều: cho phép gửi và nhận dữ liệu đồng thời Cơ chế hoạt động của TCP Quá trình giao tiếp TCP gồm ba giai đoạn chính:\nThiết lập kết nối (Bắt tay 3 bước – Three-way Handshake) Truyền dữ liệu Giải phóng kết nối Nhờ cơ chế này, TCP đảm bảo rằng hai bên luôn sẵn sàng trước khi truyền và kết thúc an toàn sau khi hoàn tất.\nMô hình Client – Server Các ứng dụng TCP thường hoạt động theo mô hình Client – Server.\nServer:\nChạy trước Lắng nghe yêu cầu kết nối Cung cấp dịch vụ Trả kết quả cho client Client:\nChạy sau Chủ động kết nối tới server Gửi yêu cầu Nhận phản hồi từ server Quá trình giao tiếp gồm:\nClient gửi yêu cầu Server xử lý Server trả kết quả cho client Socket trong Java Trong Java, Socket đại diện cho điểm cuối giao tiếp giữa client và server khi sử dụng TCP.\nSocket cho phép:\nGửi dữ liệu tới server Nhận dữ liệu từ server Giao tiếp hai chiều thông qua luồng nhập/xuất Ví dụ minh họa tạo Socket phía client:\n1 Socket socket = new Socket(\u0026#34;localhost\u0026#34;, 8080); ServerSocket trong Java ServerSocket được sử dụng ở phía server để:\nMở một cổng lắng nghe Chờ client kết nối Chấp nhận kết nối và tạo Socket giao tiếp ServerSocket đóng vai trò như cửa ngõ, cho phép các client kết nối vào server.\nVí dụ minh họa:\n1 ServerSocket server = new ServerSocket(8080); Luồng dữ liệu trong TCP Socket Sau khi kết nối TCP được thiết lập, client và server trao đổi dữ liệu thông qua các luồng:\nInputStream: dùng để đọc dữ liệu từ socket OutputStream: dùng để ghi dữ liệu vào socket Luồng dữ liệu này hoạt động tương tự như I/O Stream đã học ở bài trước,\nnhưng nguồn và đích là mạng thay vì file hay bàn phím.\nVí dụ ứng dụng: Trò chơi Oẳn Tù Tì Một bài tập tiêu biểu sử dụng TCP Socket là trò chơi Oẳn Tù Tì theo mô hình Client – Server.\nĐặc điểm Server quản lý luật chơi và điểm số Hai client gửi lựa chọn (kéo – búa – bao) Server xác định kết quả và gửi lại cho client Dữ liệu được truyền qua TCP để đảm bảo chính xác Thông qua bài tập này, sinh viên hiểu rõ:\nCách thiết lập kết nối TCP Cách trao đổi dữ liệu giữa nhiều client Cách xử lý lỗi mạng và ngoại lệ Ý nghĩa của lập trình TCP Socket Việc nắm vững TCP Socket giúp bạn:\nHiểu bản chất giao tiếp mạng Xây dựng hệ thống Client – Server thực tế Chuẩn bị cho các bài nâng cao như: Đa tuyến (Multi-thread) Socket UDP Java RMI Ứng dụng mạng phân tán Kết luận Qua bài học này, bạn đã:\nHiểu TCP là gì và vì sao cần TCP Nắm được mô hình Client – Server Biết vai trò của Socket và ServerSocket trong Java Hiểu cách dữ liệu được truyền qua TCP Chuẩn bị nền tảng cho các bài học UDP và xử lý đồng thời tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-5/","summary":"Giải thích mô hình Client–Server và cách lập trình Socket TCP trong Java – nền tảng cho giao tiếp mạng tin cậy.","title":"Bài 5: Lập trình Socket TCP trong Java"},{"content":"#Trong lập trình mạng, không phải lúc nào ứng dụng cũng cần độ tin cậy tuyệt đối như TCP.\nTrong nhiều trường hợp, điều quan trọng hơn là tốc độ truyền nhanh và độ trễ thấp.\nBài học này giới thiệu UDP Socket – cơ chế truyền dữ liệu không kết nối, được sử dụng rộng rãi trong các ứng dụng thời gian thực.\nUDP là gì? UDP (User Datagram Protocol) là giao thức truyền thông không hướng kết nối.\nĐiều này có nghĩa là:\nKhông thiết lập kết nối trước khi truyền Không đảm bảo dữ liệu đến nơi Không đảm bảo thứ tự gói tin Không tự động gửi lại gói tin bị mất UDP gửi dữ liệu theo từng datagram (gói tin độc lập).\nSo sánh TCP và UDP TCP UDP Có kết nối Không kết nối Đảm bảo dữ liệu Không đảm bảo Truyền theo luồng Truyền theo gói Độ trễ cao hơn Độ trễ thấp Phù hợp dữ liệu quan trọng Phù hợp dữ liệu thời gian thực Khi nào sử dụng UDP? UDP được sử dụng khi:\nCần truyền nhanh Có thể chấp nhận mất gói tin Dữ liệu được gửi liên tục Ví dụ ứng dụng UDP:\nTruyền video, audio trực tuyến Game online thời gian thực Chat broadcast DNS Multicast, streaming UDP Socket trong Java Java hỗ trợ UDP thông qua hai lớp chính:\nDatagramSocket: quản lý socket UDP DatagramPacket: đại diện cho gói dữ liệu UDP UDP không phân biệt client hay server rõ ràng như TCP.\nMỗi chương trình chỉ cần một DatagramSocket để gửi và nhận dữ liệu.\nDatagramPacket là gì? DatagramPacket là gói dữ liệu UDP, bao gồm:\nDữ liệu cần gửi Địa chỉ IP đích Số hiệu cổng Mỗi lần gửi hoặc nhận dữ liệu, UDP làm việc với một DatagramPacket riêng biệt.\nLuồng dữ liệu trong UDP UDP không có luồng InputStream / OutputStream như TCP.\nQuy trình truyền dữ liệu UDP:\nTạo DatagramSocket Tạo DatagramPacket chứa dữ liệu Gửi packet đi Nhận packet về Đọc dữ liệu từ packet Mỗi gói tin là độc lập, không liên quan đến các gói khác.\nĐặc điểm quan trọng của UDP Không kiểm soát lỗi Không kiểm soát luồng Không bắt tay kết nối Gửi nhanh, xử lý đơn giản Phù hợp truyền broadcast và multicast Chính vì vậy, UDP thường được dùng khi tốc độ quan trọng hơn độ chính xác tuyệt đối.\nÝ nghĩa của lập trình Socket UDP Nắm vững UDP giúp bạn:\nHiểu bản chất truyền dữ liệu không kết nối Xây dựng ứng dụng thời gian thực Phân biệt rõ TCP và UDP trong thiết kế hệ thống Chuẩn bị cho các chủ đề nâng cao như: Multicast UDP Java RMI Hệ thống phân tán Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính, UDP được sử dụng trong:\nSocket UDP Multicast Ứng dụng truyền tin nhanh Game, streaming, broadcast Hiểu UDP giúp bạn chọn đúng giao thức cho từng bài toán thực tế.\nKết luận Qua bài học này, bạn đã:\nHiểu UDP là gì và cơ chế hoạt động Phân biệt được TCP và UDP Biết vai trò của DatagramSocket và DatagramPacket Hiểu cách truyền dữ liệu không kết nối Chuẩn bị nền tảng cho bài Multicast UDP \u0026amp; Java RMI tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-6/","summary":"Giải thích giao thức UDP và cách Java lập trình Socket UDP – nền tảng cho truyền dữ liệu nhanh, không kết nối.","title":"Bài 6: Lập trình Socket UDP trong Java"},{"content":"Trong các ứng dụng mạng thực tế, đặc biệt là Server, chương trình thường phải xử lý nhiều yêu cầu cùng lúc.\nNếu chỉ sử dụng một luồng thực thi, server sẽ bị tắc nghẽn, các client phải chờ đợi và hiệu năng giảm nghiêm trọng.\nVì vậy, lập trình đa tuyến (Multithreading) và xử lý đồng thời (Concurrency) là kỹ thuật bắt buộc trong lập trình mạng.\nTuyến (Thread) là gì? Thread là một dòng điều khiển tuần tự bên trong một chương trình.\nMột chương trình (process) có thể chứa nhiều thread Các thread có thể chạy đồng thời Mỗi thread thực hiện một nhiệm vụ riêng Thread không phải là một chương trình độc lập,\nnó luôn thuộc về một process.\nProcess và Thread Process:\nCó không gian bộ nhớ riêng Chạy độc lập với process khác Tạo và chuyển đổi tốn nhiều tài nguyên Thread:\nChia sẻ bộ nhớ với các thread khác trong cùng process Tạo nhanh hơn process Chuyển đổi nhanh hơn Nhờ thread, chương trình có thể thực hiện nhiều công việc cùng lúc trong cùng một ứng dụng.\nVì sao cần lập trình đa tuyến? Lập trình đa tuyến giúp:\nTăng hiệu suất và khả năng đáp ứng Tận dụng thời gian chờ đợi (I/O, mạng, tải file) Chia nhỏ tác vụ và xử lý đồng thời Cải thiện trải nghiệm người dùng Trong lập trình mạng, đa tuyến cho phép server phục vụ nhiều client cùng lúc.\nThực thi Thread trong Java Trong Java, một thread bắt đầu chạy khi gọi phương thức start().\nKhi thread chạy, JVM thực thi mã trong phương thức run() Khi run() kết thúc, thread cũng kết thúc Một thread không thể start lại, muốn chạy lại phải tạo thread mới Thread cần có điều kiện dừng rõ ràng để tránh chạy vô hạn.\nỨng dụng đa tuyến trong lập trình mạng Ứng dụng Chat đa tuyến Một ví dụ tiêu biểu của đa tuyến trong mạng là ứng dụng chat nhiều client – một server.\nĐặc điểm:\nServer chấp nhận nhiều client kết nối cùng lúc Mỗi client được xử lý bởi một thread riêng Tin nhắn từ một client được gửi tới tất cả client khác Server ghi lại nội dung chat vào file log Thông qua ví dụ này, sinh viên hiểu rõ:\nCách server xử lý nhiều kết nối đồng thời Cách phối hợp giữa socket và thread Vai trò của đa tuyến trong ứng dụng mạng Xử lý đồng thời (Concurrency) Xử lý đồng thời xảy ra khi nhiều thread:\nChạy cùng lúc Truy cập tài nguyên chung (biến, file, bộ nhớ) Nếu không kiểm soát tốt, chương trình có thể gặp các vấn đề nghiêm trọng.\nRace Condition Race Condition xảy ra khi:\nNhiều thread cùng truy cập và thay đổi dữ liệu chung Kết quả phụ thuộc vào thứ tự thực thi không xác định Điều này có thể dẫn đến:\nDữ liệu sai lệch Kết quả không nhất quán Lỗi khó phát hiện Đồng bộ hóa (Synchronization) Để tránh race condition, Java cung cấp cơ chế đồng bộ hóa:\nĐảm bảo chỉ một thread được truy cập tài nguyên tại một thời điểm Giữ cho dữ liệu luôn nhất quán Đồng bộ hóa là nền tảng để xây dựng các ứng dụng an toàn và ổn định khi chạy đa tuyến.\nCác vấn đề thường gặp trong xử lý đồng thời Một số vấn đề phổ biến:\nRace condition: tranh chấp dữ liệu Deadlock: các thread chờ nhau vô hạn Livelock: các thread liên tục phản ứng nhưng không tiến triển Starvation: thread không bao giờ được cấp tài nguyên Những vấn đề này khiến lập trình đa tuyến trở nên phức tạp và khó debug.\nLập lịch Thread trong Java Java sử dụng cơ chế lập lịch theo độ ưu tiên:\nMỗi thread có độ ưu tiên từ MIN_PRIORITY đến MAX_PRIORITY JVM chọn thread runnable có độ ưu tiên cao hơn để chạy Thread có thể nhường CPU cho thread khác bằng cách gọi yield() Việc hiểu cơ chế lập lịch giúp lập trình viên thiết kế thread hợp lý hơn.\nÝ nghĩa của lập trình đa tuyến và xử lý đồng thời Nắm vững kiến thức bài này giúp bạn:\nXây dựng server xử lý nhiều client Viết ứng dụng mạng hiệu năng cao Tránh lỗi tranh chấp dữ liệu Chuẩn bị cho các chủ đề nâng cao như: Server đa tuyến Pooling Threads Multicast UDP Java RMI Hệ thống phân tán Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm thread và multithreading Phân biệt process và thread Biết vai trò của đa tuyến trong lập trình mạng Hiểu các vấn đề xử lý đồng thời và race condition Chuẩn bị nền tảng cho các bài học nâng cao tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-7/","summary":"Giải thích lập trình đa tuyến và xử lý đồng thời trong Java – nền tảng cho các ứng dụng mạng nhiều client và hệ thống phân tán.","title":"Bài 7: Lập trình đa tuyến và xử lý đồng thời trong Java"},{"content":"Buổi 8 gồm 2 phần lớn:\nMulticast UDP: gửi dữ liệu từ một nguồn đến nhiều máy nhận cùng lúc (1 → N). Java RMI: gọi phương thức từ xa giữa các ứng dụng Java như gọi hàm bình thường (Remote Method Invocation). Đây là các kỹ thuật thường gặp trong streaming, trò chuyện nhóm, giám sát từ xa và hệ thống phân tán.\n1) UDP Multicast Unicast, Broadcast và Multicast Trong mạng máy tính có 3 kiểu gửi dữ liệu phổ biến:\nUnicast: 1 nguồn → 1 đích\nVí dụ: bạn mở một trang web, server trả dữ liệu cho riêng bạn.\nBroadcast: 1 nguồn → tất cả máy trong mạng nội bộ\nVí dụ: một thông báo phát cho toàn bộ LAN.\nMulticast: 1 nguồn → một nhóm máy đã đăng ký nhận dữ liệu\nVí dụ: server phát stream video cho nhóm người xem cùng lúc.\nMulticast là cách truyền hiệu quả khi nhiều máy cùng cần nhận một nội dung giống nhau.\nTại sao dùng UDP Multicast? UDP Multicast thường được dùng vì:\nHiệu suất cao: gửi 1 lần nhưng nhiều máy nhận → giảm tải mạng và server. Đơn giản, nhanh: UDP là kiểu “gửi và quên”, không phải chờ xác nhận. Tối ưu trong LAN: phù hợp môi trường mạng nội bộ (Local Area Network). Rất hợp streaming: audio/video cần tốc độ và độ trễ thấp hơn là đảm bảo tuyệt đối. Ứng dụng của Multicast Multicast có thể dùng trong:\nTruyền phát multimedia trực tiếp (audio/video streaming) Trò chuyện nhóm, hội thoại nhóm Quảng bá thông tin cấu hình mạng và cập nhật trong hệ thống mạng Game nhiều người chơi (gửi trạng thái game cho nhiều người) Phát thông tin trạng thái/cảnh báo cho nhiều thiết bị Phát tán cập nhật phần mềm trong mạng nội bộ Địa chỉ Multicast IPv4 Trong IPv4:\nClass D là dải địa chỉ dành cho multicast Dải địa chỉ multicast thường gặp: 224.0.0.0 – 239.255.255.255 Một số nhóm multicast hay được nhắc:\n224.0.0.1: tất cả host trong local subnet Multicast Group là gì? Multicast hoạt động theo “nhóm”:\nMột multicast group giống như một kênh. Máy nào muốn nhận dữ liệu phải tham gia nhóm (join group). Khi rời nhóm thì không nhận dữ liệu nữa. Multicast trong Java Java hỗ trợ multicast qua lớp:\njava.net.MulticastSocket (kế thừa từ DatagramSocket) Một số thao tác quan trọng:\njoinGroup(...): tham gia nhóm multicast leaveGroup(...): rời nhóm multicast setTimeToLive(ttl): đặt TTL (thời gian sống của gói tin, qua bao nhiêu router) Quy trình gửi dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket Tham gia nhóm multicast Tạo DatagramPacket chứa dữ liệu + địa chỉ nhóm + port Gửi packet Rời nhóm Ví dụ minh họa (ngắn, chỉ để hiểu):\n1 2 3 4 5 6 7 8 9 10 11 12 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(); socket.joinGroup(group); socket.setTimeToLive(5); byte[] data = \u0026#34;Hello Multicast\u0026#34;.getBytes(); DatagramPacket packet = new DatagramPacket(data, data.length, group, 9876); socket.send(packet); socket.leaveGroup(group); socket.close(); Quy trình nhận dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket lắng nghe trên port Tham gia nhóm multicast Tạo DatagramPacket rỗng để nhận dữ liệu Gọi receive() để chờ gói tin gửi về Đọc dữ liệu từ packet Rời nhóm và đóng socket Ví dụ minh họa (ngắn):\n1 2 3 4 5 6 7 8 9 10 11 12 13 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(9876); socket.joinGroup(group); byte[] buf = new byte[1024]; DatagramPacket packet = new DatagramPacket(buf, buf.length); socket.receive(packet); String msg = new String(packet.getData(), 0, packet.getLength()); System.out.println(\u0026#34;Received: \u0026#34; + msg); socket.leaveGroup(group); socket.close(); 2) Java RMI Java RMI là gì? RMI (Remote Method Invocation) cho phép chương trình Java:\nGọi phương thức của một đối tượng nằm trên máy khác Cảm giác giống như gọi method trong cùng chương trình Nói đơn giản:\nClient gọi: remoteObject.sum(1,2) Server thực thi thật và trả kết quả về cho client RMI giúp che giấu toàn bộ chi tiết mạng phía sau, người lập trình chỉ tập trung vào logic.\nVì sao dùng Java RMI? Java RMI được sử dụng vì:\nTích hợp sẵn trong Java, dễ triển khai nếu cả client và server đều dùng Java Gọi phương thức từ xa đơn giản như gọi hàm thông thường Hỗ trợ dữ liệu phức tạp: đối tượng, mảng, class tự định nghĩa Tự động xử lý giao tiếp mạng thông qua cơ chế stub / skeleton Dựa trên TCP/IP nên tương đối ổn định và tin cậy Hạn chế của Java RMI Một số điểm hạn chế cần lưu ý:\nPhụ thuộc Java: chủ yếu phù hợp Java ↔ Java Thiết kế dịch vụ phức tạp vẫn cần tổ chức tốt (đặc biệt khi dùng callback) Quản lý phiên và kết nối không mạnh như các giải pháp hiện đại Bảo mật cần cấu hình cẩn thận trong môi trường thực tế Ý tưởng kiến trúc RMI (hiểu nhanh) Trong Java RMI có các thành phần chính:\nRemote Interface\nKhai báo các phương thức cho phép gọi từ xa\nServer Implementation\nLớp cài đặt interface, chứa logic xử lý thật\nRMI Registry\nNơi đăng ký service để client tìm thấy server\nClient\nTìm (lookup) service trong registry và gọi phương thức\nCác bước triển khai RMI (tóm tắt) Định nghĩa Remote Interface Cài đặt interface bằng một class server (remote object) Viết chương trình server: tạo object và bind vào registry Viết chương trình client: lookup registry và gọi method Chạy RMI registry, chạy server, sau đó chạy client Ví dụ ứng dụng RMI Một số ví dụ thường gặp:\nTính tổng 2 số từ xa Dịch vụ quản lý tài khoản ATM Dịch vụ giám sát nhiệt độ có callback (server gọi ngược lại client) Bài tập gợi ý theo đúng nội dung buổi 8 BT8.01: Mô phỏng streaming video\n(1 server phát, nhiều client nhận dữ liệu)\nBT8.02: Server quản lý tài khoản ATM bằng RMI\n(thêm user, đăng nhập, gửi/rút tiền, lưu lịch sử giao dịch)\nKết luận Qua bài học này, bạn đã:\nHiểu sự khác nhau giữa Unicast, Broadcast và Multicast Nắm được vì sao Multicast UDP phù hợp cho truyền dữ liệu nhóm và streaming Biết cách Java hỗ trợ multicast qua MulticastSocket Hiểu Java RMI và cơ chế gọi phương thức từ xa Chuẩn bị nền tảng cho các bài ứng dụng mạng phân tán và đồ án học phần ","permalink":"http://localhost:1313/blog/bai-viet-8/","summary":"Giải thích Multicast UDP (gửi 1-n) và Java RMI (gọi phương thức từ xa) – nền tảng cho ứng dụng nhóm và hệ phân tán.","title":"Bài 8: Multicast UDP và Java RMI"},{"content":"Sau khi hoàn thành các bài về TCP, UDP, đa tuyến và xử lý đồng thời,\nchúng ta đã có đủ nền tảng để xây dựng một ứng dụng mạng hoàn chỉnh.\nBài học này giúp bạn xâu chuỗi toàn bộ kiến thức đã học,\nhiểu rõ mỗi công nghệ dùng trong trường hợp nào,\nvà cách thiết kế một hệ thống mạng đúng tư duy kỹ sư.\nNhìn lại các mô hình giao tiếp mạng đã học Trong lập trình mạng, các ứng dụng thường được xây dựng dựa trên mô hình Client – Server.\nClient: gửi yêu cầu, nhập dữ liệu, hiển thị kết quả Server: xử lý logic, quản lý dữ liệu, trả kết quả Tùy bài toán, ta lựa chọn giao thức và mô hình phù hợp.\nSo sánh TCP, UDP và Multicast TCP – Giao tiếp tin cậy TCP phù hợp khi:\nCần đảm bảo dữ liệu đúng và đủ Cần kết nối ổn định, hai chiều Ví dụ: chat, truyền file, game theo lượt, hệ thống ngân hàng Đặc trưng:\nCó bắt tay 3 bước Có kiểm soát lỗi, kiểm soát luồng Tốn tài nguyên hơn UDP UDP – Giao tiếp nhanh, không kết nối UDP phù hợp khi:\nƯu tiên tốc độ Chấp nhận mất gói Ví dụ: game thời gian thực, streaming, cảm biến Đặc trưng:\nKhông kết nối Không đảm bảo thứ tự Ít độ trễ UDP Multicast – Truyền dữ liệu nhóm Multicast được dùng khi:\nMột nguồn → nhiều người nhận Dữ liệu giống nhau cho tất cả client Ví dụ: livestream, thông báo hệ thống, truyền trạng thái Ưu điểm:\nGiảm tải server Tiết kiệm băng thông Phù hợp mạng LAN Vai trò của đa tuyến (Multithreading) Trong thực tế, server không thể xử lý từng client một cách tuần tự.\nĐa tuyến giúp:\nNhiều client kết nối cùng lúc Không client nào bị “đóng băng” Tăng khả năng mở rộng hệ thống Ví dụ:\nServer chat: mỗi client là một thread Server TCP: mỗi socket được xử lý riêng Thiết kế một ứng dụng mạng hoàn chỉnh Khi thiết kế, cần xác định rõ:\nGiao thức: TCP hay UDP? Mô hình: 1–1, 1–n, n–n? Đồng thời hay tuần tự? Client gửi gì? Server xử lý gì? Một thiết kế tốt luôn:\nPhân tách rõ giao tiếp – xử lý – dữ liệu Dễ mở rộng Dễ bảo trì Liên hệ với đồ án học phần Các đồ án như:\nChat đa tuyến Oẳn Tù Tì client–server Streaming UDP Dịch vụ RMI Đều là sự kết hợp của các kiến thức đã học,\nkhông phải nội dung mới.\nKết luận Qua bài học này, bạn đã:\nHệ thống lại toàn bộ kiến thức lập trình mạng Hiểu rõ khi nào dùng TCP, UDP, Multicast Nắm được vai trò của đa tuyến Biết cách tư duy thiết kế một ứng dụng mạng hoàn chỉnh Đây là bước chuẩn bị quan trọng trước khi vận dụng toàn bộ kiến thức vào một hệ thống thực tế.\n","permalink":"http://localhost:1313/blog/bai-viet-9/","summary":"Tổng hợp kiến thức TCP, UDP, đa tuyến và cách thiết kế ứng dụng mạng Client–Server hoàn chỉnh.","title":"Bài 9: Tổng hợp kiến thức \u0026 thiết kế ứng dụng mạng"},{"content":"Bài cuối cùng của học phần không nhằm giới thiệu công nghệ mới,\nmà tập trung vào cách vận dụng kiến thức đã học vào thực tế.\nĐây là giai đoạn chuyển từ:\n“Biết dùng” → “Biết thiết kế” → “Biết đánh giá hệ thống”\nTư duy vận dụng kiến thức Một ứng dụng mạng hoàn chỉnh cần trả lời được các câu hỏi:\nVì sao chọn TCP mà không phải UDP? Vì sao cần đa tuyến? Server có chịu được nhiều client không? Hệ thống có mở rộng được không? Đây chính là tư duy kỹ sư, không phải chỉ “chạy được là xong”.\nĐánh giá một ứng dụng mạng Khi hoàn thiện hệ thống, cần xem xét:\n1. Tính đúng đắn Dữ liệu có truyền đúng không? Có mất gói không? Có xử lý lỗi không? 2. Tính đồng thời Nhiều client có dùng chung được không? Có bị treo server không? Có race condition không? 3. Hiệu năng Độ trễ thế nào? Server có bị quá tải không? Có tách luồng hợp lý không? Liên hệ với các mô hình phân tán Các hệ thống đã học là nền tảng cho:\nHệ thống client–server lớn Ứng dụng phân tán Microservices Cloud services Java RMI, TCP đa tuyến hay UDP Multicast\nđều là những viên gạch đầu tiên.\nTừ học phần đến thực tế Sau học phần này, bạn có thể tiếp cận:\nWebSocket REST API gRPC Message Queue (Kafka, RabbitMQ) Hệ thống realtime Tư duy lập trình mạng không thay đổi, chỉ công nghệ thay đổi.\nTổng kết toàn bộ học phần Qua toàn bộ chuỗi bài, bạn đã:\nHiểu cách dữ liệu đi qua mạng Làm việc với TCP, UDP, Multicast Xử lý đa tuyến và đồng thời Tiếp cận lập trình phân tán với RMI Có tư duy thiết kế hệ thống mạng Lời kết Lập trình mạng không chỉ là code socket,\nmà là hiểu cách các hệ thống nói chuyện với nhau.\nNếu bạn hiểu được điều đó,\nbạn đã vượt xa mức “học để qua môn”.\n","permalink":"http://localhost:1313/blog/bai-viet-10/","summary":"Vận dụng toàn bộ kiến thức lập trình mạng để xây dựng, đánh giá và hoàn thiện một ứng dụng thực tế.","title":"Bài 10: Hoàn thiện \u0026 vận dụng lập trình mạng"},{"content":"Lời mở đầu Có những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\nMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\nHọc tập Những năm đại học trôi qua nhanh hơn mình từng nghĩ. Ngày mới bước chân vào giảng đường, mình vẫn còn khá mơ hồ về ngành học, về tương lai, về chính bản thân mình sẽ trở thành ai sau bốn năm. Nhưng rồi từng môn học, từng bài tập nhóm, từng đồ án kéo mình lại gần hơn với cách một hệ thống được hình thành và vận hành.\nHệ thống thông tin không chỉ là lập trình, cũng không đơn thuần là công nghệ. Đó là câu chuyện về con người, quy trình và dữ liệu. Mình học cách đặt câu hỏi, học cách lắng nghe yêu cầu, học cách vẽ ra những sơ đồ tưởng chừng khô khan nhưng lại chứa rất nhiều suy nghĩ phía sau. Dần dần, mình nhận ra mình thích phần “hiểu vấn đề” hơn là chỉ chăm chăm vào lời giải.\nĐịnh hướng Ở thời điểm hiện tại, mình đang định hướng theo con đường Business Analyst (BA). Mình hứng thú với vai trò đứng giữa – không quá xa kỹ thuật, cũng không tách rời nghiệp vụ. Đó là nơi cần sự rõ ràng trong tư duy, sự kiên nhẫn trong giao tiếp và khả năng chuyển hóa những điều mơ hồ thành thứ có thể triển khai được.\nMình không nghĩ BA là một vị trí “nhẹ nhàng” hay “an toàn”. Ngược lại, đó là công việc đòi hỏi phải học rất nhiều, sai rất nhiều và sửa rất nhiều. Nhưng chính điều đó khiến mình thấy phù hợp. Mình muốn hiểu hệ thống trước khi xây dựng nó, muốn biết vì sao người ta see cần một chức năng, chứ không chỉ là nó được viết như thế nào.\nBlog Blog này ra đời khá tự nhiên, giống như một cuốn sổ mở rộng hơn là một trang thể hiện điều gì đó to tát. Mình viết để nhớ, để hệ thống lại những gì đã học, và đôi khi là để sắp xếp lại suy nghĩ của chính mình.\nỞ đây có thể là kiến thức về Hệ thống thông tin, về phân tích nghiệp vụ, về lập trình, hoặc đơn giản là những trải nghiệm học tập và va chạm trong quá trình làm đồ án, làm việc nhóm, và chuẩn bị bước ra môi trường thực tế. Mình không mong mọi thứ phải hoàn hảo, chỉ mong nó thật và có ích cho ai đó đang đi trên con đường tương tự.\nLời kết Mình đang ở một giai đoạn chưa thể gọi là trưởng thành, nhưng cũng không còn quá non nớt. Vẫn đang học, vẫn đang thử, vẫn đang sai và sửa mỗi ngày. Nếu có một điều mình mong giữ được lâu nhất, thì đó là sự tò mò và tinh thần học hỏi – những thứ giúp mình không đứng yên giữa rất nhiều lựa chọn ngoài kia.\nCảm ơn bạn đã ghé qua và đọc những dòng này. Hy vọng ở một thời điểm nào đó, những chia sẻ nhỏ ở đây sẽ chạm đến bạn – dù chỉ là một chút. \u0026ldquo;Học để chia sẻ, chia sẻ để học nhiều hơn.\u0026rdquo;\nLiên hệ Nếu bạn muốn gửi cho mình vài dòng trao đổi,\nbạn có thể liên hệ với mình qua Email hoặc GitHub ,Facebook dưới đây.\nCảm ơn bạn đã ghé thăm blog! ","permalink":"http://localhost:1313/about/","summary":"\u003ch2 id=\"lời-mở-đầu\"\u003eLời mở đầu\u003c/h2\u003e\n\u003cp\u003eCó những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\u003c/p\u003e\n\u003cp\u003eMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\u003c/p\u003e","title":"Giới thiệu"},{"content":"Trong lập trình mạng, trước khi kết nối, ta phải biết \u0026ldquo;địa chỉ nhà\u0026rdquo; (IP) của mình và đối phương. Java cung cấp class\nHình 1.1: Hiệu ứng Dunning–Kruger – mức độ tự tin thay đổi theo kinh nghiệm học tập\nGóc nhìn học tập: Hiệu ứng Dunning–Kruger InetAddress để làm việc này.\nĐịa chỉ IP là gì trong lập trình mạng? IP (Internet Protocol Address) là địa chỉ định danh của một thiết bị khi tham gia vào mạng máy tính.\nTrong lập trình mạng, IP đóng vai trò quan trọng trong việc:\nXác định máy gửi và máy nhận Định tuyến dữ liệu trong quá trình truyền thông Thiết lập kết nối giữa các tiến trình chạy trên những máy khác nhau Nếu không có địa chỉ IP, các máy tính sẽ không thể nhận biết và giao tiếp với nhau.\nVai trò của lớp InetAddress trong Java Lớp InetAddress đại diện cho một địa chỉ IP trong Java.\nThông qua lớp này, lập trình viên có thể:\nLấy địa chỉ IP của máy đang chạy chương trình Lấy tên máy (hostname) Phân giải tên miền sang địa chỉ IP Chuẩn bị thông tin để tạo Socket hoặc ServerSocket Hầu hết các chương trình lập trình mạng trong Java đều sử dụng InetAddress ở bước khởi tạo.\nPhân tích ý nghĩa các lệnh trong chương trình InetAddress.getLocalHost()\n→ Trả về đối tượng đại diện cho máy cục bộ (localhost).\ngetHostName()\n→ Lấy tên máy do hệ điều hành hoặc mạng gán.\ngetHostAddress()\n→ Lấy địa chỉ IP của máy dưới dạng chuỗi.\nViệc in ra hostname và IP giúp:\nKiểm tra cấu hình mạng Xác định đúng máy khi kết nối Client – Server Debug lỗi mạng Một số lưu ý khi lấy IP trong Java Khi máy không kết nối mạng, IP có thể là 127.0.0.1 Khi máy có nhiều card mạng (WiFi, LAN, VPN), IP trả về có thể không phải IP Internet Trên Server, hostname và IP thường khác máy cá nhân Ứng dụng thực tế Việc xác định IP của máy thường được sử dụng trong:\nChương trình Client – Server Thông báo IP Server cho Client kết nối Kiểm tra kết nối mạng LAN Ghi log và giám sát hệ thống Kết luận Qua bài học này, ta đã:\nHiểu vai trò của địa chỉ IP trong lập trình mạng Biết cách lấy IP bằng lớp InetAddress Chuẩn bị nền tảng cho các kỹ thuật TCP, UDP và RMI Liên hệ với học phần Lập trình Mạng máy tính Bài học này nằm trong nội dung mở đầu của học phần Lập trình Mạng máy tính (CMP180) tại Trường Đại học Công nghệ TP.HCM (HUTECH).\nTrong lộ trình môn học, sinh viên sẽ lần lượt tiếp cận các nội dung:\nKiến thức nền tảng về mạng và lập trình mạng Quản lý luồng nhập xuất (I/O) Quản lý địa chỉ và kết nối mạng Lập trình Socket TCP và UDP Xử lý đa tuyến, đa luồng Multicast UDP và Java RMI Thực hiện đồ án học phần cá nhân Mục tiêu của bài học Thông qua Bài 1, sinh viên sẽ:\nLàm quen với môi trường lập trình mạng bằng Java Hiểu được vai trò của địa chỉ IP trong giao tiếp mạng Biết cách sử dụng lớp InetAddress để lấy IP và hostname Chuẩn bị nền tảng cho các bài học tiếp theo về Socket và Server – Client ","permalink":"http://localhost:1313/blog/bai-viet-1/","summary":"GIỚI THIỆU HỌC PHẦN.","title":"Bài 1: Tổng quan khoá học"},{"content":"Trong lập trình mạng, nếu IP được xem như địa chỉ nhà của một máy tính trong mạng,\nthì Port (cổng) chính là số hiệu dùng để xác định chương trình hoặc dịch vụ cụ thể đang chạy trên máy đó.\nMột máy tính có thể chạy đồng thời nhiều ứng dụng mạng như Web Server, Database Server, Game Server hoặc Chat Server.\nMỗi ứng dụng bắt buộc phải gắn với một Port riêng để hệ điều hành có thể phân biệt và định tuyến dữ liệu chính xác.\nPort nằm ở đâu trong mô hình TCP/IP? Trong bộ giao thức TCP/IP, Port thuộc về Transport Layer (Tầng giao vận) và được sử dụng bởi hai giao thức chính là TCP và UDP.\nĐịa chỉ IP xác định máy nào sẽ nhận dữ liệu Port xác định ứng dụng nào trên máy đó sẽ xử lý dữ liệu Sự kết hợp giữa IP + Port tạo thành một Socket, là điểm cuối (endpoint) của quá trình giao tiếp mạng.\nCác loại Port phổ biến Port được đánh số từ 0 đến 65535 và được chia thành ba nhóm chính:\nInternet và các End Devices Trước khi tìm hiểu về Port, cần hiểu Internet được cấu thành từ hàng tỷ thiết bị đầu cuối (End Devices) như máy tính, điện thoại, máy chủ và các thiết bị IoT.\nCác thiết bị này kết nối với nhau thông qua nhiều lớp mạng khác nhau, và mỗi thiết bị khi tham gia giao tiếp mạng đều cần có địa chỉ IP và Port để định danh. Hình 2.1: Sơ đồ minh họa Internet và các thiết bị đầu cuối (End Devices) kết nối thông qua các mạng truy cập và mạng lõi.\nTrong quá trình giao tiếp mạng, một thiết bị không chỉ cần địa chỉ IP để xác định vị trí trong mạng, mà còn cần Port để xác định chính xác ứng dụng hoặc dịch vụ đang lắng nghe trên thiết bị đó.\nDo đó, Port đóng vai trò như “điểm tiếp nhận” (endpoint) cho các tiến trình mạng chạy trên cùng một máy.\nMô hình các tầng giao thức TCP/IP Để hiểu rõ Port hoạt động ở đâu và vì sao Server cần Port, ta cần nắm được mô hình giao thức TCP/IP – nền tảng của mọi ứng dụng mạng hiện nay.\nHình 2.2: Mô hình các tầng giao thức TCP/IP và các giao thức tiêu biểu tương ứng với từng tầng.\nTrong mô hình TCP/IP, địa chỉ IP hoạt động ở tầng Internet, giúp xác định thiết bị trong mạng.\nTrong khi đó, Port hoạt động ở tầng Transport (TCP/UDP), giúp xác định chính xác ứng dụng hoặc dịch vụ đang giao tiếp trên thiết bị đó.\nWell-known Ports (0 – 1023) Được dùng cho các dịch vụ chuẩn:\nPort 80: HTTP Port 443: HTTPS Port 21: FTP Port 25: SMTP Registered Ports (1024 – 49151) Thường dùng cho các ứng dụng phổ biến:\nPort 3306: MySQL Port 8080: Web Server thay thế port 80 Dynamic / Private Ports (49152 – 65535) Do hệ điều hành cấp phát tạm thời cho Client khi giao tiếp mạng.\nVì sao Server thường dùng cổng 8080? Cổng 8080 rất phổ biến trong quá trình phát triển và học tập vì:\nTránh xung đột với cổng 80 đang được hệ điều hành chiếm dụng Không cần quyền Administrator khi mở Server Phù hợp cho các Web Server thử nghiệm như: Apache Tomcat Spring Boot Node.js Lỗi thường gặp: “Address already in use” Lỗi này xảy ra khi Server cố gắng mở một Port đã bị chương trình khác chiếm dụng.\nNguyên nhân phổ biến:\nServer cũ chưa được tắt Port đang được dùng bởi dịch vụ khác Chạy nhiều Server cùng lúc Cách khắc phục:\nĐổi sang Port khác (ví dụ: 8080 → 9090) Kiểm tra Port đang sử dụng trong hệ điều hành Đảm bảo chỉ có một Server chạy tại một thời điểm Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), khái niệm Port sẽ được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Xây dựng mô hình Client – Server Java RMI và Multicast Việc hiểu rõ Port là nền tảng bắt buộc trước khi triển khai các ứng dụng mạng thực tế.\nKết luận Qua bài học này, ta đã:\nHiểu được Port là gì và vai trò của Port trong lập trình mạng Nắm được mối quan hệ giữa IP, Port và Socket Giải thích được lý do Server thường sử dụng cổng 8080 Chuẩn bị kiến thức nền cho các bài học tiếp theo về TCP và UDP ","permalink":"http://localhost:1313/blog/bai-viet-2/","summary":"MẠNG MÁY TÍNH \u0026amp; INTERNET.","title":"Bài 2: Kiến thức nền tảng?"},{"content":"Trong lập trình Java, luồng nhập xuất (Input / Output Streams) đóng vai trò trung gian giúp chương trình đọc và ghi dữ liệu từ nhiều nguồn khác nhau như bàn phím, file, console, bộ nhớ và sau này là socket mạng.\nHiểu rõ cơ chế luồng nhập xuất là bước nền bắt buộc trước khi đi vào lập trình Socket TCP, UDP hay Java RMI.\nLuồng (Stream) là gì? Luồng (Stream) là dòng dữ liệu di chuyển\ntừ nguồn → chương trình hoặc từ chương trình → đích.\nKhi Java đọc hoặc ghi dữ liệu, dữ liệu không đi trực tiếp mà luôn được đóng gói và truyền qua luồng.\nLuồng nhập xuất là gì? Luồng nhập xuất là cơ chế cho phép chương trình:\nNhận dữ liệu từ bên ngoài (Input) Ghi dữ liệu ra bên ngoài (Output) Luồng có thể kết nối với nhiều nguồn và đích khác nhau:\nFile Bàn phím Màn hình (console) Bộ nhớ Kết nối mạng (TCP / UDP) Dữ liệu trong luồng tồn tại dưới những dạng nào? Trong Java, dữ liệu trong luồng tồn tại dưới hai dạng chính:\nLuồng byte Luồng ký tự Việc chọn đúng loại luồng ảnh hưởng trực tiếp đến hiệu năng và tính chính xác của chương trình.\nLuồng byte trong Java Đặc điểm Dữ liệu được xử lý dưới dạng nhị phân Phù hợp với: File nhị phân Ảnh, video Socket mạng Dữ liệu phức tạp Các lớp gốc InputStream – luồng đọc byte OutputStream – luồng ghi byte Cả hai đều là lớp trừu tượng (abstract).\nCác luồng byte đọc phổ biến FileInputStream – đọc byte từ file ByteArrayInputStream – đọc từ mảng byte PipedInputStream – đọc từ luồng pipe Các luồng byte ghi phổ biến FileOutputStream – ghi byte vào file ByteArrayOutputStream – ghi vào mảng byte PipedOutputStream – ghi vào luồng pipe Mô hình đọc/ghi dữ liệu với Stream Quy trình chung khi làm việc với luồng:\nTạo đối tượng Stream Gắn Stream với nguồn hoặc đích Đọc/ghi dữ liệu trong vòng lặp Đóng Stream sau khi hoàn tất Luồng ký tự trong Java Đặc điểm Xử lý dữ liệu dạng Unicode Phù hợp với: File văn bản Chuỗi Dữ liệu hiển thị cho người dùng Các lớp gốc Reader – luồng đọc ký tự Writer – luồng ghi ký tự Các luồng ký tự đọc phổ biến FileReader – đọc file văn bản BufferedReader – đọc có bộ đệm StringReader – đọc chuỗi CharArrayReader – đọc mảng ký tự Các luồng ký tự ghi phổ biến FileWriter – ghi vào file văn bản BufferedWriter – ghi có bộ đệm PrintWriter – ghi dữ liệu dạng dễ đọc StringWriter – ghi chuỗi Luồng lọc dữ liệu (Filtered Streams) Luồng lọc dùng để chuyển đổi dữ liệu từ dạng byte/ký tự sang các kiểu dữ liệu khác.\nCác luồng lọc phổ biến DataInputStream DataOutputStream Cho phép đọc/ghi các kiểu dữ liệu nguyên thủy:\nint float double boolean char Đây là cầu nối giữa luồng thô và dữ liệu có kiểu trong Java.\nLưu trạng thái đối tượng – Serialization Serialization là gì? Serialization (chuỗi hóa) là quá trình chuyển đối tượng Java thành luồng byte để:\nLưu vào file Truyền qua mạng Phục hồi lại sau này Deserialization Ngược lại, Deserialization (giải chuỗi) là quá trình:\nĐọc byte Tái tạo lại đối tượng ban đầu Đây là nền tảng cho:\nLưu dữ liệu chương trình Java RMI Truyền object qua mạng Try-with-resources (TWR) Java hỗ trợ Try-with-resources để:\nTự động đóng stream Tránh rò rỉ tài nguyên Code gọn và an toàn hơn So với try-catch truyền thống, TWR:\nÍt lỗi hơn Dễ bảo trì hơn Được khuyến khích sử dụng Các lỗi I/O thường gặp Khi làm việc với luồng, một số exception phổ biến là:\nFileNotFoundException IOException EOFException UnsupportedEncodingException FileAlreadyExistsException AccessDeniedException SocketException MalformedURLException SerializationException InvalidPathException Việc bắt và xử lý exception đúng cách là yêu cầu bắt buộc trong lập trình Java.\nLiên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), luồng nhập xuất được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Truyền dữ liệu Client – Server Java RMI Multicast UDP Không hiểu I/O Stream → không thể làm mạng đúng cách.\nKết luận Qua bài học này, ta đã:\nHiểu khái niệm luồng nhập xuất trong Java Phân biệt luồng byte và luồng ký tự Nắm được cách đọc/ghi dữ liệu với Stream Biết vai trò của Serialization và Filtered Streams Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo Khi xử lý các tác vụ mạng (như gọi API), người mới học JS hay viết code lồng nhau kiểu này:\n1 2 3 4 5 6 7 8 9 10 // Cực hình Callback Hell getData(function(a) { getMoreData(a, function(b) { getMoreData(b, function(c) { getMoreData(c, function(d) { console.log(d); }); }); }); }); ","permalink":"http://localhost:1313/blog/bai-viet-3/","summary":"Tổng quan về Input/Output Streams trong Java – nền tảng cho xử lý file, console và lập trình mạng.","title":"Bài 3: Quản lý luồng nhập xuất trong Java"},{"content":"Trong lập trình mạng, trước khi chương trình có thể gửi hoặc nhận dữ liệu, điều quan trọng nhất là xác định đúng địa chỉ kết nối mạng. Nếu xác định sai địa chỉ, chương trình sẽ không thể giao tiếp, dù phần xử lý dữ liệu có đúng đến đâu.\nBài học này giúp bạn hiểu cách Java làm việc với địa chỉ IP, tên miền (DNS) và URL. Đây là nền tảng bắt buộc trước khi đi vào Socket TCP, UDP, Web Crawler và Java RMI.\nĐịa chỉ kết nối mạng là gì? Địa chỉ kết nối mạng là thông tin dùng để xác định máy nào trong mạng cần giao tiếp và dịch vụ nào trên máy đó sẽ xử lý dữ liệu.\nTrong Internet, địa chỉ kết nối thường bao gồm:\nĐịa chỉ IP Tên miền (Domain Name) Cổng (Port) Giao thức (Protocol) DNS – Domain Name System Hình 4.1 – Mô hình hoạt động của DNS (Domain Name System)\nClient gửi yêu cầu phân giải tên miền đến DNS Server, DNS trả về địa chỉ IP tương ứng để client kết nối đến server đích.*\nCon người dễ nhớ tên miền hơn các dãy số IP.\nDNS (Domain Name System) có nhiệm vụ ánh xạ tên miền sang địa chỉ IP, giúp client tìm đúng server cần kết nối.\nVí dụ:\ngoogle.com tương ứng với nhiều địa chỉ IP khác nhau www.cs.yale.edu tương ứng với 128.36.229.30 Nhờ DNS, người dùng không cần ghi nhớ địa chỉ IP khi truy cập Internet. *Hình 4.2 minh họa cấu trúc phân cấp của hệ thống DNS, bao gồm Root Domain, các Top-Level Domain (com, edu, org, vn, …) và các tên miền con phía dưới.\nCấu trúc phân cấp này giúp DNS hoạt động hiệu quả và dễ mở rộng trên toàn Internet.*\nĐịa chỉ IPv4 *Hình 4.3 minh họa khái niệm Zone trong DNS.\nMỗi Zone là một phần của không gian tên miền và được quản lý bởi một DNS Server có thẩm quyền.\nViệc chia DNS thành các Zone giúp hệ thống dễ quản lý, phân quyền và tăng độ tin cậy.*\nIPv4 là dạng địa chỉ phổ biến, gồm 32 bit, thường được viết thành bốn nhóm số.\nVí dụ:\n192.168.1.1 8.8.8.8 Một số dải địa chỉ đặc biệt:\n127.x.x.x là loopback (localhost) 224.0.0.0 – 239.255.255.255 là multicast Lớp InetAddress trong Java Java cung cấp lớp InetAddress để làm việc với địa chỉ IP và DNS.\nLớp này thường được dùng để:\nPhân giải tên miền sang IP Kiểm tra loại địa chỉ Kiểm tra khả năng kết nối mạng Ví dụ minh họa:\n1 InetAddress address = InetAddress.getByName(\u0026#34;google.com\u0026#34;); URL – Uniform Resource Locator URL được dùng để xác định tài nguyên trên Internet như trang web, file hoặc dịch vụ.\nMột URL đầy đủ thường bao gồm các thành phần sau:\nGiao thức (Protocol) Tên miền (Host) Cổng (Port) Đường dẫn (Path) Chuỗi truy vấn (Query) Ví dụ một URL đầy đủ: https://www.hutech.edu.vn/admission?id=123\nURL cho biết lấy dữ liệu ở đâu và bằng cách nào.\nLớp URL trong Java Lớp URL cho phép chương trình Java:\nPhân tích các thành phần của URL Kết nối tới server Đọc dữ liệu từ Internet Ví dụ minh họa:\n1 URL url = new URL(\u0026#34;https://www.example.com\u0026#34;); Ý nghĩa của việc quản lý địa chỉ kết nối mạng Hiểu rõ cách quản lý địa chỉ mạng giúp:\nTránh kết nối sai server Chuẩn bị đúng địa chỉ cho Socket TCP/UDP Hiểu cách Web Crawler hoạt động Nắm vững mô hình Client – Server Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm địa chỉ kết nối mạng Biết vai trò của DNS và IPv4 Nắm được cách Java làm việc với InetAddress Hiểu cấu trúc và vai trò của URL Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-4/","summary":"Tìm hiểu cách Java quản lý địa chỉ mạng thông qua InetAddress, URL, URLConnection và DNS.","title":"Bài 4: Quản lý địa chỉ kết nối mạng trong Java"},{"content":"Trong lập trình mạng, TCP Socket là cơ chế quan trọng nhất để xây dựng các ứng dụng Client – Server có độ tin cậy cao.\nBài học này giúp bạn hiểu TCP là gì, vì sao cần TCP, và cách Java triển khai TCP thông qua Socket và ServerSocket.\nĐây là bước chuyển tiếp trực tiếp từ kiến thức địa chỉ mạng (IP, DNS, URL) sang giao tiếp dữ liệu thực tế giữa các chương trình.\nTCP là gì? TCP (Transmission Control Protocol) là giao thức truyền thông hướng kết nối, đảm bảo dữ liệu được truyền:\nĐúng thứ tự Đầy đủ Không bị mất mát Không bị trùng lặp Trước khi truyền dữ liệu, TCP yêu cầu thiết lập kết nối giữa hai bên, và chỉ khi kết nối thành công thì dữ liệu mới được trao đổi.\nVì sao sử dụng TCP? TCP được sử dụng khi ứng dụng yêu cầu độ tin cậy cao, ví dụ:\nỨng dụng chat Ứng dụng client–server Truyền file Game online theo lượt Hệ thống ngân hàng, thương mại điện tử TCP cung cấp các cơ chế quan trọng:\nĐảm bảo dữ liệu: gói tin bị mất sẽ được gửi lại Kiểm soát lỗi: phát hiện và sửa lỗi trong quá trình truyền Kiểm soát luồng: tránh làm quá tải phía nhận Giao tiếp hai chiều: cho phép gửi và nhận dữ liệu đồng thời Cơ chế hoạt động của TCP Hình 5.1 – Socket TCP và cơ chế bắt tay 3 bước (Three-way Handshake)\nHình minh họa quá trình thiết lập kết nối TCP giữa Client và Server.\nClient khởi tạo client socket và gửi yêu cầu kết nối.\nServer lắng nghe qua welcoming socket, sau đó tạo connection socket để giao tiếp riêng với client.\nSau khi kết nối được thiết lập thành công, hai bên trao đổi dữ liệu hai chiều thông qua các luồng byte.\nQuá trình giao tiếp TCP gồm ba giai đoạn chính:\nThiết lập kết nối (Bắt tay 3 bước – Three-way Handshake) Truyền dữ liệu Giải phóng kết nối Nhờ cơ chế này, TCP đảm bảo rằng hai bên luôn sẵn sàng trước khi truyền và kết thúc an toàn sau khi hoàn tất.\nMô hình Client – Server Các ứng dụng TCP thường hoạt động theo mô hình Client – Server.\nServer:\nChạy trước Lắng nghe yêu cầu kết nối Cung cấp dịch vụ Trả kết quả cho client Client:\nChạy sau Chủ động kết nối tới server Gửi yêu cầu Nhận phản hồi từ server Quá trình giao tiếp gồm:\nClient gửi yêu cầu Server xử lý Server trả kết quả cho client Socket trong Java Trong Java, Socket đại diện cho điểm cuối giao tiếp giữa client và server khi sử dụng TCP.\nSocket cho phép:\nGửi dữ liệu tới server Nhận dữ liệu từ server Giao tiếp hai chiều thông qua luồng nhập/xuất Ví dụ minh họa tạo Socket phía client:\n1 Socket socket = new Socket(\u0026#34;localhost\u0026#34;, 8080); ServerSocket trong Java ServerSocket được sử dụng ở phía server để:\nMở một cổng lắng nghe Chờ client kết nối Chấp nhận kết nối và tạo Socket giao tiếp ServerSocket đóng vai trò như cửa ngõ, cho phép các client kết nối vào server.\nVí dụ minh họa:\n1 ServerSocket server = new ServerSocket(8080); Luồng dữ liệu trong TCP Socket Sau khi kết nối TCP được thiết lập, client và server trao đổi dữ liệu thông qua các luồng:\nInputStream: dùng để đọc dữ liệu từ socket OutputStream: dùng để ghi dữ liệu vào socket Luồng dữ liệu này hoạt động tương tự như I/O Stream đã học ở bài trước,\nnhưng nguồn và đích là mạng thay vì file hay bàn phím.\nVí dụ ứng dụng: Trò chơi Oẳn Tù Tì Một bài tập tiêu biểu sử dụng TCP Socket là trò chơi Oẳn Tù Tì theo mô hình Client – Server.\nĐặc điểm Server quản lý luật chơi và điểm số Hai client gửi lựa chọn (kéo – búa – bao) Server xác định kết quả và gửi lại cho client Dữ liệu được truyền qua TCP để đảm bảo chính xác Thông qua bài tập này, sinh viên hiểu rõ:\nCách thiết lập kết nối TCP Cách trao đổi dữ liệu giữa nhiều client Cách xử lý lỗi mạng và ngoại lệ Ý nghĩa của lập trình TCP Socket Việc nắm vững TCP Socket giúp bạn:\nHiểu bản chất giao tiếp mạng Xây dựng hệ thống Client – Server thực tế Chuẩn bị cho các bài nâng cao như: Đa tuyến (Multi-thread) Socket UDP Java RMI Ứng dụng mạng phân tán Kết luận Qua bài học này, bạn đã:\nHiểu TCP là gì và vì sao cần TCP Nắm được mô hình Client – Server Biết vai trò của Socket và ServerSocket trong Java Hiểu cách dữ liệu được truyền qua TCP Chuẩn bị nền tảng cho các bài học UDP và xử lý đồng thời tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-5/","summary":"Giải thích mô hình Client–Server và cách lập trình Socket TCP trong Java – nền tảng cho giao tiếp mạng tin cậy.","title":"Bài 5: Lập trình Socket TCP trong Java"},{"content":"#Trong lập trình mạng, không phải lúc nào ứng dụng cũng cần độ tin cậy tuyệt đối như TCP.\nTrong nhiều trường hợp, điều quan trọng hơn là tốc độ truyền nhanh và độ trễ thấp.\nBài học này giới thiệu UDP Socket – cơ chế truyền dữ liệu không kết nối, được sử dụng rộng rãi trong các ứng dụng thời gian thực.\nUDP là gì? UDP (User Datagram Protocol) là giao thức truyền thông không hướng kết nối.\nĐiều này có nghĩa là:\nKhông thiết lập kết nối trước khi truyền Không đảm bảo dữ liệu đến nơi Không đảm bảo thứ tự gói tin Không tự động gửi lại gói tin bị mất UDP gửi dữ liệu theo từng datagram (gói tin độc lập).\nSo sánh TCP và UDP TCP UDP Có kết nối Không kết nối Đảm bảo dữ liệu Không đảm bảo Truyền theo luồng Truyền theo gói Độ trễ cao hơn Độ trễ thấp Phù hợp dữ liệu quan trọng Phù hợp dữ liệu thời gian thực Khi nào sử dụng UDP? UDP được sử dụng khi:\nCần truyền nhanh Có thể chấp nhận mất gói tin Dữ liệu được gửi liên tục Ví dụ ứng dụng UDP:\nTruyền video, audio trực tuyến Game online thời gian thực Chat broadcast DNS Multicast, streaming UDP Socket trong Java Java hỗ trợ UDP thông qua hai lớp chính:\nDatagramSocket: quản lý socket UDP DatagramPacket: đại diện cho gói dữ liệu UDP UDP không phân biệt client hay server rõ ràng như TCP.\nMỗi chương trình chỉ cần một DatagramSocket để gửi và nhận dữ liệu.\nDatagramPacket là gì? DatagramPacket là gói dữ liệu UDP, bao gồm:\nDữ liệu cần gửi Địa chỉ IP đích Số hiệu cổng Mỗi lần gửi hoặc nhận dữ liệu, UDP làm việc với một DatagramPacket riêng biệt.\nLuồng dữ liệu trong UDP UDP không có luồng InputStream / OutputStream như TCP.\nQuy trình truyền dữ liệu UDP:\nTạo DatagramSocket Tạo DatagramPacket chứa dữ liệu Gửi packet đi Nhận packet về Đọc dữ liệu từ packet Mỗi gói tin là độc lập, không liên quan đến các gói khác.\nĐặc điểm quan trọng của UDP Không kiểm soát lỗi Không kiểm soát luồng Không bắt tay kết nối Gửi nhanh, xử lý đơn giản Phù hợp truyền broadcast và multicast Chính vì vậy, UDP thường được dùng khi tốc độ quan trọng hơn độ chính xác tuyệt đối.\nÝ nghĩa của lập trình Socket UDP Nắm vững UDP giúp bạn:\nHiểu bản chất truyền dữ liệu không kết nối Xây dựng ứng dụng thời gian thực Phân biệt rõ TCP và UDP trong thiết kế hệ thống Chuẩn bị cho các chủ đề nâng cao như: Multicast UDP Java RMI Hệ thống phân tán Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính, UDP được sử dụng trong:\nSocket UDP Multicast Ứng dụng truyền tin nhanh Game, streaming, broadcast Hiểu UDP giúp bạn chọn đúng giao thức cho từng bài toán thực tế.\nKết luận Qua bài học này, bạn đã:\nHiểu UDP là gì và cơ chế hoạt động Phân biệt được TCP và UDP Biết vai trò của DatagramSocket và DatagramPacket Hiểu cách truyền dữ liệu không kết nối Chuẩn bị nền tảng cho bài Multicast UDP \u0026amp; Java RMI tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-6/","summary":"Giải thích giao thức UDP và cách Java lập trình Socket UDP – nền tảng cho truyền dữ liệu nhanh, không kết nối.","title":"Bài 6: Lập trình Socket UDP trong Java"},{"content":"Trong các ứng dụng mạng thực tế, đặc biệt là Server, chương trình thường phải xử lý nhiều yêu cầu cùng lúc.\nNếu chỉ sử dụng một luồng thực thi, server sẽ bị tắc nghẽn, các client phải chờ đợi và hiệu năng giảm nghiêm trọng.\nVì vậy, lập trình đa tuyến (Multithreading) và xử lý đồng thời (Concurrency) là kỹ thuật bắt buộc trong lập trình mạng.\nTuyến (Thread) là gì? Thread là một dòng điều khiển tuần tự bên trong một chương trình.\nMột chương trình (process) có thể chứa nhiều thread Các thread có thể chạy đồng thời Mỗi thread thực hiện một nhiệm vụ riêng Thread không phải là một chương trình độc lập,\nnó luôn thuộc về một process.\nProcess và Thread Process:\nCó không gian bộ nhớ riêng Chạy độc lập với process khác Tạo và chuyển đổi tốn nhiều tài nguyên Thread:\nChia sẻ bộ nhớ với các thread khác trong cùng process Tạo nhanh hơn process Chuyển đổi nhanh hơn Nhờ thread, chương trình có thể thực hiện nhiều công việc cùng lúc trong cùng một ứng dụng.\nVì sao cần lập trình đa tuyến? Lập trình đa tuyến giúp:\nTăng hiệu suất và khả năng đáp ứng Tận dụng thời gian chờ đợi (I/O, mạng, tải file) Chia nhỏ tác vụ và xử lý đồng thời Cải thiện trải nghiệm người dùng Trong lập trình mạng, đa tuyến cho phép server phục vụ nhiều client cùng lúc.\nThực thi Thread trong Java Trong Java, một thread bắt đầu chạy khi gọi phương thức start().\nKhi thread chạy, JVM thực thi mã trong phương thức run() Khi run() kết thúc, thread cũng kết thúc Một thread không thể start lại, muốn chạy lại phải tạo thread mới Thread cần có điều kiện dừng rõ ràng để tránh chạy vô hạn.\nỨng dụng đa tuyến trong lập trình mạng Ứng dụng Chat đa tuyến Một ví dụ tiêu biểu của đa tuyến trong mạng là ứng dụng chat nhiều client – một server.\nĐặc điểm:\nServer chấp nhận nhiều client kết nối cùng lúc Mỗi client được xử lý bởi một thread riêng Tin nhắn từ một client được gửi tới tất cả client khác Server ghi lại nội dung chat vào file log Thông qua ví dụ này, sinh viên hiểu rõ:\nCách server xử lý nhiều kết nối đồng thời Cách phối hợp giữa socket và thread Vai trò của đa tuyến trong ứng dụng mạng Xử lý đồng thời (Concurrency) Xử lý đồng thời xảy ra khi nhiều thread:\nChạy cùng lúc Truy cập tài nguyên chung (biến, file, bộ nhớ) Nếu không kiểm soát tốt, chương trình có thể gặp các vấn đề nghiêm trọng.\nRace Condition Race Condition xảy ra khi:\nNhiều thread cùng truy cập và thay đổi dữ liệu chung Kết quả phụ thuộc vào thứ tự thực thi không xác định Điều này có thể dẫn đến:\nDữ liệu sai lệch Kết quả không nhất quán Lỗi khó phát hiện Đồng bộ hóa (Synchronization) Để tránh race condition, Java cung cấp cơ chế đồng bộ hóa:\nĐảm bảo chỉ một thread được truy cập tài nguyên tại một thời điểm Giữ cho dữ liệu luôn nhất quán Đồng bộ hóa là nền tảng để xây dựng các ứng dụng an toàn và ổn định khi chạy đa tuyến.\nCác vấn đề thường gặp trong xử lý đồng thời Một số vấn đề phổ biến:\nRace condition: tranh chấp dữ liệu Deadlock: các thread chờ nhau vô hạn Livelock: các thread liên tục phản ứng nhưng không tiến triển Starvation: thread không bao giờ được cấp tài nguyên Những vấn đề này khiến lập trình đa tuyến trở nên phức tạp và khó debug.\nLập lịch Thread trong Java Java sử dụng cơ chế lập lịch theo độ ưu tiên:\nMỗi thread có độ ưu tiên từ MIN_PRIORITY đến MAX_PRIORITY JVM chọn thread runnable có độ ưu tiên cao hơn để chạy Thread có thể nhường CPU cho thread khác bằng cách gọi yield() Việc hiểu cơ chế lập lịch giúp lập trình viên thiết kế thread hợp lý hơn.\nÝ nghĩa của lập trình đa tuyến và xử lý đồng thời Nắm vững kiến thức bài này giúp bạn:\nXây dựng server xử lý nhiều client Viết ứng dụng mạng hiệu năng cao Tránh lỗi tranh chấp dữ liệu Chuẩn bị cho các chủ đề nâng cao như: Server đa tuyến Pooling Threads Multicast UDP Java RMI Hệ thống phân tán Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm thread và multithreading Phân biệt process và thread Biết vai trò của đa tuyến trong lập trình mạng Hiểu các vấn đề xử lý đồng thời và race condition Chuẩn bị nền tảng cho các bài học nâng cao tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-7/","summary":"Giải thích lập trình đa tuyến và xử lý đồng thời trong Java – nền tảng cho các ứng dụng mạng nhiều client và hệ thống phân tán.","title":"Bài 7: Lập trình đa tuyến và xử lý đồng thời trong Java"},{"content":"Buổi 8 gồm 2 phần lớn:\nMulticast UDP: gửi dữ liệu từ một nguồn đến nhiều máy nhận cùng lúc (1 → N). Java RMI: gọi phương thức từ xa giữa các ứng dụng Java như gọi hàm bình thường (Remote Method Invocation). Đây là các kỹ thuật thường gặp trong streaming, trò chuyện nhóm, giám sát từ xa và hệ thống phân tán.\n1) UDP Multicast Unicast, Broadcast và Multicast Trong mạng máy tính có 3 kiểu gửi dữ liệu phổ biến:\nUnicast: 1 nguồn → 1 đích\nVí dụ: bạn mở một trang web, server trả dữ liệu cho riêng bạn.\nBroadcast: 1 nguồn → tất cả máy trong mạng nội bộ\nVí dụ: một thông báo phát cho toàn bộ LAN.\nMulticast: 1 nguồn → một nhóm máy đã đăng ký nhận dữ liệu\nVí dụ: server phát stream video cho nhóm người xem cùng lúc.\nMulticast là cách truyền hiệu quả khi nhiều máy cùng cần nhận một nội dung giống nhau.\nTại sao dùng UDP Multicast? UDP Multicast thường được dùng vì:\nHiệu suất cao: gửi 1 lần nhưng nhiều máy nhận → giảm tải mạng và server. Đơn giản, nhanh: UDP là kiểu “gửi và quên”, không phải chờ xác nhận. Tối ưu trong LAN: phù hợp môi trường mạng nội bộ (Local Area Network). Rất hợp streaming: audio/video cần tốc độ và độ trễ thấp hơn là đảm bảo tuyệt đối. Ứng dụng của Multicast Multicast có thể dùng trong:\nTruyền phát multimedia trực tiếp (audio/video streaming) Trò chuyện nhóm, hội thoại nhóm Quảng bá thông tin cấu hình mạng và cập nhật trong hệ thống mạng Game nhiều người chơi (gửi trạng thái game cho nhiều người) Phát thông tin trạng thái/cảnh báo cho nhiều thiết bị Phát tán cập nhật phần mềm trong mạng nội bộ Địa chỉ Multicast IPv4 Trong IPv4:\nClass D là dải địa chỉ dành cho multicast Dải địa chỉ multicast thường gặp: 224.0.0.0 – 239.255.255.255 Một số nhóm multicast hay được nhắc:\n224.0.0.1: tất cả host trong local subnet Multicast Group là gì? Multicast hoạt động theo “nhóm”:\nMột multicast group giống như một kênh. Máy nào muốn nhận dữ liệu phải tham gia nhóm (join group). Khi rời nhóm thì không nhận dữ liệu nữa. Multicast trong Java Java hỗ trợ multicast qua lớp:\njava.net.MulticastSocket (kế thừa từ DatagramSocket) Một số thao tác quan trọng:\njoinGroup(...): tham gia nhóm multicast leaveGroup(...): rời nhóm multicast setTimeToLive(ttl): đặt TTL (thời gian sống của gói tin, qua bao nhiêu router) Quy trình gửi dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket Tham gia nhóm multicast Tạo DatagramPacket chứa dữ liệu + địa chỉ nhóm + port Gửi packet Rời nhóm Ví dụ minh họa (ngắn, chỉ để hiểu):\n1 2 3 4 5 6 7 8 9 10 11 12 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(); socket.joinGroup(group); socket.setTimeToLive(5); byte[] data = \u0026#34;Hello Multicast\u0026#34;.getBytes(); DatagramPacket packet = new DatagramPacket(data, data.length, group, 9876); socket.send(packet); socket.leaveGroup(group); socket.close(); Quy trình nhận dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket lắng nghe trên port Tham gia nhóm multicast Tạo DatagramPacket rỗng để nhận dữ liệu Gọi receive() để chờ gói tin gửi về Đọc dữ liệu từ packet Rời nhóm và đóng socket Ví dụ minh họa (ngắn):\n1 2 3 4 5 6 7 8 9 10 11 12 13 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(9876); socket.joinGroup(group); byte[] buf = new byte[1024]; DatagramPacket packet = new DatagramPacket(buf, buf.length); socket.receive(packet); String msg = new String(packet.getData(), 0, packet.getLength()); System.out.println(\u0026#34;Received: \u0026#34; + msg); socket.leaveGroup(group); socket.close(); 2) Java RMI Java RMI là gì? RMI (Remote Method Invocation) cho phép chương trình Java:\nGọi phương thức của một đối tượng nằm trên máy khác Cảm giác giống như gọi method trong cùng chương trình Nói đơn giản:\nClient gọi: remoteObject.sum(1,2) Server thực thi thật và trả kết quả về cho client RMI giúp che giấu toàn bộ chi tiết mạng phía sau, người lập trình chỉ tập trung vào logic.\nVì sao dùng Java RMI? Java RMI được sử dụng vì:\nTích hợp sẵn trong Java, dễ triển khai nếu cả client và server đều dùng Java Gọi phương thức từ xa đơn giản như gọi hàm thông thường Hỗ trợ dữ liệu phức tạp: đối tượng, mảng, class tự định nghĩa Tự động xử lý giao tiếp mạng thông qua cơ chế stub / skeleton Dựa trên TCP/IP nên tương đối ổn định và tin cậy Hạn chế của Java RMI Một số điểm hạn chế cần lưu ý:\nPhụ thuộc Java: chủ yếu phù hợp Java ↔ Java Thiết kế dịch vụ phức tạp vẫn cần tổ chức tốt (đặc biệt khi dùng callback) Quản lý phiên và kết nối không mạnh như các giải pháp hiện đại Bảo mật cần cấu hình cẩn thận trong môi trường thực tế Ý tưởng kiến trúc RMI (hiểu nhanh) Trong Java RMI có các thành phần chính:\nRemote Interface\nKhai báo các phương thức cho phép gọi từ xa\nServer Implementation\nLớp cài đặt interface, chứa logic xử lý thật\nRMI Registry\nNơi đăng ký service để client tìm thấy server\nClient\nTìm (lookup) service trong registry và gọi phương thức\nCác bước triển khai RMI (tóm tắt) Định nghĩa Remote Interface Cài đặt interface bằng một class server (remote object) Viết chương trình server: tạo object và bind vào registry Viết chương trình client: lookup registry và gọi method Chạy RMI registry, chạy server, sau đó chạy client Ví dụ ứng dụng RMI Một số ví dụ thường gặp:\nTính tổng 2 số từ xa Dịch vụ quản lý tài khoản ATM Dịch vụ giám sát nhiệt độ có callback (server gọi ngược lại client) Bài tập gợi ý theo đúng nội dung buổi 8 BT8.01: Mô phỏng streaming video\n(1 server phát, nhiều client nhận dữ liệu)\nBT8.02: Server quản lý tài khoản ATM bằng RMI\n(thêm user, đăng nhập, gửi/rút tiền, lưu lịch sử giao dịch)\nKết luận Qua bài học này, bạn đã:\nHiểu sự khác nhau giữa Unicast, Broadcast và Multicast Nắm được vì sao Multicast UDP phù hợp cho truyền dữ liệu nhóm và streaming Biết cách Java hỗ trợ multicast qua MulticastSocket Hiểu Java RMI và cơ chế gọi phương thức từ xa Chuẩn bị nền tảng cho các bài ứng dụng mạng phân tán và đồ án học phần ","permalink":"http://localhost:1313/blog/bai-viet-8/","summary":"Giải thích Multicast UDP (gửi 1-n) và Java RMI (gọi phương thức từ xa) – nền tảng cho ứng dụng nhóm và hệ phân tán.","title":"Bài 8: Multicast UDP và Java RMI"},{"content":"Sau khi hoàn thành các bài về TCP, UDP, đa tuyến và xử lý đồng thời,\nchúng ta đã có đủ nền tảng để xây dựng một ứng dụng mạng hoàn chỉnh.\nBài học này giúp bạn xâu chuỗi toàn bộ kiến thức đã học,\nhiểu rõ mỗi công nghệ dùng trong trường hợp nào,\nvà cách thiết kế một hệ thống mạng đúng tư duy kỹ sư.\nNhìn lại các mô hình giao tiếp mạng đã học Trong lập trình mạng, các ứng dụng thường được xây dựng dựa trên mô hình Client – Server.\nClient: gửi yêu cầu, nhập dữ liệu, hiển thị kết quả Server: xử lý logic, quản lý dữ liệu, trả kết quả Tùy bài toán, ta lựa chọn giao thức và mô hình phù hợp.\nSo sánh TCP, UDP và Multicast TCP – Giao tiếp tin cậy TCP phù hợp khi:\nCần đảm bảo dữ liệu đúng và đủ Cần kết nối ổn định, hai chiều Ví dụ: chat, truyền file, game theo lượt, hệ thống ngân hàng Đặc trưng:\nCó bắt tay 3 bước Có kiểm soát lỗi, kiểm soát luồng Tốn tài nguyên hơn UDP UDP – Giao tiếp nhanh, không kết nối UDP phù hợp khi:\nƯu tiên tốc độ Chấp nhận mất gói Ví dụ: game thời gian thực, streaming, cảm biến Đặc trưng:\nKhông kết nối Không đảm bảo thứ tự Ít độ trễ UDP Multicast – Truyền dữ liệu nhóm Multicast được dùng khi:\nMột nguồn → nhiều người nhận Dữ liệu giống nhau cho tất cả client Ví dụ: livestream, thông báo hệ thống, truyền trạng thái Ưu điểm:\nGiảm tải server Tiết kiệm băng thông Phù hợp mạng LAN Vai trò của đa tuyến (Multithreading) Trong thực tế, server không thể xử lý từng client một cách tuần tự.\nĐa tuyến giúp:\nNhiều client kết nối cùng lúc Không client nào bị “đóng băng” Tăng khả năng mở rộng hệ thống Ví dụ:\nServer chat: mỗi client là một thread Server TCP: mỗi socket được xử lý riêng Thiết kế một ứng dụng mạng hoàn chỉnh Khi thiết kế, cần xác định rõ:\nGiao thức: TCP hay UDP? Mô hình: 1–1, 1–n, n–n? Đồng thời hay tuần tự? Client gửi gì? Server xử lý gì? Một thiết kế tốt luôn:\nPhân tách rõ giao tiếp – xử lý – dữ liệu Dễ mở rộng Dễ bảo trì Liên hệ với đồ án học phần Các đồ án như:\nChat đa tuyến Oẳn Tù Tì client–server Streaming UDP Dịch vụ RMI Đều là sự kết hợp của các kiến thức đã học,\nkhông phải nội dung mới.\nKết luận Qua bài học này, bạn đã:\nHệ thống lại toàn bộ kiến thức lập trình mạng Hiểu rõ khi nào dùng TCP, UDP, Multicast Nắm được vai trò của đa tuyến Biết cách tư duy thiết kế một ứng dụng mạng hoàn chỉnh Đây là bước chuẩn bị quan trọng trước khi vận dụng toàn bộ kiến thức vào một hệ thống thực tế.\n","permalink":"http://localhost:1313/blog/bai-viet-9/","summary":"Tổng hợp kiến thức TCP, UDP, đa tuyến và cách thiết kế ứng dụng mạng Client–Server hoàn chỉnh.","title":"Bài 9: Tổng hợp kiến thức \u0026 thiết kế ứng dụng mạng"},{"content":"Bài cuối cùng của học phần không nhằm giới thiệu công nghệ mới,\nmà tập trung vào cách vận dụng kiến thức đã học vào thực tế.\nĐây là giai đoạn chuyển từ:\n“Biết dùng” → “Biết thiết kế” → “Biết đánh giá hệ thống”\nTư duy vận dụng kiến thức Một ứng dụng mạng hoàn chỉnh cần trả lời được các câu hỏi:\nVì sao chọn TCP mà không phải UDP? Vì sao cần đa tuyến? Server có chịu được nhiều client không? Hệ thống có mở rộng được không? Đây chính là tư duy kỹ sư, không phải chỉ “chạy được là xong”.\nĐánh giá một ứng dụng mạng Khi hoàn thiện hệ thống, cần xem xét:\n1. Tính đúng đắn Dữ liệu có truyền đúng không? Có mất gói không? Có xử lý lỗi không? 2. Tính đồng thời Nhiều client có dùng chung được không? Có bị treo server không? Có race condition không? 3. Hiệu năng Độ trễ thế nào? Server có bị quá tải không? Có tách luồng hợp lý không? Liên hệ với các mô hình phân tán Các hệ thống đã học là nền tảng cho:\nHệ thống client–server lớn Ứng dụng phân tán Microservices Cloud services Java RMI, TCP đa tuyến hay UDP Multicast\nđều là những viên gạch đầu tiên.\nTừ học phần đến thực tế Sau học phần này, bạn có thể tiếp cận:\nWebSocket REST API gRPC Message Queue (Kafka, RabbitMQ) Hệ thống realtime Tư duy lập trình mạng không thay đổi, chỉ công nghệ thay đổi.\nTổng kết toàn bộ học phần Qua toàn bộ chuỗi bài, bạn đã:\nHiểu cách dữ liệu đi qua mạng Làm việc với TCP, UDP, Multicast Xử lý đa tuyến và đồng thời Tiếp cận lập trình phân tán với RMI Có tư duy thiết kế hệ thống mạng Lời kết Lập trình mạng không chỉ là code socket,\nmà là hiểu cách các hệ thống nói chuyện với nhau.\nNếu bạn hiểu được điều đó,\nbạn đã vượt xa mức “học để qua môn”.\n","permalink":"http://localhost:1313/blog/bai-viet-10/","summary":"Vận dụng toàn bộ kiến thức lập trình mạng để xây dựng, đánh giá và hoàn thiện một ứng dụng thực tế.","title":"Bài 10: Hoàn thiện \u0026 vận dụng lập trình mạng"},{"content":"Lời mở đầu Có những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\nMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\nHọc tập Những năm đại học trôi qua nhanh hơn mình từng nghĩ. Ngày mới bước chân vào giảng đường, mình vẫn còn khá mơ hồ về ngành học, về tương lai, về chính bản thân mình sẽ trở thành ai sau bốn năm. Nhưng rồi từng môn học, từng bài tập nhóm, từng đồ án kéo mình lại gần hơn với cách một hệ thống được hình thành và vận hành.\nHệ thống thông tin không chỉ là lập trình, cũng không đơn thuần là công nghệ. Đó là câu chuyện về con người, quy trình và dữ liệu. Mình học cách đặt câu hỏi, học cách lắng nghe yêu cầu, học cách vẽ ra những sơ đồ tưởng chừng khô khan nhưng lại chứa rất nhiều suy nghĩ phía sau. Dần dần, mình nhận ra mình thích phần “hiểu vấn đề” hơn là chỉ chăm chăm vào lời giải.\nĐịnh hướng Ở thời điểm hiện tại, mình đang định hướng theo con đường Business Analyst (BA). Mình hứng thú với vai trò đứng giữa – không quá xa kỹ thuật, cũng không tách rời nghiệp vụ. Đó là nơi cần sự rõ ràng trong tư duy, sự kiên nhẫn trong giao tiếp và khả năng chuyển hóa những điều mơ hồ thành thứ có thể triển khai được.\nMình không nghĩ BA là một vị trí “nhẹ nhàng” hay “an toàn”. Ngược lại, đó là công việc đòi hỏi phải học rất nhiều, sai rất nhiều và sửa rất nhiều. Nhưng chính điều đó khiến mình thấy phù hợp. Mình muốn hiểu hệ thống trước khi xây dựng nó, muốn biết vì sao người ta see cần một chức năng, chứ không chỉ là nó được viết như thế nào.\nBlog Blog này ra đời khá tự nhiên, giống như một cuốn sổ mở rộng hơn là một trang thể hiện điều gì đó to tát. Mình viết để nhớ, để hệ thống lại những gì đã học, và đôi khi là để sắp xếp lại suy nghĩ của chính mình.\nỞ đây có thể là kiến thức về Hệ thống thông tin, về phân tích nghiệp vụ, về lập trình, hoặc đơn giản là những trải nghiệm học tập và va chạm trong quá trình làm đồ án, làm việc nhóm, và chuẩn bị bước ra môi trường thực tế. Mình không mong mọi thứ phải hoàn hảo, chỉ mong nó thật và có ích cho ai đó đang đi trên con đường tương tự.\nLời kết Mình đang ở một giai đoạn chưa thể gọi là trưởng thành, nhưng cũng không còn quá non nớt. Vẫn đang học, vẫn đang thử, vẫn đang sai và sửa mỗi ngày. Nếu có một điều mình mong giữ được lâu nhất, thì đó là sự tò mò và tinh thần học hỏi – những thứ giúp mình không đứng yên giữa rất nhiều lựa chọn ngoài kia.\nCảm ơn bạn đã ghé qua và đọc những dòng này. Hy vọng ở một thời điểm nào đó, những chia sẻ nhỏ ở đây sẽ chạm đến bạn – dù chỉ là một chút. \u0026ldquo;Học để chia sẻ, chia sẻ để học nhiều hơn.\u0026rdquo;\nLiên hệ Nếu bạn muốn gửi cho mình vài dòng trao đổi,\nbạn có thể liên hệ với mình qua Email hoặc GitHub ,Facebook dưới đây.\nCảm ơn bạn đã ghé thăm blog! ","permalink":"http://localhost:1313/about/","summary":"\u003ch2 id=\"lời-mở-đầu\"\u003eLời mở đầu\u003c/h2\u003e\n\u003cp\u003eCó những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\u003c/p\u003e\n\u003cp\u003eMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\u003c/p\u003e","title":"Giới thiệu"},{"content":"Trong lập trình mạng, trước khi kết nối, ta phải biết \u0026ldquo;địa chỉ nhà\u0026rdquo; (IP) của mình và đối phương. Java cung cấp class\nHình 1.1: Hiệu ứng Dunning–Kruger – mức độ tự tin thay đổi theo kinh nghiệm học tập\nGóc nhìn học tập: Hiệu ứng Dunning–Kruger InetAddress để làm việc này.\nĐịa chỉ IP là gì trong lập trình mạng? IP (Internet Protocol Address) là địa chỉ định danh của một thiết bị khi tham gia vào mạng máy tính.\nTrong lập trình mạng, IP đóng vai trò quan trọng trong việc:\nXác định máy gửi và máy nhận Định tuyến dữ liệu trong quá trình truyền thông Thiết lập kết nối giữa các tiến trình chạy trên những máy khác nhau Nếu không có địa chỉ IP, các máy tính sẽ không thể nhận biết và giao tiếp với nhau.\nVai trò của lớp InetAddress trong Java Lớp InetAddress đại diện cho một địa chỉ IP trong Java.\nThông qua lớp này, lập trình viên có thể:\nLấy địa chỉ IP của máy đang chạy chương trình Lấy tên máy (hostname) Phân giải tên miền sang địa chỉ IP Chuẩn bị thông tin để tạo Socket hoặc ServerSocket Hầu hết các chương trình lập trình mạng trong Java đều sử dụng InetAddress ở bước khởi tạo.\nPhân tích ý nghĩa các lệnh trong chương trình InetAddress.getLocalHost()\n→ Trả về đối tượng đại diện cho máy cục bộ (localhost).\ngetHostName()\n→ Lấy tên máy do hệ điều hành hoặc mạng gán.\ngetHostAddress()\n→ Lấy địa chỉ IP của máy dưới dạng chuỗi.\nViệc in ra hostname và IP giúp:\nKiểm tra cấu hình mạng Xác định đúng máy khi kết nối Client – Server Debug lỗi mạng Một số lưu ý khi lấy IP trong Java Khi máy không kết nối mạng, IP có thể là 127.0.0.1 Khi máy có nhiều card mạng (WiFi, LAN, VPN), IP trả về có thể không phải IP Internet Trên Server, hostname và IP thường khác máy cá nhân Ứng dụng thực tế Việc xác định IP của máy thường được sử dụng trong:\nChương trình Client – Server Thông báo IP Server cho Client kết nối Kiểm tra kết nối mạng LAN Ghi log và giám sát hệ thống Kết luận Qua bài học này, ta đã:\nHiểu vai trò của địa chỉ IP trong lập trình mạng Biết cách lấy IP bằng lớp InetAddress Chuẩn bị nền tảng cho các kỹ thuật TCP, UDP và RMI Liên hệ với học phần Lập trình Mạng máy tính Bài học này nằm trong nội dung mở đầu của học phần Lập trình Mạng máy tính (CMP180) tại Trường Đại học Công nghệ TP.HCM (HUTECH).\nTrong lộ trình môn học, sinh viên sẽ lần lượt tiếp cận các nội dung:\nKiến thức nền tảng về mạng và lập trình mạng Quản lý luồng nhập xuất (I/O) Quản lý địa chỉ và kết nối mạng Lập trình Socket TCP và UDP Xử lý đa tuyến, đa luồng Multicast UDP và Java RMI Thực hiện đồ án học phần cá nhân Mục tiêu của bài học Thông qua Bài 1, sinh viên sẽ:\nLàm quen với môi trường lập trình mạng bằng Java Hiểu được vai trò của địa chỉ IP trong giao tiếp mạng Biết cách sử dụng lớp InetAddress để lấy IP và hostname Chuẩn bị nền tảng cho các bài học tiếp theo về Socket và Server – Client ","permalink":"http://localhost:1313/blog/bai-viet-1/","summary":"GIỚI THIỆU HỌC PHẦN.","title":"Bài 1: Tổng quan khoá học"},{"content":"Trong lập trình mạng, nếu IP được xem như địa chỉ nhà của một máy tính trong mạng,\nthì Port (cổng) chính là số hiệu dùng để xác định chương trình hoặc dịch vụ cụ thể đang chạy trên máy đó.\nMột máy tính có thể chạy đồng thời nhiều ứng dụng mạng như Web Server, Database Server, Game Server hoặc Chat Server.\nMỗi ứng dụng bắt buộc phải gắn với một Port riêng để hệ điều hành có thể phân biệt và định tuyến dữ liệu chính xác.\nPort nằm ở đâu trong mô hình TCP/IP? Trong bộ giao thức TCP/IP, Port thuộc về Transport Layer (Tầng giao vận) và được sử dụng bởi hai giao thức chính là TCP và UDP.\nĐịa chỉ IP xác định máy nào sẽ nhận dữ liệu Port xác định ứng dụng nào trên máy đó sẽ xử lý dữ liệu Sự kết hợp giữa IP + Port tạo thành một Socket, là điểm cuối (endpoint) của quá trình giao tiếp mạng.\nCác loại Port phổ biến Port được đánh số từ 0 đến 65535 và được chia thành ba nhóm chính:\nInternet và các End Devices Trước khi tìm hiểu về Port, cần hiểu Internet được cấu thành từ hàng tỷ thiết bị đầu cuối (End Devices) như máy tính, điện thoại, máy chủ và các thiết bị IoT.\nCác thiết bị này kết nối với nhau thông qua nhiều lớp mạng khác nhau, và mỗi thiết bị khi tham gia giao tiếp mạng đều cần có địa chỉ IP và Port để định danh. Hình 2.1: Sơ đồ minh họa Internet và các thiết bị đầu cuối (End Devices) kết nối thông qua các mạng truy cập và mạng lõi.\nTrong quá trình giao tiếp mạng, một thiết bị không chỉ cần địa chỉ IP để xác định vị trí trong mạng, mà còn cần Port để xác định chính xác ứng dụng hoặc dịch vụ đang lắng nghe trên thiết bị đó.\nDo đó, Port đóng vai trò như “điểm tiếp nhận” (endpoint) cho các tiến trình mạng chạy trên cùng một máy.\nMô hình các tầng giao thức TCP/IP Để hiểu rõ Port hoạt động ở đâu và vì sao Server cần Port, ta cần nắm được mô hình giao thức TCP/IP – nền tảng của mọi ứng dụng mạng hiện nay.\nHình 2.2: Mô hình các tầng giao thức TCP/IP và các giao thức tiêu biểu tương ứng với từng tầng.\nTrong mô hình TCP/IP, địa chỉ IP hoạt động ở tầng Internet, giúp xác định thiết bị trong mạng.\nTrong khi đó, Port hoạt động ở tầng Transport (TCP/UDP), giúp xác định chính xác ứng dụng hoặc dịch vụ đang giao tiếp trên thiết bị đó.\nWell-known Ports (0 – 1023) Được dùng cho các dịch vụ chuẩn:\nPort 80: HTTP Port 443: HTTPS Port 21: FTP Port 25: SMTP Registered Ports (1024 – 49151) Thường dùng cho các ứng dụng phổ biến:\nPort 3306: MySQL Port 8080: Web Server thay thế port 80 Dynamic / Private Ports (49152 – 65535) Do hệ điều hành cấp phát tạm thời cho Client khi giao tiếp mạng.\nVì sao Server thường dùng cổng 8080? Cổng 8080 rất phổ biến trong quá trình phát triển và học tập vì:\nTránh xung đột với cổng 80 đang được hệ điều hành chiếm dụng Không cần quyền Administrator khi mở Server Phù hợp cho các Web Server thử nghiệm như: Apache Tomcat Spring Boot Node.js Lỗi thường gặp: “Address already in use” Lỗi này xảy ra khi Server cố gắng mở một Port đã bị chương trình khác chiếm dụng.\nNguyên nhân phổ biến:\nServer cũ chưa được tắt Port đang được dùng bởi dịch vụ khác Chạy nhiều Server cùng lúc Cách khắc phục:\nĐổi sang Port khác (ví dụ: 8080 → 9090) Kiểm tra Port đang sử dụng trong hệ điều hành Đảm bảo chỉ có một Server chạy tại một thời điểm Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), khái niệm Port sẽ được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Xây dựng mô hình Client – Server Java RMI và Multicast Việc hiểu rõ Port là nền tảng bắt buộc trước khi triển khai các ứng dụng mạng thực tế.\nKết luận Qua bài học này, ta đã:\nHiểu được Port là gì và vai trò của Port trong lập trình mạng Nắm được mối quan hệ giữa IP, Port và Socket Giải thích được lý do Server thường sử dụng cổng 8080 Chuẩn bị kiến thức nền cho các bài học tiếp theo về TCP và UDP ","permalink":"http://localhost:1313/blog/bai-viet-2/","summary":"MẠNG MÁY TÍNH \u0026amp; INTERNET.","title":"Bài 2: Kiến thức nền tảng?"},{"content":"Trong lập trình Java, luồng nhập xuất (Input / Output Streams) đóng vai trò trung gian giúp chương trình đọc và ghi dữ liệu từ nhiều nguồn khác nhau như bàn phím, file, console, bộ nhớ và sau này là socket mạng.\nHiểu rõ cơ chế luồng nhập xuất là bước nền bắt buộc trước khi đi vào lập trình Socket TCP, UDP hay Java RMI.\nLuồng (Stream) là gì? Luồng (Stream) là dòng dữ liệu di chuyển\ntừ nguồn → chương trình hoặc từ chương trình → đích.\nKhi Java đọc hoặc ghi dữ liệu, dữ liệu không đi trực tiếp mà luôn được đóng gói và truyền qua luồng.\nLuồng nhập xuất là gì? Luồng nhập xuất là cơ chế cho phép chương trình:\nNhận dữ liệu từ bên ngoài (Input) Ghi dữ liệu ra bên ngoài (Output) Luồng có thể kết nối với nhiều nguồn và đích khác nhau:\nFile Bàn phím Màn hình (console) Bộ nhớ Kết nối mạng (TCP / UDP) Dữ liệu trong luồng tồn tại dưới những dạng nào? Trong Java, dữ liệu trong luồng tồn tại dưới hai dạng chính:\nLuồng byte Luồng ký tự Việc chọn đúng loại luồng ảnh hưởng trực tiếp đến hiệu năng và tính chính xác của chương trình.\nLuồng byte trong Java Đặc điểm Dữ liệu được xử lý dưới dạng nhị phân Phù hợp với: File nhị phân Ảnh, video Socket mạng Dữ liệu phức tạp Các lớp gốc InputStream – luồng đọc byte OutputStream – luồng ghi byte Cả hai đều là lớp trừu tượng (abstract).\nCác luồng byte đọc phổ biến FileInputStream – đọc byte từ file ByteArrayInputStream – đọc từ mảng byte PipedInputStream – đọc từ luồng pipe Các luồng byte ghi phổ biến FileOutputStream – ghi byte vào file ByteArrayOutputStream – ghi vào mảng byte PipedOutputStream – ghi vào luồng pipe Mô hình đọc/ghi dữ liệu với Stream Quy trình chung khi làm việc với luồng:\nTạo đối tượng Stream Gắn Stream với nguồn hoặc đích Đọc/ghi dữ liệu trong vòng lặp Đóng Stream sau khi hoàn tất Luồng ký tự trong Java Đặc điểm Xử lý dữ liệu dạng Unicode Phù hợp với: File văn bản Chuỗi Dữ liệu hiển thị cho người dùng Các lớp gốc Reader – luồng đọc ký tự Writer – luồng ghi ký tự Các luồng ký tự đọc phổ biến FileReader – đọc file văn bản BufferedReader – đọc có bộ đệm StringReader – đọc chuỗi CharArrayReader – đọc mảng ký tự Các luồng ký tự ghi phổ biến FileWriter – ghi vào file văn bản BufferedWriter – ghi có bộ đệm PrintWriter – ghi dữ liệu dạng dễ đọc StringWriter – ghi chuỗi Luồng lọc dữ liệu (Filtered Streams) Luồng lọc dùng để chuyển đổi dữ liệu từ dạng byte/ký tự sang các kiểu dữ liệu khác.\nCác luồng lọc phổ biến DataInputStream DataOutputStream Cho phép đọc/ghi các kiểu dữ liệu nguyên thủy:\nint float double boolean char Đây là cầu nối giữa luồng thô và dữ liệu có kiểu trong Java.\nLưu trạng thái đối tượng – Serialization Serialization là gì? Serialization (chuỗi hóa) là quá trình chuyển đối tượng Java thành luồng byte để:\nLưu vào file Truyền qua mạng Phục hồi lại sau này Deserialization Ngược lại, Deserialization (giải chuỗi) là quá trình:\nĐọc byte Tái tạo lại đối tượng ban đầu Đây là nền tảng cho:\nLưu dữ liệu chương trình Java RMI Truyền object qua mạng Try-with-resources (TWR) Java hỗ trợ Try-with-resources để:\nTự động đóng stream Tránh rò rỉ tài nguyên Code gọn và an toàn hơn So với try-catch truyền thống, TWR:\nÍt lỗi hơn Dễ bảo trì hơn Được khuyến khích sử dụng Các lỗi I/O thường gặp Khi làm việc với luồng, một số exception phổ biến là:\nFileNotFoundException IOException EOFException UnsupportedEncodingException FileAlreadyExistsException AccessDeniedException SocketException MalformedURLException SerializationException InvalidPathException Việc bắt và xử lý exception đúng cách là yêu cầu bắt buộc trong lập trình Java.\nLiên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), luồng nhập xuất được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Truyền dữ liệu Client – Server Java RMI Multicast UDP Không hiểu I/O Stream → không thể làm mạng đúng cách.\nKết luận Qua bài học này, ta đã:\nHiểu khái niệm luồng nhập xuất trong Java Phân biệt luồng byte và luồng ký tự Nắm được cách đọc/ghi dữ liệu với Stream Biết vai trò của Serialization và Filtered Streams Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo Khi xử lý các tác vụ mạng (như gọi API), người mới học JS hay viết code lồng nhau kiểu này:\n1 2 3 4 5 6 7 8 9 10 // Cực hình Callback Hell getData(function(a) { getMoreData(a, function(b) { getMoreData(b, function(c) { getMoreData(c, function(d) { console.log(d); }); }); }); }); ","permalink":"http://localhost:1313/blog/bai-viet-3/","summary":"Tổng quan về Input/Output Streams trong Java – nền tảng cho xử lý file, console và lập trình mạng.","title":"Bài 3: Quản lý luồng nhập xuất trong Java"},{"content":"Trong lập trình mạng, trước khi chương trình có thể gửi hoặc nhận dữ liệu, điều quan trọng nhất là xác định đúng địa chỉ kết nối mạng. Nếu xác định sai địa chỉ, chương trình sẽ không thể giao tiếp, dù phần xử lý dữ liệu có đúng đến đâu.\nBài học này giúp bạn hiểu cách Java làm việc với địa chỉ IP, tên miền (DNS) và URL. Đây là nền tảng bắt buộc trước khi đi vào Socket TCP, UDP, Web Crawler và Java RMI.\nĐịa chỉ kết nối mạng là gì? Địa chỉ kết nối mạng là thông tin dùng để xác định máy nào trong mạng cần giao tiếp và dịch vụ nào trên máy đó sẽ xử lý dữ liệu.\nTrong Internet, địa chỉ kết nối thường bao gồm:\nĐịa chỉ IP Tên miền (Domain Name) Cổng (Port) Giao thức (Protocol) DNS – Domain Name System Hình 4.1 – Mô hình hoạt động của DNS (Domain Name System)\nClient gửi yêu cầu phân giải tên miền đến DNS Server, DNS trả về địa chỉ IP tương ứng để client kết nối đến server đích.*\nCon người dễ nhớ tên miền hơn các dãy số IP.\nDNS (Domain Name System) có nhiệm vụ ánh xạ tên miền sang địa chỉ IP, giúp client tìm đúng server cần kết nối.\nVí dụ:\ngoogle.com tương ứng với nhiều địa chỉ IP khác nhau www.cs.yale.edu tương ứng với 128.36.229.30 Nhờ DNS, người dùng không cần ghi nhớ địa chỉ IP khi truy cập Internet. *Hình 4.2 minh họa cấu trúc phân cấp của hệ thống DNS, bao gồm Root Domain, các Top-Level Domain (com, edu, org, vn, …) và các tên miền con phía dưới.\nCấu trúc phân cấp này giúp DNS hoạt động hiệu quả và dễ mở rộng trên toàn Internet.*\nĐịa chỉ IPv4 *Hình 4.3 minh họa khái niệm Zone trong DNS.\nMỗi Zone là một phần của không gian tên miền và được quản lý bởi một DNS Server có thẩm quyền.\nViệc chia DNS thành các Zone giúp hệ thống dễ quản lý, phân quyền và tăng độ tin cậy.*\nIPv4 là dạng địa chỉ phổ biến, gồm 32 bit, thường được viết thành bốn nhóm số.\nVí dụ:\n192.168.1.1 8.8.8.8 Một số dải địa chỉ đặc biệt:\n127.x.x.x là loopback (localhost) 224.0.0.0 – 239.255.255.255 là multicast Lớp InetAddress trong Java Java cung cấp lớp InetAddress để làm việc với địa chỉ IP và DNS.\nLớp này thường được dùng để:\nPhân giải tên miền sang IP Kiểm tra loại địa chỉ Kiểm tra khả năng kết nối mạng Ví dụ minh họa:\n1 InetAddress address = InetAddress.getByName(\u0026#34;google.com\u0026#34;); URL – Uniform Resource Locator URL được dùng để xác định tài nguyên trên Internet như trang web, file hoặc dịch vụ.\nMột URL đầy đủ thường bao gồm các thành phần sau:\nGiao thức (Protocol) Tên miền (Host) Cổng (Port) Đường dẫn (Path) Chuỗi truy vấn (Query) Ví dụ một URL đầy đủ: https://www.hutech.edu.vn/admission?id=123\nURL cho biết lấy dữ liệu ở đâu và bằng cách nào.\nLớp URL trong Java Lớp URL cho phép chương trình Java:\nPhân tích các thành phần của URL Kết nối tới server Đọc dữ liệu từ Internet Ví dụ minh họa:\n1 URL url = new URL(\u0026#34;https://www.example.com\u0026#34;); Ý nghĩa của việc quản lý địa chỉ kết nối mạng Hiểu rõ cách quản lý địa chỉ mạng giúp:\nTránh kết nối sai server Chuẩn bị đúng địa chỉ cho Socket TCP/UDP Hiểu cách Web Crawler hoạt động Nắm vững mô hình Client – Server Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm địa chỉ kết nối mạng Biết vai trò của DNS và IPv4 Nắm được cách Java làm việc với InetAddress Hiểu cấu trúc và vai trò của URL Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-4/","summary":"Tìm hiểu cách Java quản lý địa chỉ mạng thông qua InetAddress, URL, URLConnection và DNS.","title":"Bài 4: Quản lý địa chỉ kết nối mạng trong Java"},{"content":"Trong lập trình mạng, TCP Socket là cơ chế quan trọng nhất để xây dựng các ứng dụng Client – Server có độ tin cậy cao.\nBài học này giúp bạn hiểu TCP là gì, vì sao cần TCP, và cách Java triển khai TCP thông qua Socket và ServerSocket.\nĐây là bước chuyển tiếp trực tiếp từ kiến thức địa chỉ mạng (IP, DNS, URL) sang giao tiếp dữ liệu thực tế giữa các chương trình.\nTCP là gì? TCP (Transmission Control Protocol) là giao thức truyền thông hướng kết nối, đảm bảo dữ liệu được truyền:\nĐúng thứ tự Đầy đủ Không bị mất mát Không bị trùng lặp Trước khi truyền dữ liệu, TCP yêu cầu thiết lập kết nối giữa hai bên, và chỉ khi kết nối thành công thì dữ liệu mới được trao đổi.\nVì sao sử dụng TCP? TCP được sử dụng khi ứng dụng yêu cầu độ tin cậy cao, ví dụ:\nỨng dụng chat Ứng dụng client–server Truyền file Game online theo lượt Hệ thống ngân hàng, thương mại điện tử TCP cung cấp các cơ chế quan trọng:\nĐảm bảo dữ liệu: gói tin bị mất sẽ được gửi lại Kiểm soát lỗi: phát hiện và sửa lỗi trong quá trình truyền Kiểm soát luồng: tránh làm quá tải phía nhận Giao tiếp hai chiều: cho phép gửi và nhận dữ liệu đồng thời Cơ chế hoạt động của TCP Hình 5.1 – Socket TCP và cơ chế bắt tay 3 bước (Three-way Handshake)\nHình minh họa quá trình thiết lập kết nối TCP giữa Client và Server.\nClient khởi tạo client socket và gửi yêu cầu kết nối.\nServer lắng nghe qua welcoming socket, sau đó tạo connection socket để giao tiếp riêng với client.\nSau khi kết nối được thiết lập thành công, hai bên trao đổi dữ liệu hai chiều thông qua các luồng byte.\nQuá trình giao tiếp TCP gồm ba giai đoạn chính:\nThiết lập kết nối (Bắt tay 3 bước – Three-way Handshake) Truyền dữ liệu Giải phóng kết nối Nhờ cơ chế này, TCP đảm bảo rằng hai bên luôn sẵn sàng trước khi truyền và kết thúc an toàn sau khi hoàn tất.\nMô hình Client – Server Các ứng dụng TCP thường hoạt động theo mô hình Client – Server.\nServer:\nChạy trước Lắng nghe yêu cầu kết nối Cung cấp dịch vụ Trả kết quả cho client Client:\nChạy sau Chủ động kết nối tới server Gửi yêu cầu Nhận phản hồi từ server Quá trình giao tiếp gồm:\nClient gửi yêu cầu Server xử lý Server trả kết quả cho client Socket trong Java Trong Java, Socket đại diện cho điểm cuối giao tiếp giữa client và server khi sử dụng TCP.\nSocket cho phép:\nGửi dữ liệu tới server Nhận dữ liệu từ server Giao tiếp hai chiều thông qua luồng nhập/xuất Ví dụ minh họa tạo Socket phía client:\n1 Socket socket = new Socket(\u0026#34;localhost\u0026#34;, 8080); ServerSocket trong Java ServerSocket được sử dụng ở phía server để:\nMở một cổng lắng nghe Chờ client kết nối Chấp nhận kết nối và tạo Socket giao tiếp ServerSocket đóng vai trò như cửa ngõ, cho phép các client kết nối vào server.\nVí dụ minh họa:\n1 ServerSocket server = new ServerSocket(8080); Luồng dữ liệu trong TCP Socket Sau khi kết nối TCP được thiết lập, client và server trao đổi dữ liệu thông qua các luồng:\nInputStream: dùng để đọc dữ liệu từ socket OutputStream: dùng để ghi dữ liệu vào socket Luồng dữ liệu này hoạt động tương tự như I/O Stream đã học ở bài trước,\nnhưng nguồn và đích là mạng thay vì file hay bàn phím.\nVí dụ ứng dụng: Trò chơi Oẳn Tù Tì Một bài tập tiêu biểu sử dụng TCP Socket là trò chơi Oẳn Tù Tì theo mô hình Client – Server.\nĐặc điểm Server quản lý luật chơi và điểm số Hai client gửi lựa chọn (kéo – búa – bao) Server xác định kết quả và gửi lại cho client Dữ liệu được truyền qua TCP để đảm bảo chính xác Thông qua bài tập này, sinh viên hiểu rõ:\nCách thiết lập kết nối TCP Cách trao đổi dữ liệu giữa nhiều client Cách xử lý lỗi mạng và ngoại lệ Ý nghĩa của lập trình TCP Socket Việc nắm vững TCP Socket giúp bạn:\nHiểu bản chất giao tiếp mạng Xây dựng hệ thống Client – Server thực tế Chuẩn bị cho các bài nâng cao như: Đa tuyến (Multi-thread) Socket UDP Java RMI Ứng dụng mạng phân tán Kết luận Qua bài học này, bạn đã:\nHiểu TCP là gì và vì sao cần TCP Nắm được mô hình Client – Server Biết vai trò của Socket và ServerSocket trong Java Hiểu cách dữ liệu được truyền qua TCP Chuẩn bị nền tảng cho các bài học UDP và xử lý đồng thời tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-5/","summary":"Giải thích mô hình Client–Server và cách lập trình Socket TCP trong Java – nền tảng cho giao tiếp mạng tin cậy.","title":"Bài 5: Lập trình Socket TCP trong Java"},{"content":"#Trong lập trình mạng, không phải lúc nào ứng dụng cũng cần độ tin cậy tuyệt đối như TCP.\nTrong nhiều trường hợp, điều quan trọng hơn là tốc độ truyền nhanh và độ trễ thấp.\nBài học này giới thiệu UDP Socket – cơ chế truyền dữ liệu không kết nối, được sử dụng rộng rãi trong các ứng dụng thời gian thực.\nUDP là gì? UDP (User Datagram Protocol) là giao thức truyền thông không hướng kết nối.\nĐiều này có nghĩa là:\nKhông thiết lập kết nối trước khi truyền Không đảm bảo dữ liệu đến nơi Không đảm bảo thứ tự gói tin Không tự động gửi lại gói tin bị mất UDP gửi dữ liệu theo từng datagram (gói tin độc lập).\nSo sánh TCP và UDP TCP UDP Có kết nối Không kết nối Đảm bảo dữ liệu Không đảm bảo Truyền theo luồng Truyền theo gói Độ trễ cao hơn Độ trễ thấp Phù hợp dữ liệu quan trọng Phù hợp dữ liệu thời gian thực Khi nào sử dụng UDP? UDP được sử dụng khi:\nCần truyền nhanh Có thể chấp nhận mất gói tin Dữ liệu được gửi liên tục Ví dụ ứng dụng UDP:\nTruyền video, audio trực tuyến Game online thời gian thực Chat broadcast DNS Multicast, streaming UDP Socket trong Java Java hỗ trợ UDP thông qua hai lớp chính:\nDatagramSocket: quản lý socket UDP DatagramPacket: đại diện cho gói dữ liệu UDP UDP không phân biệt client hay server rõ ràng như TCP.\nMỗi chương trình chỉ cần một DatagramSocket để gửi và nhận dữ liệu.\nDatagramPacket là gì? DatagramPacket là gói dữ liệu UDP, bao gồm:\nDữ liệu cần gửi Địa chỉ IP đích Số hiệu cổng Mỗi lần gửi hoặc nhận dữ liệu, UDP làm việc với một DatagramPacket riêng biệt.\nLuồng dữ liệu trong UDP UDP không có luồng InputStream / OutputStream như TCP.\nQuy trình truyền dữ liệu UDP:\nTạo DatagramSocket Tạo DatagramPacket chứa dữ liệu Gửi packet đi Nhận packet về Đọc dữ liệu từ packet Mỗi gói tin là độc lập, không liên quan đến các gói khác.\nĐặc điểm quan trọng của UDP Không kiểm soát lỗi Không kiểm soát luồng Không bắt tay kết nối Gửi nhanh, xử lý đơn giản Phù hợp truyền broadcast và multicast Chính vì vậy, UDP thường được dùng khi tốc độ quan trọng hơn độ chính xác tuyệt đối.\nÝ nghĩa của lập trình Socket UDP Nắm vững UDP giúp bạn:\nHiểu bản chất truyền dữ liệu không kết nối Xây dựng ứng dụng thời gian thực Phân biệt rõ TCP và UDP trong thiết kế hệ thống Chuẩn bị cho các chủ đề nâng cao như: Multicast UDP Java RMI Hệ thống phân tán Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính, UDP được sử dụng trong:\nSocket UDP Multicast Ứng dụng truyền tin nhanh Game, streaming, broadcast Hiểu UDP giúp bạn chọn đúng giao thức cho từng bài toán thực tế.\nKết luận Qua bài học này, bạn đã:\nHiểu UDP là gì và cơ chế hoạt động Phân biệt được TCP và UDP Biết vai trò của DatagramSocket và DatagramPacket Hiểu cách truyền dữ liệu không kết nối Chuẩn bị nền tảng cho bài Multicast UDP \u0026amp; Java RMI tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-6/","summary":"Giải thích giao thức UDP và cách Java lập trình Socket UDP – nền tảng cho truyền dữ liệu nhanh, không kết nối.","title":"Bài 6: Lập trình Socket UDP trong Java"},{"content":"Trong các ứng dụng mạng thực tế, đặc biệt là Server, chương trình thường phải xử lý nhiều yêu cầu cùng lúc.\nNếu chỉ sử dụng một luồng thực thi, server sẽ bị tắc nghẽn, các client phải chờ đợi và hiệu năng giảm nghiêm trọng.\nVì vậy, lập trình đa tuyến (Multithreading) và xử lý đồng thời (Concurrency) là kỹ thuật bắt buộc trong lập trình mạng.\nTuyến (Thread) là gì? Thread là một dòng điều khiển tuần tự bên trong một chương trình.\nMột chương trình (process) có thể chứa nhiều thread Các thread có thể chạy đồng thời Mỗi thread thực hiện một nhiệm vụ riêng Thread không phải là một chương trình độc lập,\nnó luôn thuộc về một process.\nProcess và Thread Process:\nCó không gian bộ nhớ riêng Chạy độc lập với process khác Tạo và chuyển đổi tốn nhiều tài nguyên Thread:\nChia sẻ bộ nhớ với các thread khác trong cùng process Tạo nhanh hơn process Chuyển đổi nhanh hơn Nhờ thread, chương trình có thể thực hiện nhiều công việc cùng lúc trong cùng một ứng dụng.\nVì sao cần lập trình đa tuyến? Lập trình đa tuyến giúp:\nTăng hiệu suất và khả năng đáp ứng Tận dụng thời gian chờ đợi (I/O, mạng, tải file) Chia nhỏ tác vụ và xử lý đồng thời Cải thiện trải nghiệm người dùng Trong lập trình mạng, đa tuyến cho phép server phục vụ nhiều client cùng lúc.\nThực thi Thread trong Java Trong Java, một thread bắt đầu chạy khi gọi phương thức start().\nKhi thread chạy, JVM thực thi mã trong phương thức run() Khi run() kết thúc, thread cũng kết thúc Một thread không thể start lại, muốn chạy lại phải tạo thread mới Thread cần có điều kiện dừng rõ ràng để tránh chạy vô hạn.\nỨng dụng đa tuyến trong lập trình mạng Ứng dụng Chat đa tuyến Một ví dụ tiêu biểu của đa tuyến trong mạng là ứng dụng chat nhiều client – một server.\nĐặc điểm:\nServer chấp nhận nhiều client kết nối cùng lúc Mỗi client được xử lý bởi một thread riêng Tin nhắn từ một client được gửi tới tất cả client khác Server ghi lại nội dung chat vào file log Thông qua ví dụ này, sinh viên hiểu rõ:\nCách server xử lý nhiều kết nối đồng thời Cách phối hợp giữa socket và thread Vai trò của đa tuyến trong ứng dụng mạng Xử lý đồng thời (Concurrency) Xử lý đồng thời xảy ra khi nhiều thread:\nChạy cùng lúc Truy cập tài nguyên chung (biến, file, bộ nhớ) Nếu không kiểm soát tốt, chương trình có thể gặp các vấn đề nghiêm trọng.\nRace Condition Race Condition xảy ra khi:\nNhiều thread cùng truy cập và thay đổi dữ liệu chung Kết quả phụ thuộc vào thứ tự thực thi không xác định Điều này có thể dẫn đến:\nDữ liệu sai lệch Kết quả không nhất quán Lỗi khó phát hiện Đồng bộ hóa (Synchronization) Để tránh race condition, Java cung cấp cơ chế đồng bộ hóa:\nĐảm bảo chỉ một thread được truy cập tài nguyên tại một thời điểm Giữ cho dữ liệu luôn nhất quán Đồng bộ hóa là nền tảng để xây dựng các ứng dụng an toàn và ổn định khi chạy đa tuyến.\nCác vấn đề thường gặp trong xử lý đồng thời Một số vấn đề phổ biến:\nRace condition: tranh chấp dữ liệu Deadlock: các thread chờ nhau vô hạn Livelock: các thread liên tục phản ứng nhưng không tiến triển Starvation: thread không bao giờ được cấp tài nguyên Những vấn đề này khiến lập trình đa tuyến trở nên phức tạp và khó debug.\nLập lịch Thread trong Java Java sử dụng cơ chế lập lịch theo độ ưu tiên:\nMỗi thread có độ ưu tiên từ MIN_PRIORITY đến MAX_PRIORITY JVM chọn thread runnable có độ ưu tiên cao hơn để chạy Thread có thể nhường CPU cho thread khác bằng cách gọi yield() Việc hiểu cơ chế lập lịch giúp lập trình viên thiết kế thread hợp lý hơn.\nÝ nghĩa của lập trình đa tuyến và xử lý đồng thời Nắm vững kiến thức bài này giúp bạn:\nXây dựng server xử lý nhiều client Viết ứng dụng mạng hiệu năng cao Tránh lỗi tranh chấp dữ liệu Chuẩn bị cho các chủ đề nâng cao như: Server đa tuyến Pooling Threads Multicast UDP Java RMI Hệ thống phân tán Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm thread và multithreading Phân biệt process và thread Biết vai trò của đa tuyến trong lập trình mạng Hiểu các vấn đề xử lý đồng thời và race condition Chuẩn bị nền tảng cho các bài học nâng cao tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-7/","summary":"Giải thích lập trình đa tuyến và xử lý đồng thời trong Java – nền tảng cho các ứng dụng mạng nhiều client và hệ thống phân tán.","title":"Bài 7: Lập trình đa tuyến và xử lý đồng thời trong Java"},{"content":"Buổi 8 gồm 2 phần lớn:\nMulticast UDP: gửi dữ liệu từ một nguồn đến nhiều máy nhận cùng lúc (1 → N). Java RMI: gọi phương thức từ xa giữa các ứng dụng Java như gọi hàm bình thường (Remote Method Invocation). Đây là các kỹ thuật thường gặp trong streaming, trò chuyện nhóm, giám sát từ xa và hệ thống phân tán.\n1) UDP Multicast Unicast, Broadcast và Multicast Trong mạng máy tính có 3 kiểu gửi dữ liệu phổ biến:\nUnicast: 1 nguồn → 1 đích\nVí dụ: bạn mở một trang web, server trả dữ liệu cho riêng bạn.\nBroadcast: 1 nguồn → tất cả máy trong mạng nội bộ\nVí dụ: một thông báo phát cho toàn bộ LAN.\nMulticast: 1 nguồn → một nhóm máy đã đăng ký nhận dữ liệu\nVí dụ: server phát stream video cho nhóm người xem cùng lúc.\nMulticast là cách truyền hiệu quả khi nhiều máy cùng cần nhận một nội dung giống nhau.\nTại sao dùng UDP Multicast? UDP Multicast thường được dùng vì:\nHiệu suất cao: gửi 1 lần nhưng nhiều máy nhận → giảm tải mạng và server. Đơn giản, nhanh: UDP là kiểu “gửi và quên”, không phải chờ xác nhận. Tối ưu trong LAN: phù hợp môi trường mạng nội bộ (Local Area Network). Rất hợp streaming: audio/video cần tốc độ và độ trễ thấp hơn là đảm bảo tuyệt đối. Ứng dụng của Multicast Multicast có thể dùng trong:\nTruyền phát multimedia trực tiếp (audio/video streaming) Trò chuyện nhóm, hội thoại nhóm Quảng bá thông tin cấu hình mạng và cập nhật trong hệ thống mạng Game nhiều người chơi (gửi trạng thái game cho nhiều người) Phát thông tin trạng thái/cảnh báo cho nhiều thiết bị Phát tán cập nhật phần mềm trong mạng nội bộ Địa chỉ Multicast IPv4 Trong IPv4:\nClass D là dải địa chỉ dành cho multicast Dải địa chỉ multicast thường gặp: 224.0.0.0 – 239.255.255.255 Một số nhóm multicast hay được nhắc:\n224.0.0.1: tất cả host trong local subnet Multicast Group là gì? Multicast hoạt động theo “nhóm”:\nMột multicast group giống như một kênh. Máy nào muốn nhận dữ liệu phải tham gia nhóm (join group). Khi rời nhóm thì không nhận dữ liệu nữa. Multicast trong Java Java hỗ trợ multicast qua lớp:\njava.net.MulticastSocket (kế thừa từ DatagramSocket) Một số thao tác quan trọng:\njoinGroup(...): tham gia nhóm multicast leaveGroup(...): rời nhóm multicast setTimeToLive(ttl): đặt TTL (thời gian sống của gói tin, qua bao nhiêu router) Quy trình gửi dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket Tham gia nhóm multicast Tạo DatagramPacket chứa dữ liệu + địa chỉ nhóm + port Gửi packet Rời nhóm Ví dụ minh họa (ngắn, chỉ để hiểu):\n1 2 3 4 5 6 7 8 9 10 11 12 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(); socket.joinGroup(group); socket.setTimeToLive(5); byte[] data = \u0026#34;Hello Multicast\u0026#34;.getBytes(); DatagramPacket packet = new DatagramPacket(data, data.length, group, 9876); socket.send(packet); socket.leaveGroup(group); socket.close(); Quy trình nhận dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket lắng nghe trên port Tham gia nhóm multicast Tạo DatagramPacket rỗng để nhận dữ liệu Gọi receive() để chờ gói tin gửi về Đọc dữ liệu từ packet Rời nhóm và đóng socket Ví dụ minh họa (ngắn):\n1 2 3 4 5 6 7 8 9 10 11 12 13 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(9876); socket.joinGroup(group); byte[] buf = new byte[1024]; DatagramPacket packet = new DatagramPacket(buf, buf.length); socket.receive(packet); String msg = new String(packet.getData(), 0, packet.getLength()); System.out.println(\u0026#34;Received: \u0026#34; + msg); socket.leaveGroup(group); socket.close(); 2) Java RMI Java RMI là gì? RMI (Remote Method Invocation) cho phép chương trình Java:\nGọi phương thức của một đối tượng nằm trên máy khác Cảm giác giống như gọi method trong cùng chương trình Nói đơn giản:\nClient gọi: remoteObject.sum(1,2) Server thực thi thật và trả kết quả về cho client RMI giúp che giấu toàn bộ chi tiết mạng phía sau, người lập trình chỉ tập trung vào logic.\nVì sao dùng Java RMI? Java RMI được sử dụng vì:\nTích hợp sẵn trong Java, dễ triển khai nếu cả client và server đều dùng Java Gọi phương thức từ xa đơn giản như gọi hàm thông thường Hỗ trợ dữ liệu phức tạp: đối tượng, mảng, class tự định nghĩa Tự động xử lý giao tiếp mạng thông qua cơ chế stub / skeleton Dựa trên TCP/IP nên tương đối ổn định và tin cậy Hạn chế của Java RMI Một số điểm hạn chế cần lưu ý:\nPhụ thuộc Java: chủ yếu phù hợp Java ↔ Java Thiết kế dịch vụ phức tạp vẫn cần tổ chức tốt (đặc biệt khi dùng callback) Quản lý phiên và kết nối không mạnh như các giải pháp hiện đại Bảo mật cần cấu hình cẩn thận trong môi trường thực tế Ý tưởng kiến trúc RMI (hiểu nhanh) Trong Java RMI có các thành phần chính:\nRemote Interface\nKhai báo các phương thức cho phép gọi từ xa\nServer Implementation\nLớp cài đặt interface, chứa logic xử lý thật\nRMI Registry\nNơi đăng ký service để client tìm thấy server\nClient\nTìm (lookup) service trong registry và gọi phương thức\nCác bước triển khai RMI (tóm tắt) Định nghĩa Remote Interface Cài đặt interface bằng một class server (remote object) Viết chương trình server: tạo object và bind vào registry Viết chương trình client: lookup registry và gọi method Chạy RMI registry, chạy server, sau đó chạy client Ví dụ ứng dụng RMI Một số ví dụ thường gặp:\nTính tổng 2 số từ xa Dịch vụ quản lý tài khoản ATM Dịch vụ giám sát nhiệt độ có callback (server gọi ngược lại client) Bài tập gợi ý theo đúng nội dung buổi 8 BT8.01: Mô phỏng streaming video\n(1 server phát, nhiều client nhận dữ liệu)\nBT8.02: Server quản lý tài khoản ATM bằng RMI\n(thêm user, đăng nhập, gửi/rút tiền, lưu lịch sử giao dịch)\nKết luận Qua bài học này, bạn đã:\nHiểu sự khác nhau giữa Unicast, Broadcast và Multicast Nắm được vì sao Multicast UDP phù hợp cho truyền dữ liệu nhóm và streaming Biết cách Java hỗ trợ multicast qua MulticastSocket Hiểu Java RMI và cơ chế gọi phương thức từ xa Chuẩn bị nền tảng cho các bài ứng dụng mạng phân tán và đồ án học phần ","permalink":"http://localhost:1313/blog/bai-viet-8/","summary":"Giải thích Multicast UDP (gửi 1-n) và Java RMI (gọi phương thức từ xa) – nền tảng cho ứng dụng nhóm và hệ phân tán.","title":"Bài 8: Multicast UDP và Java RMI"},{"content":"Sau khi hoàn thành các bài về TCP, UDP, đa tuyến và xử lý đồng thời,\nchúng ta đã có đủ nền tảng để xây dựng một ứng dụng mạng hoàn chỉnh.\nBài học này giúp bạn xâu chuỗi toàn bộ kiến thức đã học,\nhiểu rõ mỗi công nghệ dùng trong trường hợp nào,\nvà cách thiết kế một hệ thống mạng đúng tư duy kỹ sư.\nNhìn lại các mô hình giao tiếp mạng đã học Trong lập trình mạng, các ứng dụng thường được xây dựng dựa trên mô hình Client – Server.\nClient: gửi yêu cầu, nhập dữ liệu, hiển thị kết quả Server: xử lý logic, quản lý dữ liệu, trả kết quả Tùy bài toán, ta lựa chọn giao thức và mô hình phù hợp.\nSo sánh TCP, UDP và Multicast TCP – Giao tiếp tin cậy TCP phù hợp khi:\nCần đảm bảo dữ liệu đúng và đủ Cần kết nối ổn định, hai chiều Ví dụ: chat, truyền file, game theo lượt, hệ thống ngân hàng Đặc trưng:\nCó bắt tay 3 bước Có kiểm soát lỗi, kiểm soát luồng Tốn tài nguyên hơn UDP UDP – Giao tiếp nhanh, không kết nối UDP phù hợp khi:\nƯu tiên tốc độ Chấp nhận mất gói Ví dụ: game thời gian thực, streaming, cảm biến Đặc trưng:\nKhông kết nối Không đảm bảo thứ tự Ít độ trễ UDP Multicast – Truyền dữ liệu nhóm Multicast được dùng khi:\nMột nguồn → nhiều người nhận Dữ liệu giống nhau cho tất cả client Ví dụ: livestream, thông báo hệ thống, truyền trạng thái Ưu điểm:\nGiảm tải server Tiết kiệm băng thông Phù hợp mạng LAN Vai trò của đa tuyến (Multithreading) Trong thực tế, server không thể xử lý từng client một cách tuần tự.\nĐa tuyến giúp:\nNhiều client kết nối cùng lúc Không client nào bị “đóng băng” Tăng khả năng mở rộng hệ thống Ví dụ:\nServer chat: mỗi client là một thread Server TCP: mỗi socket được xử lý riêng Thiết kế một ứng dụng mạng hoàn chỉnh Khi thiết kế, cần xác định rõ:\nGiao thức: TCP hay UDP? Mô hình: 1–1, 1–n, n–n? Đồng thời hay tuần tự? Client gửi gì? Server xử lý gì? Một thiết kế tốt luôn:\nPhân tách rõ giao tiếp – xử lý – dữ liệu Dễ mở rộng Dễ bảo trì Liên hệ với đồ án học phần Các đồ án như:\nChat đa tuyến Oẳn Tù Tì client–server Streaming UDP Dịch vụ RMI Đều là sự kết hợp của các kiến thức đã học,\nkhông phải nội dung mới.\nKết luận Qua bài học này, bạn đã:\nHệ thống lại toàn bộ kiến thức lập trình mạng Hiểu rõ khi nào dùng TCP, UDP, Multicast Nắm được vai trò của đa tuyến Biết cách tư duy thiết kế một ứng dụng mạng hoàn chỉnh Đây là bước chuẩn bị quan trọng trước khi vận dụng toàn bộ kiến thức vào một hệ thống thực tế.\n","permalink":"http://localhost:1313/blog/bai-viet-9/","summary":"Tổng hợp kiến thức TCP, UDP, đa tuyến và cách thiết kế ứng dụng mạng Client–Server hoàn chỉnh.","title":"Bài 9: Tổng hợp kiến thức \u0026 thiết kế ứng dụng mạng"},{"content":"Bài cuối cùng của học phần không nhằm giới thiệu công nghệ mới,\nmà tập trung vào cách vận dụng kiến thức đã học vào thực tế.\nĐây là giai đoạn chuyển từ:\n“Biết dùng” → “Biết thiết kế” → “Biết đánh giá hệ thống”\nTư duy vận dụng kiến thức Một ứng dụng mạng hoàn chỉnh cần trả lời được các câu hỏi:\nVì sao chọn TCP mà không phải UDP? Vì sao cần đa tuyến? Server có chịu được nhiều client không? Hệ thống có mở rộng được không? Đây chính là tư duy kỹ sư, không phải chỉ “chạy được là xong”.\nĐánh giá một ứng dụng mạng Khi hoàn thiện hệ thống, cần xem xét:\n1. Tính đúng đắn Dữ liệu có truyền đúng không? Có mất gói không? Có xử lý lỗi không? 2. Tính đồng thời Nhiều client có dùng chung được không? Có bị treo server không? Có race condition không? 3. Hiệu năng Độ trễ thế nào? Server có bị quá tải không? Có tách luồng hợp lý không? Liên hệ với các mô hình phân tán Các hệ thống đã học là nền tảng cho:\nHệ thống client–server lớn Ứng dụng phân tán Microservices Cloud services Java RMI, TCP đa tuyến hay UDP Multicast\nđều là những viên gạch đầu tiên.\nTừ học phần đến thực tế Sau học phần này, bạn có thể tiếp cận:\nWebSocket REST API gRPC Message Queue (Kafka, RabbitMQ) Hệ thống realtime Tư duy lập trình mạng không thay đổi, chỉ công nghệ thay đổi.\nTổng kết toàn bộ học phần Qua toàn bộ chuỗi bài, bạn đã:\nHiểu cách dữ liệu đi qua mạng Làm việc với TCP, UDP, Multicast Xử lý đa tuyến và đồng thời Tiếp cận lập trình phân tán với RMI Có tư duy thiết kế hệ thống mạng Lời kết Lập trình mạng không chỉ là code socket,\nmà là hiểu cách các hệ thống nói chuyện với nhau.\nNếu bạn hiểu được điều đó,\nbạn đã vượt xa mức “học để qua môn”.\n","permalink":"http://localhost:1313/blog/bai-viet-10/","summary":"Vận dụng toàn bộ kiến thức lập trình mạng để xây dựng, đánh giá và hoàn thiện một ứng dụng thực tế.","title":"Bài 10: Hoàn thiện \u0026 vận dụng lập trình mạng"},{"content":"Lời mở đầu Có những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\nMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\nHọc tập Những năm đại học trôi qua nhanh hơn mình từng nghĩ. Ngày mới bước chân vào giảng đường, mình vẫn còn khá mơ hồ về ngành học, về tương lai, về chính bản thân mình sẽ trở thành ai sau bốn năm. Nhưng rồi từng môn học, từng bài tập nhóm, từng đồ án kéo mình lại gần hơn với cách một hệ thống được hình thành và vận hành.\nHệ thống thông tin không chỉ là lập trình, cũng không đơn thuần là công nghệ. Đó là câu chuyện về con người, quy trình và dữ liệu. Mình học cách đặt câu hỏi, học cách lắng nghe yêu cầu, học cách vẽ ra những sơ đồ tưởng chừng khô khan nhưng lại chứa rất nhiều suy nghĩ phía sau. Dần dần, mình nhận ra mình thích phần “hiểu vấn đề” hơn là chỉ chăm chăm vào lời giải.\nĐịnh hướng Ở thời điểm hiện tại, mình đang định hướng theo con đường Business Analyst (BA). Mình hứng thú với vai trò đứng giữa – không quá xa kỹ thuật, cũng không tách rời nghiệp vụ. Đó là nơi cần sự rõ ràng trong tư duy, sự kiên nhẫn trong giao tiếp và khả năng chuyển hóa những điều mơ hồ thành thứ có thể triển khai được.\nMình không nghĩ BA là một vị trí “nhẹ nhàng” hay “an toàn”. Ngược lại, đó là công việc đòi hỏi phải học rất nhiều, sai rất nhiều và sửa rất nhiều. Nhưng chính điều đó khiến mình thấy phù hợp. Mình muốn hiểu hệ thống trước khi xây dựng nó, muốn biết vì sao người ta see cần một chức năng, chứ không chỉ là nó được viết như thế nào.\nBlog Blog này ra đời khá tự nhiên, giống như một cuốn sổ mở rộng hơn là một trang thể hiện điều gì đó to tát. Mình viết để nhớ, để hệ thống lại những gì đã học, và đôi khi là để sắp xếp lại suy nghĩ của chính mình.\nỞ đây có thể là kiến thức về Hệ thống thông tin, về phân tích nghiệp vụ, về lập trình, hoặc đơn giản là những trải nghiệm học tập và va chạm trong quá trình làm đồ án, làm việc nhóm, và chuẩn bị bước ra môi trường thực tế. Mình không mong mọi thứ phải hoàn hảo, chỉ mong nó thật và có ích cho ai đó đang đi trên con đường tương tự.\nLời kết Mình đang ở một giai đoạn chưa thể gọi là trưởng thành, nhưng cũng không còn quá non nớt. Vẫn đang học, vẫn đang thử, vẫn đang sai và sửa mỗi ngày. Nếu có một điều mình mong giữ được lâu nhất, thì đó là sự tò mò và tinh thần học hỏi – những thứ giúp mình không đứng yên giữa rất nhiều lựa chọn ngoài kia.\nCảm ơn bạn đã ghé qua và đọc những dòng này. Hy vọng ở một thời điểm nào đó, những chia sẻ nhỏ ở đây sẽ chạm đến bạn – dù chỉ là một chút. \u0026ldquo;Học để chia sẻ, chia sẻ để học nhiều hơn.\u0026rdquo;\nLiên hệ Nếu bạn muốn gửi cho mình vài dòng trao đổi,\nbạn có thể liên hệ với mình qua Email hoặc GitHub ,Facebook dưới đây.\nCảm ơn bạn đã ghé thăm blog! ","permalink":"http://localhost:1313/about/","summary":"\u003ch2 id=\"lời-mở-đầu\"\u003eLời mở đầu\u003c/h2\u003e\n\u003cp\u003eCó những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\u003c/p\u003e\n\u003cp\u003eMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\u003c/p\u003e","title":"Giới thiệu"},{"content":"Trong lập trình mạng, trước khi kết nối, ta phải biết \u0026ldquo;địa chỉ nhà\u0026rdquo; (IP) của mình và đối phương. Java cung cấp class\nHình 1.1: Hiệu ứng Dunning–Kruger – mức độ tự tin thay đổi theo kinh nghiệm học tập\nGóc nhìn học tập: Hiệu ứng Dunning–Kruger InetAddress để làm việc này.\nĐịa chỉ IP là gì trong lập trình mạng? IP (Internet Protocol Address) là địa chỉ định danh của một thiết bị khi tham gia vào mạng máy tính.\nTrong lập trình mạng, IP đóng vai trò quan trọng trong việc:\nXác định máy gửi và máy nhận Định tuyến dữ liệu trong quá trình truyền thông Thiết lập kết nối giữa các tiến trình chạy trên những máy khác nhau Nếu không có địa chỉ IP, các máy tính sẽ không thể nhận biết và giao tiếp với nhau.\nVai trò của lớp InetAddress trong Java Lớp InetAddress đại diện cho một địa chỉ IP trong Java.\nThông qua lớp này, lập trình viên có thể:\nLấy địa chỉ IP của máy đang chạy chương trình Lấy tên máy (hostname) Phân giải tên miền sang địa chỉ IP Chuẩn bị thông tin để tạo Socket hoặc ServerSocket Hầu hết các chương trình lập trình mạng trong Java đều sử dụng InetAddress ở bước khởi tạo.\nPhân tích ý nghĩa các lệnh trong chương trình InetAddress.getLocalHost()\n→ Trả về đối tượng đại diện cho máy cục bộ (localhost).\ngetHostName()\n→ Lấy tên máy do hệ điều hành hoặc mạng gán.\ngetHostAddress()\n→ Lấy địa chỉ IP của máy dưới dạng chuỗi.\nViệc in ra hostname và IP giúp:\nKiểm tra cấu hình mạng Xác định đúng máy khi kết nối Client – Server Debug lỗi mạng Một số lưu ý khi lấy IP trong Java Khi máy không kết nối mạng, IP có thể là 127.0.0.1 Khi máy có nhiều card mạng (WiFi, LAN, VPN), IP trả về có thể không phải IP Internet Trên Server, hostname và IP thường khác máy cá nhân Ứng dụng thực tế Việc xác định IP của máy thường được sử dụng trong:\nChương trình Client – Server Thông báo IP Server cho Client kết nối Kiểm tra kết nối mạng LAN Ghi log và giám sát hệ thống Kết luận Qua bài học này, ta đã:\nHiểu vai trò của địa chỉ IP trong lập trình mạng Biết cách lấy IP bằng lớp InetAddress Chuẩn bị nền tảng cho các kỹ thuật TCP, UDP và RMI Liên hệ với học phần Lập trình Mạng máy tính Bài học này nằm trong nội dung mở đầu của học phần Lập trình Mạng máy tính (CMP180) tại Trường Đại học Công nghệ TP.HCM (HUTECH).\nTrong lộ trình môn học, sinh viên sẽ lần lượt tiếp cận các nội dung:\nKiến thức nền tảng về mạng và lập trình mạng Quản lý luồng nhập xuất (I/O) Quản lý địa chỉ và kết nối mạng Lập trình Socket TCP và UDP Xử lý đa tuyến, đa luồng Multicast UDP và Java RMI Thực hiện đồ án học phần cá nhân Mục tiêu của bài học Thông qua Bài 1, sinh viên sẽ:\nLàm quen với môi trường lập trình mạng bằng Java Hiểu được vai trò của địa chỉ IP trong giao tiếp mạng Biết cách sử dụng lớp InetAddress để lấy IP và hostname Chuẩn bị nền tảng cho các bài học tiếp theo về Socket và Server – Client ","permalink":"http://localhost:1313/blog/bai-viet-1/","summary":"GIỚI THIỆU HỌC PHẦN.","title":"Bài 1: Tổng quan khoá học"},{"content":"Trong lập trình mạng, nếu IP được xem như địa chỉ nhà của một máy tính trong mạng,\nthì Port (cổng) chính là số hiệu dùng để xác định chương trình hoặc dịch vụ cụ thể đang chạy trên máy đó.\nMột máy tính có thể chạy đồng thời nhiều ứng dụng mạng như Web Server, Database Server, Game Server hoặc Chat Server.\nMỗi ứng dụng bắt buộc phải gắn với một Port riêng để hệ điều hành có thể phân biệt và định tuyến dữ liệu chính xác.\nPort nằm ở đâu trong mô hình TCP/IP? Trong bộ giao thức TCP/IP, Port thuộc về Transport Layer (Tầng giao vận) và được sử dụng bởi hai giao thức chính là TCP và UDP.\nĐịa chỉ IP xác định máy nào sẽ nhận dữ liệu Port xác định ứng dụng nào trên máy đó sẽ xử lý dữ liệu Sự kết hợp giữa IP + Port tạo thành một Socket, là điểm cuối (endpoint) của quá trình giao tiếp mạng.\nCác loại Port phổ biến Port được đánh số từ 0 đến 65535 và được chia thành ba nhóm chính:\nInternet và các End Devices Trước khi tìm hiểu về Port, cần hiểu Internet được cấu thành từ hàng tỷ thiết bị đầu cuối (End Devices) như máy tính, điện thoại, máy chủ và các thiết bị IoT.\nCác thiết bị này kết nối với nhau thông qua nhiều lớp mạng khác nhau, và mỗi thiết bị khi tham gia giao tiếp mạng đều cần có địa chỉ IP và Port để định danh. Hình 2.1: Sơ đồ minh họa Internet và các thiết bị đầu cuối (End Devices) kết nối thông qua các mạng truy cập và mạng lõi.\nTrong quá trình giao tiếp mạng, một thiết bị không chỉ cần địa chỉ IP để xác định vị trí trong mạng, mà còn cần Port để xác định chính xác ứng dụng hoặc dịch vụ đang lắng nghe trên thiết bị đó.\nDo đó, Port đóng vai trò như “điểm tiếp nhận” (endpoint) cho các tiến trình mạng chạy trên cùng một máy.\nMô hình các tầng giao thức TCP/IP Để hiểu rõ Port hoạt động ở đâu và vì sao Server cần Port, ta cần nắm được mô hình giao thức TCP/IP – nền tảng của mọi ứng dụng mạng hiện nay.\nHình 2.2: Mô hình các tầng giao thức TCP/IP và các giao thức tiêu biểu tương ứng với từng tầng.\nTrong mô hình TCP/IP, địa chỉ IP hoạt động ở tầng Internet, giúp xác định thiết bị trong mạng.\nTrong khi đó, Port hoạt động ở tầng Transport (TCP/UDP), giúp xác định chính xác ứng dụng hoặc dịch vụ đang giao tiếp trên thiết bị đó.\nWell-known Ports (0 – 1023) Được dùng cho các dịch vụ chuẩn:\nPort 80: HTTP Port 443: HTTPS Port 21: FTP Port 25: SMTP Registered Ports (1024 – 49151) Thường dùng cho các ứng dụng phổ biến:\nPort 3306: MySQL Port 8080: Web Server thay thế port 80 Dynamic / Private Ports (49152 – 65535) Do hệ điều hành cấp phát tạm thời cho Client khi giao tiếp mạng.\nVì sao Server thường dùng cổng 8080? Cổng 8080 rất phổ biến trong quá trình phát triển và học tập vì:\nTránh xung đột với cổng 80 đang được hệ điều hành chiếm dụng Không cần quyền Administrator khi mở Server Phù hợp cho các Web Server thử nghiệm như: Apache Tomcat Spring Boot Node.js Lỗi thường gặp: “Address already in use” Lỗi này xảy ra khi Server cố gắng mở một Port đã bị chương trình khác chiếm dụng.\nNguyên nhân phổ biến:\nServer cũ chưa được tắt Port đang được dùng bởi dịch vụ khác Chạy nhiều Server cùng lúc Cách khắc phục:\nĐổi sang Port khác (ví dụ: 8080 → 9090) Kiểm tra Port đang sử dụng trong hệ điều hành Đảm bảo chỉ có một Server chạy tại một thời điểm Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), khái niệm Port sẽ được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Xây dựng mô hình Client – Server Java RMI và Multicast Việc hiểu rõ Port là nền tảng bắt buộc trước khi triển khai các ứng dụng mạng thực tế.\nKết luận Qua bài học này, ta đã:\nHiểu được Port là gì và vai trò của Port trong lập trình mạng Nắm được mối quan hệ giữa IP, Port và Socket Giải thích được lý do Server thường sử dụng cổng 8080 Chuẩn bị kiến thức nền cho các bài học tiếp theo về TCP và UDP ","permalink":"http://localhost:1313/blog/bai-viet-2/","summary":"MẠNG MÁY TÍNH \u0026amp; INTERNET.","title":"Bài 2: Kiến thức nền tảng?"},{"content":"Trong lập trình Java, luồng nhập xuất (Input / Output Streams) đóng vai trò trung gian giúp chương trình đọc và ghi dữ liệu từ nhiều nguồn khác nhau như bàn phím, file, console, bộ nhớ và sau này là socket mạng.\nHiểu rõ cơ chế luồng nhập xuất là bước nền bắt buộc trước khi đi vào lập trình Socket TCP, UDP hay Java RMI.\nLuồng (Stream) là gì? Luồng (Stream) là dòng dữ liệu di chuyển\ntừ nguồn → chương trình hoặc từ chương trình → đích.\nKhi Java đọc hoặc ghi dữ liệu, dữ liệu không đi trực tiếp mà luôn được đóng gói và truyền qua luồng.\nLuồng nhập xuất là gì? Luồng nhập xuất là cơ chế cho phép chương trình:\nNhận dữ liệu từ bên ngoài (Input) Ghi dữ liệu ra bên ngoài (Output) Luồng có thể kết nối với nhiều nguồn và đích khác nhau:\nFile Bàn phím Màn hình (console) Bộ nhớ Kết nối mạng (TCP / UDP) Dữ liệu trong luồng tồn tại dưới những dạng nào? Trong Java, dữ liệu trong luồng tồn tại dưới hai dạng chính:\nLuồng byte Luồng ký tự Việc chọn đúng loại luồng ảnh hưởng trực tiếp đến hiệu năng và tính chính xác của chương trình.\nLuồng byte trong Java Đặc điểm Dữ liệu được xử lý dưới dạng nhị phân Phù hợp với: File nhị phân Ảnh, video Socket mạng Dữ liệu phức tạp Các lớp gốc InputStream – luồng đọc byte OutputStream – luồng ghi byte Cả hai đều là lớp trừu tượng (abstract).\nCác luồng byte đọc phổ biến FileInputStream – đọc byte từ file ByteArrayInputStream – đọc từ mảng byte PipedInputStream – đọc từ luồng pipe Các luồng byte ghi phổ biến FileOutputStream – ghi byte vào file ByteArrayOutputStream – ghi vào mảng byte PipedOutputStream – ghi vào luồng pipe Mô hình đọc/ghi dữ liệu với Stream Quy trình chung khi làm việc với luồng:\nTạo đối tượng Stream Gắn Stream với nguồn hoặc đích Đọc/ghi dữ liệu trong vòng lặp Đóng Stream sau khi hoàn tất Luồng ký tự trong Java Đặc điểm Xử lý dữ liệu dạng Unicode Phù hợp với: File văn bản Chuỗi Dữ liệu hiển thị cho người dùng Các lớp gốc Reader – luồng đọc ký tự Writer – luồng ghi ký tự Các luồng ký tự đọc phổ biến FileReader – đọc file văn bản BufferedReader – đọc có bộ đệm StringReader – đọc chuỗi CharArrayReader – đọc mảng ký tự Các luồng ký tự ghi phổ biến FileWriter – ghi vào file văn bản BufferedWriter – ghi có bộ đệm PrintWriter – ghi dữ liệu dạng dễ đọc StringWriter – ghi chuỗi Luồng lọc dữ liệu (Filtered Streams) Luồng lọc dùng để chuyển đổi dữ liệu từ dạng byte/ký tự sang các kiểu dữ liệu khác.\nCác luồng lọc phổ biến DataInputStream DataOutputStream Cho phép đọc/ghi các kiểu dữ liệu nguyên thủy:\nint float double boolean char Đây là cầu nối giữa luồng thô và dữ liệu có kiểu trong Java.\nLưu trạng thái đối tượng – Serialization Serialization là gì? Serialization (chuỗi hóa) là quá trình chuyển đối tượng Java thành luồng byte để:\nLưu vào file Truyền qua mạng Phục hồi lại sau này Deserialization Ngược lại, Deserialization (giải chuỗi) là quá trình:\nĐọc byte Tái tạo lại đối tượng ban đầu Đây là nền tảng cho:\nLưu dữ liệu chương trình Java RMI Truyền object qua mạng Try-with-resources (TWR) Java hỗ trợ Try-with-resources để:\nTự động đóng stream Tránh rò rỉ tài nguyên Code gọn và an toàn hơn So với try-catch truyền thống, TWR:\nÍt lỗi hơn Dễ bảo trì hơn Được khuyến khích sử dụng Các lỗi I/O thường gặp Khi làm việc với luồng, một số exception phổ biến là:\nFileNotFoundException IOException EOFException UnsupportedEncodingException FileAlreadyExistsException AccessDeniedException SocketException MalformedURLException SerializationException InvalidPathException Việc bắt và xử lý exception đúng cách là yêu cầu bắt buộc trong lập trình Java.\nLiên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính (CMP180), luồng nhập xuất được sử dụng xuyên suốt trong:\nLập trình Socket TCP Lập trình Socket UDP Truyền dữ liệu Client – Server Java RMI Multicast UDP Không hiểu I/O Stream → không thể làm mạng đúng cách.\nKết luận Qua bài học này, ta đã:\nHiểu khái niệm luồng nhập xuất trong Java Phân biệt luồng byte và luồng ký tự Nắm được cách đọc/ghi dữ liệu với Stream Biết vai trò của Serialization và Filtered Streams Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo Khi xử lý các tác vụ mạng (như gọi API), người mới học JS hay viết code lồng nhau kiểu này:\n1 2 3 4 5 6 7 8 9 10 // Cực hình Callback Hell getData(function(a) { getMoreData(a, function(b) { getMoreData(b, function(c) { getMoreData(c, function(d) { console.log(d); }); }); }); }); ","permalink":"http://localhost:1313/blog/bai-viet-3/","summary":"Tổng quan về Input/Output Streams trong Java – nền tảng cho xử lý file, console và lập trình mạng.","title":"Bài 3: Quản lý luồng nhập xuất trong Java"},{"content":"Trong lập trình mạng, trước khi chương trình có thể gửi hoặc nhận dữ liệu, điều quan trọng nhất là xác định đúng địa chỉ kết nối mạng. Nếu xác định sai địa chỉ, chương trình sẽ không thể giao tiếp, dù phần xử lý dữ liệu có đúng đến đâu.\nBài học này giúp bạn hiểu cách Java làm việc với địa chỉ IP, tên miền (DNS) và URL. Đây là nền tảng bắt buộc trước khi đi vào Socket TCP, UDP, Web Crawler và Java RMI.\nĐịa chỉ kết nối mạng là gì? Địa chỉ kết nối mạng là thông tin dùng để xác định máy nào trong mạng cần giao tiếp và dịch vụ nào trên máy đó sẽ xử lý dữ liệu.\nTrong Internet, địa chỉ kết nối thường bao gồm:\nĐịa chỉ IP Tên miền (Domain Name) Cổng (Port) Giao thức (Protocol) DNS – Domain Name System Hình 4.1 – Mô hình hoạt động của DNS (Domain Name System)\nClient gửi yêu cầu phân giải tên miền đến DNS Server, DNS trả về địa chỉ IP tương ứng để client kết nối đến server đích.*\nCon người dễ nhớ tên miền hơn các dãy số IP.\nDNS (Domain Name System) có nhiệm vụ ánh xạ tên miền sang địa chỉ IP, giúp client tìm đúng server cần kết nối.\nVí dụ:\ngoogle.com tương ứng với nhiều địa chỉ IP khác nhau www.cs.yale.edu tương ứng với 128.36.229.30 Nhờ DNS, người dùng không cần ghi nhớ địa chỉ IP khi truy cập Internet. *Hình 4.2 minh họa cấu trúc phân cấp của hệ thống DNS, bao gồm Root Domain, các Top-Level Domain (com, edu, org, vn, …) và các tên miền con phía dưới.\nCấu trúc phân cấp này giúp DNS hoạt động hiệu quả và dễ mở rộng trên toàn Internet.*\nĐịa chỉ IPv4 *Hình 4.3 minh họa khái niệm Zone trong DNS.\nMỗi Zone là một phần của không gian tên miền và được quản lý bởi một DNS Server có thẩm quyền.\nViệc chia DNS thành các Zone giúp hệ thống dễ quản lý, phân quyền và tăng độ tin cậy.*\nIPv4 là dạng địa chỉ phổ biến, gồm 32 bit, thường được viết thành bốn nhóm số.\nVí dụ:\n192.168.1.1 8.8.8.8 Một số dải địa chỉ đặc biệt:\n127.x.x.x là loopback (localhost) 224.0.0.0 – 239.255.255.255 là multicast Lớp InetAddress trong Java Java cung cấp lớp InetAddress để làm việc với địa chỉ IP và DNS.\nLớp này thường được dùng để:\nPhân giải tên miền sang IP Kiểm tra loại địa chỉ Kiểm tra khả năng kết nối mạng Ví dụ minh họa:\n1 InetAddress address = InetAddress.getByName(\u0026#34;google.com\u0026#34;); URL – Uniform Resource Locator URL được dùng để xác định tài nguyên trên Internet như trang web, file hoặc dịch vụ.\nMột URL đầy đủ thường bao gồm các thành phần sau:\nGiao thức (Protocol) Tên miền (Host) Cổng (Port) Đường dẫn (Path) Chuỗi truy vấn (Query) Ví dụ một URL đầy đủ: https://www.hutech.edu.vn/admission?id=123\nURL cho biết lấy dữ liệu ở đâu và bằng cách nào.\nLớp URL trong Java Lớp URL cho phép chương trình Java:\nPhân tích các thành phần của URL Kết nối tới server Đọc dữ liệu từ Internet Ví dụ minh họa:\n1 URL url = new URL(\u0026#34;https://www.example.com\u0026#34;); Ý nghĩa của việc quản lý địa chỉ kết nối mạng Hiểu rõ cách quản lý địa chỉ mạng giúp:\nTránh kết nối sai server Chuẩn bị đúng địa chỉ cho Socket TCP/UDP Hiểu cách Web Crawler hoạt động Nắm vững mô hình Client – Server Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm địa chỉ kết nối mạng Biết vai trò của DNS và IPv4 Nắm được cách Java làm việc với InetAddress Hiểu cấu trúc và vai trò của URL Chuẩn bị nền tảng cho các bài học Socket TCP/UDP tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-4/","summary":"Tìm hiểu cách Java quản lý địa chỉ mạng thông qua InetAddress, URL, URLConnection và DNS.","title":"Bài 4: Quản lý địa chỉ kết nối mạng trong Java"},{"content":"Trong lập trình mạng, TCP Socket là cơ chế quan trọng nhất để xây dựng các ứng dụng Client – Server có độ tin cậy cao.\nBài học này giúp bạn hiểu TCP là gì, vì sao cần TCP, và cách Java triển khai TCP thông qua Socket và ServerSocket.\nĐây là bước chuyển tiếp trực tiếp từ kiến thức địa chỉ mạng (IP, DNS, URL) sang giao tiếp dữ liệu thực tế giữa các chương trình.\nTCP là gì? TCP (Transmission Control Protocol) là giao thức truyền thông hướng kết nối, đảm bảo dữ liệu được truyền:\nĐúng thứ tự Đầy đủ Không bị mất mát Không bị trùng lặp Trước khi truyền dữ liệu, TCP yêu cầu thiết lập kết nối giữa hai bên, và chỉ khi kết nối thành công thì dữ liệu mới được trao đổi.\nVì sao sử dụng TCP? TCP được sử dụng khi ứng dụng yêu cầu độ tin cậy cao, ví dụ:\nỨng dụng chat Ứng dụng client–server Truyền file Game online theo lượt Hệ thống ngân hàng, thương mại điện tử TCP cung cấp các cơ chế quan trọng:\nĐảm bảo dữ liệu: gói tin bị mất sẽ được gửi lại Kiểm soát lỗi: phát hiện và sửa lỗi trong quá trình truyền Kiểm soát luồng: tránh làm quá tải phía nhận Giao tiếp hai chiều: cho phép gửi và nhận dữ liệu đồng thời Cơ chế hoạt động của TCP Hình 5.1 – Socket TCP và cơ chế bắt tay 3 bước (Three-way Handshake)\nHình minh họa quá trình thiết lập kết nối TCP giữa Client và Server.\nClient khởi tạo client socket và gửi yêu cầu kết nối.\nServer lắng nghe qua welcoming socket, sau đó tạo connection socket để giao tiếp riêng với client.\nSau khi kết nối được thiết lập thành công, hai bên trao đổi dữ liệu hai chiều thông qua các luồng byte.\nQuá trình giao tiếp TCP gồm ba giai đoạn chính:\nThiết lập kết nối (Bắt tay 3 bước – Three-way Handshake) Truyền dữ liệu Giải phóng kết nối Nhờ cơ chế này, TCP đảm bảo rằng hai bên luôn sẵn sàng trước khi truyền và kết thúc an toàn sau khi hoàn tất.\nMô hình Client – Server Các ứng dụng TCP thường hoạt động theo mô hình Client – Server.\nServer:\nChạy trước Lắng nghe yêu cầu kết nối Cung cấp dịch vụ Trả kết quả cho client Client:\nChạy sau Chủ động kết nối tới server Gửi yêu cầu Nhận phản hồi từ server Quá trình giao tiếp gồm:\nClient gửi yêu cầu Server xử lý Server trả kết quả cho client Socket trong Java Hình 5.2 – Các bước kết nối TCP Socket giữa Client và Server\nQuy trình kết nối TCP gồm các bước:\nServer tạo ServerSocket và chờ kết nối Client tạo Socket và gửi yêu cầu kết nối Server chấp nhận kết nối bằng accept() Hai bên trao đổi dữ liệu qua InputStream và OutputStream Đóng socket sau khi hoàn tất Mỗi client khi kết nối sẽ có một Socket riêng, giúp server xử lý đồng thời nhiều client.\nTrong Java, Socket đại diện cho điểm cuối giao tiếp giữa client và server khi sử dụng TCP.\nSocket cho phép:\nGửi dữ liệu tới server Nhận dữ liệu từ server Giao tiếp hai chiều thông qua luồng nhập/xuất Ví dụ minh họa tạo Socket phía client:\n1 Socket socket = new Socket(\u0026#34;localhost\u0026#34;, 8080); ServerSocket trong Java ServerSocket được sử dụng ở phía server để:\nMở một cổng lắng nghe Chờ client kết nối Chấp nhận kết nối và tạo Socket giao tiếp ServerSocket đóng vai trò như cửa ngõ, cho phép các client kết nối vào server.\nVí dụ minh họa:\n1 ServerSocket server = new ServerSocket(8080); Luồng dữ liệu trong TCP Socket Sau khi kết nối TCP được thiết lập, client và server trao đổi dữ liệu thông qua các luồng:\nInputStream: dùng để đọc dữ liệu từ socket OutputStream: dùng để ghi dữ liệu vào socket Luồng dữ liệu này hoạt động tương tự như I/O Stream đã học ở bài trước,\nnhưng nguồn và đích là mạng thay vì file hay bàn phím.\nVí dụ ứng dụng: Trò chơi Oẳn Tù Tì Một bài tập tiêu biểu sử dụng TCP Socket là trò chơi Oẳn Tù Tì theo mô hình Client – Server.\nĐặc điểm Server quản lý luật chơi và điểm số Hai client gửi lựa chọn (kéo – búa – bao) Server xác định kết quả và gửi lại cho client Dữ liệu được truyền qua TCP để đảm bảo chính xác Thông qua bài tập này, sinh viên hiểu rõ:\nCách thiết lập kết nối TCP Cách trao đổi dữ liệu giữa nhiều client Cách xử lý lỗi mạng và ngoại lệ Ý nghĩa của lập trình TCP Socket Việc nắm vững TCP Socket giúp bạn:\nHiểu bản chất giao tiếp mạng Xây dựng hệ thống Client – Server thực tế Chuẩn bị cho các bài nâng cao như: Đa tuyến (Multi-thread) Socket UDP Java RMI Ứng dụng mạng phân tán Kết luận Qua bài học này, bạn đã:\nHiểu TCP là gì và vì sao cần TCP Nắm được mô hình Client – Server Biết vai trò của Socket và ServerSocket trong Java Hiểu cách dữ liệu được truyền qua TCP Chuẩn bị nền tảng cho các bài học UDP và xử lý đồng thời tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-5/","summary":"Giải thích mô hình Client–Server và cách lập trình Socket TCP trong Java – nền tảng cho giao tiếp mạng tin cậy.","title":"Bài 5: Lập trình Socket TCP trong Java"},{"content":"#Trong lập trình mạng, không phải lúc nào ứng dụng cũng cần độ tin cậy tuyệt đối như TCP.\nTrong nhiều trường hợp, điều quan trọng hơn là tốc độ truyền nhanh và độ trễ thấp.\nBài học này giới thiệu UDP Socket – cơ chế truyền dữ liệu không kết nối, được sử dụng rộng rãi trong các ứng dụng thời gian thực.\nUDP là gì? UDP (User Datagram Protocol) là giao thức truyền thông không hướng kết nối.\nĐiều này có nghĩa là:\nKhông thiết lập kết nối trước khi truyền Không đảm bảo dữ liệu đến nơi Không đảm bảo thứ tự gói tin Không tự động gửi lại gói tin bị mất UDP gửi dữ liệu theo từng datagram (gói tin độc lập).\nSo sánh TCP và UDP TCP UDP Có kết nối Không kết nối Đảm bảo dữ liệu Không đảm bảo Truyền theo luồng Truyền theo gói Độ trễ cao hơn Độ trễ thấp Phù hợp dữ liệu quan trọng Phù hợp dữ liệu thời gian thực Khi nào sử dụng UDP? UDP được sử dụng khi:\nCần truyền nhanh Có thể chấp nhận mất gói tin Dữ liệu được gửi liên tục Ví dụ ứng dụng UDP:\nTruyền video, audio trực tuyến Game online thời gian thực Chat broadcast DNS Multicast, streaming UDP Socket trong Java Java hỗ trợ UDP thông qua hai lớp chính:\nDatagramSocket: quản lý socket UDP DatagramPacket: đại diện cho gói dữ liệu UDP UDP không phân biệt client hay server rõ ràng như TCP.\nMỗi chương trình chỉ cần một DatagramSocket để gửi và nhận dữ liệu.\nDatagramPacket là gì? DatagramPacket là gói dữ liệu UDP, bao gồm:\nDữ liệu cần gửi Địa chỉ IP đích Số hiệu cổng Mỗi lần gửi hoặc nhận dữ liệu, UDP làm việc với một DatagramPacket riêng biệt.\nLuồng dữ liệu trong UDP UDP không có luồng InputStream / OutputStream như TCP.\nQuy trình truyền dữ liệu UDP:\nTạo DatagramSocket Tạo DatagramPacket chứa dữ liệu Gửi packet đi Nhận packet về Đọc dữ liệu từ packet Mỗi gói tin là độc lập, không liên quan đến các gói khác.\nĐặc điểm quan trọng của UDP Không kiểm soát lỗi Không kiểm soát luồng Không bắt tay kết nối Gửi nhanh, xử lý đơn giản Phù hợp truyền broadcast và multicast Chính vì vậy, UDP thường được dùng khi tốc độ quan trọng hơn độ chính xác tuyệt đối.\nÝ nghĩa của lập trình Socket UDP Nắm vững UDP giúp bạn:\nHiểu bản chất truyền dữ liệu không kết nối Xây dựng ứng dụng thời gian thực Phân biệt rõ TCP và UDP trong thiết kế hệ thống Chuẩn bị cho các chủ đề nâng cao như: Multicast UDP Java RMI Hệ thống phân tán Liên hệ với môn Lập trình Mạng máy tính Trong học phần Lập trình Mạng máy tính, UDP được sử dụng trong:\nSocket UDP Multicast Ứng dụng truyền tin nhanh Game, streaming, broadcast Hiểu UDP giúp bạn chọn đúng giao thức cho từng bài toán thực tế.\nKết luận Qua bài học này, bạn đã:\nHiểu UDP là gì và cơ chế hoạt động Phân biệt được TCP và UDP Biết vai trò của DatagramSocket và DatagramPacket Hiểu cách truyền dữ liệu không kết nối Chuẩn bị nền tảng cho bài Multicast UDP \u0026amp; Java RMI tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-6/","summary":"Giải thích giao thức UDP và cách Java lập trình Socket UDP – nền tảng cho truyền dữ liệu nhanh, không kết nối.","title":"Bài 6: Lập trình Socket UDP trong Java"},{"content":"Trong các ứng dụng mạng thực tế, đặc biệt là Server, chương trình thường phải xử lý nhiều yêu cầu cùng lúc.\nNếu chỉ sử dụng một luồng thực thi, server sẽ bị tắc nghẽn, các client phải chờ đợi và hiệu năng giảm nghiêm trọng.\nVì vậy, lập trình đa tuyến (Multithreading) và xử lý đồng thời (Concurrency) là kỹ thuật bắt buộc trong lập trình mạng.\nTuyến (Thread) là gì? Thread là một dòng điều khiển tuần tự bên trong một chương trình.\nMột chương trình (process) có thể chứa nhiều thread Các thread có thể chạy đồng thời Mỗi thread thực hiện một nhiệm vụ riêng Thread không phải là một chương trình độc lập,\nnó luôn thuộc về một process.\nProcess và Thread Process:\nCó không gian bộ nhớ riêng Chạy độc lập với process khác Tạo và chuyển đổi tốn nhiều tài nguyên Thread:\nChia sẻ bộ nhớ với các thread khác trong cùng process Tạo nhanh hơn process Chuyển đổi nhanh hơn Nhờ thread, chương trình có thể thực hiện nhiều công việc cùng lúc trong cùng một ứng dụng.\nVì sao cần lập trình đa tuyến? Lập trình đa tuyến giúp:\nTăng hiệu suất và khả năng đáp ứng Tận dụng thời gian chờ đợi (I/O, mạng, tải file) Chia nhỏ tác vụ và xử lý đồng thời Cải thiện trải nghiệm người dùng Trong lập trình mạng, đa tuyến cho phép server phục vụ nhiều client cùng lúc.\nThực thi Thread trong Java Trong Java, một thread bắt đầu chạy khi gọi phương thức start().\nKhi thread chạy, JVM thực thi mã trong phương thức run() Khi run() kết thúc, thread cũng kết thúc Một thread không thể start lại, muốn chạy lại phải tạo thread mới Thread cần có điều kiện dừng rõ ràng để tránh chạy vô hạn.\nỨng dụng đa tuyến trong lập trình mạng Ứng dụng Chat đa tuyến Một ví dụ tiêu biểu của đa tuyến trong mạng là ứng dụng chat nhiều client – một server.\nĐặc điểm:\nServer chấp nhận nhiều client kết nối cùng lúc Mỗi client được xử lý bởi một thread riêng Tin nhắn từ một client được gửi tới tất cả client khác Server ghi lại nội dung chat vào file log Thông qua ví dụ này, sinh viên hiểu rõ:\nCách server xử lý nhiều kết nối đồng thời Cách phối hợp giữa socket và thread Vai trò của đa tuyến trong ứng dụng mạng Xử lý đồng thời (Concurrency) Xử lý đồng thời xảy ra khi nhiều thread:\nChạy cùng lúc Truy cập tài nguyên chung (biến, file, bộ nhớ) Nếu không kiểm soát tốt, chương trình có thể gặp các vấn đề nghiêm trọng.\nRace Condition Race Condition xảy ra khi:\nNhiều thread cùng truy cập và thay đổi dữ liệu chung Kết quả phụ thuộc vào thứ tự thực thi không xác định Điều này có thể dẫn đến:\nDữ liệu sai lệch Kết quả không nhất quán Lỗi khó phát hiện Đồng bộ hóa (Synchronization) Để tránh race condition, Java cung cấp cơ chế đồng bộ hóa:\nĐảm bảo chỉ một thread được truy cập tài nguyên tại một thời điểm Giữ cho dữ liệu luôn nhất quán Đồng bộ hóa là nền tảng để xây dựng các ứng dụng an toàn và ổn định khi chạy đa tuyến.\nCác vấn đề thường gặp trong xử lý đồng thời Một số vấn đề phổ biến:\nRace condition: tranh chấp dữ liệu Deadlock: các thread chờ nhau vô hạn Livelock: các thread liên tục phản ứng nhưng không tiến triển Starvation: thread không bao giờ được cấp tài nguyên Những vấn đề này khiến lập trình đa tuyến trở nên phức tạp và khó debug.\nLập lịch Thread trong Java Java sử dụng cơ chế lập lịch theo độ ưu tiên:\nMỗi thread có độ ưu tiên từ MIN_PRIORITY đến MAX_PRIORITY JVM chọn thread runnable có độ ưu tiên cao hơn để chạy Thread có thể nhường CPU cho thread khác bằng cách gọi yield() Việc hiểu cơ chế lập lịch giúp lập trình viên thiết kế thread hợp lý hơn.\nÝ nghĩa của lập trình đa tuyến và xử lý đồng thời Nắm vững kiến thức bài này giúp bạn:\nXây dựng server xử lý nhiều client Viết ứng dụng mạng hiệu năng cao Tránh lỗi tranh chấp dữ liệu Chuẩn bị cho các chủ đề nâng cao như: Server đa tuyến Pooling Threads Multicast UDP Java RMI Hệ thống phân tán Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm thread và multithreading Phân biệt process và thread Biết vai trò của đa tuyến trong lập trình mạng Hiểu các vấn đề xử lý đồng thời và race condition Chuẩn bị nền tảng cho các bài học nâng cao tiếp theo ","permalink":"http://localhost:1313/blog/bai-viet-7/","summary":"Giải thích lập trình đa tuyến và xử lý đồng thời trong Java – nền tảng cho các ứng dụng mạng nhiều client và hệ thống phân tán.","title":"Bài 7: Lập trình đa tuyến và xử lý đồng thời trong Java"},{"content":"Buổi 8 gồm 2 phần lớn:\nMulticast UDP: gửi dữ liệu từ một nguồn đến nhiều máy nhận cùng lúc (1 → N). Java RMI: gọi phương thức từ xa giữa các ứng dụng Java như gọi hàm bình thường (Remote Method Invocation). Đây là các kỹ thuật thường gặp trong streaming, trò chuyện nhóm, giám sát từ xa và hệ thống phân tán.\n1) UDP Multicast Unicast, Broadcast và Multicast Trong mạng máy tính có 3 kiểu gửi dữ liệu phổ biến:\nUnicast: 1 nguồn → 1 đích\nVí dụ: bạn mở một trang web, server trả dữ liệu cho riêng bạn.\nBroadcast: 1 nguồn → tất cả máy trong mạng nội bộ\nVí dụ: một thông báo phát cho toàn bộ LAN.\nMulticast: 1 nguồn → một nhóm máy đã đăng ký nhận dữ liệu\nVí dụ: server phát stream video cho nhóm người xem cùng lúc.\nMulticast là cách truyền hiệu quả khi nhiều máy cùng cần nhận một nội dung giống nhau.\nTại sao dùng UDP Multicast? UDP Multicast thường được dùng vì:\nHiệu suất cao: gửi 1 lần nhưng nhiều máy nhận → giảm tải mạng và server. Đơn giản, nhanh: UDP là kiểu “gửi và quên”, không phải chờ xác nhận. Tối ưu trong LAN: phù hợp môi trường mạng nội bộ (Local Area Network). Rất hợp streaming: audio/video cần tốc độ và độ trễ thấp hơn là đảm bảo tuyệt đối. Ứng dụng của Multicast Multicast có thể dùng trong:\nTruyền phát multimedia trực tiếp (audio/video streaming) Trò chuyện nhóm, hội thoại nhóm Quảng bá thông tin cấu hình mạng và cập nhật trong hệ thống mạng Game nhiều người chơi (gửi trạng thái game cho nhiều người) Phát thông tin trạng thái/cảnh báo cho nhiều thiết bị Phát tán cập nhật phần mềm trong mạng nội bộ Địa chỉ Multicast IPv4 Trong IPv4:\nClass D là dải địa chỉ dành cho multicast Dải địa chỉ multicast thường gặp: 224.0.0.0 – 239.255.255.255 Một số nhóm multicast hay được nhắc:\n224.0.0.1: tất cả host trong local subnet Multicast Group là gì? Multicast hoạt động theo “nhóm”:\nMột multicast group giống như một kênh. Máy nào muốn nhận dữ liệu phải tham gia nhóm (join group). Khi rời nhóm thì không nhận dữ liệu nữa. Multicast trong Java Java hỗ trợ multicast qua lớp:\njava.net.MulticastSocket (kế thừa từ DatagramSocket) Một số thao tác quan trọng:\njoinGroup(...): tham gia nhóm multicast leaveGroup(...): rời nhóm multicast setTimeToLive(ttl): đặt TTL (thời gian sống của gói tin, qua bao nhiêu router) Quy trình gửi dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket Tham gia nhóm multicast Tạo DatagramPacket chứa dữ liệu + địa chỉ nhóm + port Gửi packet Rời nhóm Ví dụ minh họa (ngắn, chỉ để hiểu):\n1 2 3 4 5 6 7 8 9 10 11 12 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(); socket.joinGroup(group); socket.setTimeToLive(5); byte[] data = \u0026#34;Hello Multicast\u0026#34;.getBytes(); DatagramPacket packet = new DatagramPacket(data, data.length, group, 9876); socket.send(packet); socket.leaveGroup(group); socket.close(); Quy trình nhận dữ liệu Multicast (ý tưởng) Các bước chung:\nTạo MulticastSocket lắng nghe trên port Tham gia nhóm multicast Tạo DatagramPacket rỗng để nhận dữ liệu Gọi receive() để chờ gói tin gửi về Đọc dữ liệu từ packet Rời nhóm và đóng socket Ví dụ minh họa (ngắn):\n1 2 3 4 5 6 7 8 9 10 11 12 13 InetAddress group = InetAddress.getByName(\u0026#34;230.0.0.1\u0026#34;); MulticastSocket socket = new MulticastSocket(9876); socket.joinGroup(group); byte[] buf = new byte[1024]; DatagramPacket packet = new DatagramPacket(buf, buf.length); socket.receive(packet); String msg = new String(packet.getData(), 0, packet.getLength()); System.out.println(\u0026#34;Received: \u0026#34; + msg); socket.leaveGroup(group); socket.close(); 2) Java RMI Java RMI là gì? RMI (Remote Method Invocation) cho phép chương trình Java:\nGọi phương thức của một đối tượng nằm trên máy khác Cảm giác giống như gọi method trong cùng chương trình Nói đơn giản:\nClient gọi: remoteObject.sum(1,2) Server thực thi thật và trả kết quả về cho client RMI giúp che giấu toàn bộ chi tiết mạng phía sau, người lập trình chỉ tập trung vào logic.\nVì sao dùng Java RMI? Java RMI được sử dụng vì:\nTích hợp sẵn trong Java, dễ triển khai nếu cả client và server đều dùng Java Gọi phương thức từ xa đơn giản như gọi hàm thông thường Hỗ trợ dữ liệu phức tạp: đối tượng, mảng, class tự định nghĩa Tự động xử lý giao tiếp mạng thông qua cơ chế stub / skeleton Dựa trên TCP/IP nên tương đối ổn định và tin cậy Hạn chế của Java RMI Một số điểm hạn chế cần lưu ý:\nPhụ thuộc Java: chủ yếu phù hợp Java ↔ Java Thiết kế dịch vụ phức tạp vẫn cần tổ chức tốt (đặc biệt khi dùng callback) Quản lý phiên và kết nối không mạnh như các giải pháp hiện đại Bảo mật cần cấu hình cẩn thận trong môi trường thực tế Ý tưởng kiến trúc RMI (hiểu nhanh) Trong Java RMI có các thành phần chính:\nRemote Interface\nKhai báo các phương thức cho phép gọi từ xa\nServer Implementation\nLớp cài đặt interface, chứa logic xử lý thật\nRMI Registry\nNơi đăng ký service để client tìm thấy server\nClient\nTìm (lookup) service trong registry và gọi phương thức\nCác bước triển khai RMI (tóm tắt) Định nghĩa Remote Interface Cài đặt interface bằng một class server (remote object) Viết chương trình server: tạo object và bind vào registry Viết chương trình client: lookup registry và gọi method Chạy RMI registry, chạy server, sau đó chạy client Ví dụ ứng dụng RMI Một số ví dụ thường gặp:\nTính tổng 2 số từ xa Dịch vụ quản lý tài khoản ATM Dịch vụ giám sát nhiệt độ có callback (server gọi ngược lại client) Bài tập gợi ý theo đúng nội dung buổi 8 BT8.01: Mô phỏng streaming video\n(1 server phát, nhiều client nhận dữ liệu)\nBT8.02: Server quản lý tài khoản ATM bằng RMI\n(thêm user, đăng nhập, gửi/rút tiền, lưu lịch sử giao dịch)\nKết luận Qua bài học này, bạn đã:\nHiểu sự khác nhau giữa Unicast, Broadcast và Multicast Nắm được vì sao Multicast UDP phù hợp cho truyền dữ liệu nhóm và streaming Biết cách Java hỗ trợ multicast qua MulticastSocket Hiểu Java RMI và cơ chế gọi phương thức từ xa Chuẩn bị nền tảng cho các bài ứng dụng mạng phân tán và đồ án học phần ","permalink":"http://localhost:1313/blog/bai-viet-8/","summary":"Giải thích Multicast UDP (gửi 1-n) và Java RMI (gọi phương thức từ xa) – nền tảng cho ứng dụng nhóm và hệ phân tán.","title":"Bài 8: Multicast UDP và Java RMI"},{"content":"Sau khi hoàn thành các bài về TCP, UDP, đa tuyến và xử lý đồng thời,\nchúng ta đã có đủ nền tảng để xây dựng một ứng dụng mạng hoàn chỉnh.\nBài học này giúp bạn xâu chuỗi toàn bộ kiến thức đã học,\nhiểu rõ mỗi công nghệ dùng trong trường hợp nào,\nvà cách thiết kế một hệ thống mạng đúng tư duy kỹ sư.\nNhìn lại các mô hình giao tiếp mạng đã học Trong lập trình mạng, các ứng dụng thường được xây dựng dựa trên mô hình Client – Server.\nClient: gửi yêu cầu, nhập dữ liệu, hiển thị kết quả Server: xử lý logic, quản lý dữ liệu, trả kết quả Tùy bài toán, ta lựa chọn giao thức và mô hình phù hợp.\nSo sánh TCP, UDP và Multicast TCP – Giao tiếp tin cậy TCP phù hợp khi:\nCần đảm bảo dữ liệu đúng và đủ Cần kết nối ổn định, hai chiều Ví dụ: chat, truyền file, game theo lượt, hệ thống ngân hàng Đặc trưng:\nCó bắt tay 3 bước Có kiểm soát lỗi, kiểm soát luồng Tốn tài nguyên hơn UDP UDP – Giao tiếp nhanh, không kết nối UDP phù hợp khi:\nƯu tiên tốc độ Chấp nhận mất gói Ví dụ: game thời gian thực, streaming, cảm biến Đặc trưng:\nKhông kết nối Không đảm bảo thứ tự Ít độ trễ UDP Multicast – Truyền dữ liệu nhóm Multicast được dùng khi:\nMột nguồn → nhiều người nhận Dữ liệu giống nhau cho tất cả client Ví dụ: livestream, thông báo hệ thống, truyền trạng thái Ưu điểm:\nGiảm tải server Tiết kiệm băng thông Phù hợp mạng LAN Vai trò của đa tuyến (Multithreading) Trong thực tế, server không thể xử lý từng client một cách tuần tự.\nĐa tuyến giúp:\nNhiều client kết nối cùng lúc Không client nào bị “đóng băng” Tăng khả năng mở rộng hệ thống Ví dụ:\nServer chat: mỗi client là một thread Server TCP: mỗi socket được xử lý riêng Thiết kế một ứng dụng mạng hoàn chỉnh Khi thiết kế, cần xác định rõ:\nGiao thức: TCP hay UDP? Mô hình: 1–1, 1–n, n–n? Đồng thời hay tuần tự? Client gửi gì? Server xử lý gì? Một thiết kế tốt luôn:\nPhân tách rõ giao tiếp – xử lý – dữ liệu Dễ mở rộng Dễ bảo trì Liên hệ với đồ án học phần Các đồ án như:\nChat đa tuyến Oẳn Tù Tì client–server Streaming UDP Dịch vụ RMI Đều là sự kết hợp của các kiến thức đã học,\nkhông phải nội dung mới.\nKết luận Qua bài học này, bạn đã:\nHệ thống lại toàn bộ kiến thức lập trình mạng Hiểu rõ khi nào dùng TCP, UDP, Multicast Nắm được vai trò của đa tuyến Biết cách tư duy thiết kế một ứng dụng mạng hoàn chỉnh Đây là bước chuẩn bị quan trọng trước khi vận dụng toàn bộ kiến thức vào một hệ thống thực tế.\n","permalink":"http://localhost:1313/blog/bai-viet-9/","summary":"Tổng hợp kiến thức TCP, UDP, đa tuyến và cách thiết kế ứng dụng mạng Client–Server hoàn chỉnh.","title":"Bài 9: Tổng hợp kiến thức \u0026 thiết kế ứng dụng mạng"},{"content":"Bài cuối cùng của học phần không nhằm giới thiệu công nghệ mới,\nmà tập trung vào cách vận dụng kiến thức đã học vào thực tế.\nĐây là giai đoạn chuyển từ:\n“Biết dùng” → “Biết thiết kế” → “Biết đánh giá hệ thống”\nTư duy vận dụng kiến thức Một ứng dụng mạng hoàn chỉnh cần trả lời được các câu hỏi:\nVì sao chọn TCP mà không phải UDP? Vì sao cần đa tuyến? Server có chịu được nhiều client không? Hệ thống có mở rộng được không? Đây chính là tư duy kỹ sư, không phải chỉ “chạy được là xong”.\nĐánh giá một ứng dụng mạng Khi hoàn thiện hệ thống, cần xem xét:\n1. Tính đúng đắn Dữ liệu có truyền đúng không? Có mất gói không? Có xử lý lỗi không? 2. Tính đồng thời Nhiều client có dùng chung được không? Có bị treo server không? Có race condition không? 3. Hiệu năng Độ trễ thế nào? Server có bị quá tải không? Có tách luồng hợp lý không? Liên hệ với các mô hình phân tán Các hệ thống đã học là nền tảng cho:\nHệ thống client–server lớn Ứng dụng phân tán Microservices Cloud services Java RMI, TCP đa tuyến hay UDP Multicast\nđều là những viên gạch đầu tiên.\nTừ học phần đến thực tế Sau học phần này, bạn có thể tiếp cận:\nWebSocket REST API gRPC Message Queue (Kafka, RabbitMQ) Hệ thống realtime Tư duy lập trình mạng không thay đổi, chỉ công nghệ thay đổi.\nTổng kết toàn bộ học phần Qua toàn bộ chuỗi bài, bạn đã:\nHiểu cách dữ liệu đi qua mạng Làm việc với TCP, UDP, Multicast Xử lý đa tuyến và đồng thời Tiếp cận lập trình phân tán với RMI Có tư duy thiết kế hệ thống mạng Lời kết Lập trình mạng không chỉ là code socket,\nmà là hiểu cách các hệ thống nói chuyện với nhau.\nNếu bạn hiểu được điều đó,\nbạn đã vượt xa mức “học để qua môn”.\n","permalink":"http://localhost:1313/blog/bai-viet-10/","summary":"Vận dụng toàn bộ kiến thức lập trình mạng để xây dựng, đánh giá và hoàn thiện một ứng dụng thực tế.","title":"Bài 10: Hoàn thiện \u0026 vận dụng lập trình mạng"},{"content":"Lời mở đầu Có những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\nMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\nHọc tập Những năm đại học trôi qua nhanh hơn mình từng nghĩ. Ngày mới bước chân vào giảng đường, mình vẫn còn khá mơ hồ về ngành học, về tương lai, về chính bản thân mình sẽ trở thành ai sau bốn năm. Nhưng rồi từng môn học, từng bài tập nhóm, từng đồ án kéo mình lại gần hơn với cách một hệ thống được hình thành và vận hành.\nHệ thống thông tin không chỉ là lập trình, cũng không đơn thuần là công nghệ. Đó là câu chuyện về con người, quy trình và dữ liệu. Mình học cách đặt câu hỏi, học cách lắng nghe yêu cầu, học cách vẽ ra những sơ đồ tưởng chừng khô khan nhưng lại chứa rất nhiều suy nghĩ phía sau. Dần dần, mình nhận ra mình thích phần “hiểu vấn đề” hơn là chỉ chăm chăm vào lời giải.\nĐịnh hướng Ở thời điểm hiện tại, mình đang định hướng theo con đường Business Analyst (BA). Mình hứng thú với vai trò đứng giữa – không quá xa kỹ thuật, cũng không tách rời nghiệp vụ. Đó là nơi cần sự rõ ràng trong tư duy, sự kiên nhẫn trong giao tiếp và khả năng chuyển hóa những điều mơ hồ thành thứ có thể triển khai được.\nMình không nghĩ BA là một vị trí “nhẹ nhàng” hay “an toàn”. Ngược lại, đó là công việc đòi hỏi phải học rất nhiều, sai rất nhiều và sửa rất nhiều. Nhưng chính điều đó khiến mình thấy phù hợp. Mình muốn hiểu hệ thống trước khi xây dựng nó, muốn biết vì sao người ta see cần một chức năng, chứ không chỉ là nó được viết như thế nào.\nBlog Blog này ra đời khá tự nhiên, giống như một cuốn sổ mở rộng hơn là một trang thể hiện điều gì đó to tát. Mình viết để nhớ, để hệ thống lại những gì đã học, và đôi khi là để sắp xếp lại suy nghĩ của chính mình.\nỞ đây có thể là kiến thức về Hệ thống thông tin, về phân tích nghiệp vụ, về lập trình, hoặc đơn giản là những trải nghiệm học tập và va chạm trong quá trình làm đồ án, làm việc nhóm, và chuẩn bị bước ra môi trường thực tế. Mình không mong mọi thứ phải hoàn hảo, chỉ mong nó thật và có ích cho ai đó đang đi trên con đường tương tự.\nLời kết Mình đang ở một giai đoạn chưa thể gọi là trưởng thành, nhưng cũng không còn quá non nớt. Vẫn đang học, vẫn đang thử, vẫn đang sai và sửa mỗi ngày. Nếu có một điều mình mong giữ được lâu nhất, thì đó là sự tò mò và tinh thần học hỏi – những thứ giúp mình không đứng yên giữa rất nhiều lựa chọn ngoài kia.\nCảm ơn bạn đã ghé qua và đọc những dòng này. Hy vọng ở một thời điểm nào đó, những chia sẻ nhỏ ở đây sẽ chạm đến bạn – dù chỉ là một chút. \u0026ldquo;Học để chia sẻ, chia sẻ để học nhiều hơn.\u0026rdquo;\nLiên hệ Nếu bạn muốn gửi cho mình vài dòng trao đổi,\nbạn có thể liên hệ với mình qua Email hoặc GitHub ,Facebook dưới đây.\nCảm ơn bạn đã ghé thăm blog! ","permalink":"http://localhost:1313/about/","summary":"\u003ch2 id=\"lời-mở-đầu\"\u003eLời mở đầu\u003c/h2\u003e\n\u003cp\u003eCó những lúc, người ta không thật sự cần giới thiệu bản thân mình một cách rõ ràng và rành mạch. Chỉ là muốn viết vài dòng để nhìn lại chính mình, để ghi nhớ mình đã đi đến đâu trong quãng đường tuổi trẻ còn đang tiếp diễn.\u003c/p\u003e\n\u003cp\u003eMình tên là Lê Hoàng Nhật Duy, sinh ngày 27 tháng 7 năm 2004. Hiện tại, mình là sinh viên năm 4 ngành Hệ thống thông tin tại Trường Đại học Công nghệ TP.HCM (HUTECH). Viết những dòng này, mình không đặt nặng chuyện kể cho ai nghe mình là ai, mà chỉ mong lưu lại một lát cắt của bản thân ở thời điểm này – khi mọi thứ vẫn còn đang dang dở, chưa hoàn thiện, nhưng đủ thật để nhìn lại.\u003c/p\u003e","title":"Giới thiệu"}]