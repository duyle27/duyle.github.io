<!doctype html><html lang=vi dir=auto data-theme=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Bài 7: Lập trình đa tuyến và xử lý đồng thời trong Java | Nhật Duy Blog</title><meta name=keywords content="JavaScript,JSON"><meta name=description content="Giải thích lập trình đa tuyến và xử lý đồng thời trong Java – nền tảng cho các ứng dụng mạng nhiều client và hệ thống phân tán."><meta name=author content="Nhật Duy"><link rel=canonical href=http://localhost:1313/blog/bai-viet-7/><link crossorigin=anonymous href=/assets/css/stylesheet.d5a652739bf8a5b9ac39fa208725be6e68ffed64ab75efa1cbbf0cbf6bd6e16f.css integrity="sha256-1aZSc5v4pbmsOfoghyW+bmj/7WSrde+hy78Mv2vW4W8=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=vi href=http://localhost:1313/blog/bai-viet-7/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><link rel=stylesheet href=/css/custom.css><meta property="og:url" content="http://localhost:1313/blog/bai-viet-7/"><meta property="og:site_name" content="Nhật Duy Blog"><meta property="og:title" content="Bài 7: Lập trình đa tuyến và xử lý đồng thời trong Java"><meta property="og:description" content="Giải thích lập trình đa tuyến và xử lý đồng thời trong Java – nền tảng cho các ứng dụng mạng nhiều client và hệ thống phân tán."><meta property="og:locale" content="vi-vn"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2025-12-21T00:00:00+00:00"><meta property="article:modified_time" content="2025-12-21T00:00:00+00:00"><meta property="article:tag" content="JavaScript"><meta property="article:tag" content="JSON"><meta name=twitter:card content="summary"><meta name=twitter:title content="Bài 7: Lập trình đa tuyến và xử lý đồng thời trong Java"><meta name=twitter:description content="Giải thích lập trình đa tuyến và xử lý đồng thời trong Java – nền tảng cho các ứng dụng mạng nhiều client và hệ thống phân tán."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"http://localhost:1313/blog/"},{"@type":"ListItem","position":2,"name":"Bài 7: Lập trình đa tuyến và xử lý đồng thời trong Java","item":"http://localhost:1313/blog/bai-viet-7/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Bài 7: Lập trình đa tuyến và xử lý đồng thời trong Java","name":"Bài 7: Lập trình đa tuyến và xử lý đồng thời trong Java","description":"Giải thích lập trình đa tuyến và xử lý đồng thời trong Java – nền tảng cho các ứng dụng mạng nhiều client và hệ thống phân tán.","keywords":["JavaScript","JSON"],"articleBody":"Trong các ứng dụng mạng thực tế, đặc biệt là Server, chương trình thường phải xử lý nhiều yêu cầu cùng lúc.\nNếu chỉ sử dụng một luồng thực thi, server sẽ bị tắc nghẽn, các client phải chờ đợi và hiệu năng giảm nghiêm trọng.\nVì vậy, lập trình đa tuyến (Multithreading) và xử lý đồng thời (Concurrency) là kỹ thuật bắt buộc trong lập trình mạng.\nTuyến (Thread) là gì? Thread là một dòng điều khiển tuần tự bên trong một chương trình.\nMột chương trình (process) có thể chứa nhiều thread Các thread có thể chạy đồng thời Mỗi thread thực hiện một nhiệm vụ riêng Thread không phải là một chương trình độc lập,\nnó luôn thuộc về một process.\nProcess và Thread Process:\nCó không gian bộ nhớ riêng Chạy độc lập với process khác Tạo và chuyển đổi tốn nhiều tài nguyên Thread:\nChia sẻ bộ nhớ với các thread khác trong cùng process Tạo nhanh hơn process Chuyển đổi nhanh hơn Nhờ thread, chương trình có thể thực hiện nhiều công việc cùng lúc trong cùng một ứng dụng.\nVì sao cần lập trình đa tuyến? Lập trình đa tuyến giúp:\nTăng hiệu suất và khả năng đáp ứng Tận dụng thời gian chờ đợi (I/O, mạng, tải file) Chia nhỏ tác vụ và xử lý đồng thời Cải thiện trải nghiệm người dùng Trong lập trình mạng, đa tuyến cho phép server phục vụ nhiều client cùng lúc.\nThực thi Thread trong Java Trong Java, một thread bắt đầu chạy khi gọi phương thức start().\nKhi thread chạy, JVM thực thi mã trong phương thức run() Khi run() kết thúc, thread cũng kết thúc Một thread không thể start lại, muốn chạy lại phải tạo thread mới Thread cần có điều kiện dừng rõ ràng để tránh chạy vô hạn.\nỨng dụng đa tuyến trong lập trình mạng Ứng dụng Chat đa tuyến Một ví dụ tiêu biểu của đa tuyến trong mạng là ứng dụng chat nhiều client – một server.\nĐặc điểm:\nServer chấp nhận nhiều client kết nối cùng lúc Mỗi client được xử lý bởi một thread riêng Tin nhắn từ một client được gửi tới tất cả client khác Server ghi lại nội dung chat vào file log Thông qua ví dụ này, sinh viên hiểu rõ:\nCách server xử lý nhiều kết nối đồng thời Cách phối hợp giữa socket và thread Vai trò của đa tuyến trong ứng dụng mạng Xử lý đồng thời (Concurrency) Xử lý đồng thời xảy ra khi nhiều thread:\nChạy cùng lúc Truy cập tài nguyên chung (biến, file, bộ nhớ) Nếu không kiểm soát tốt, chương trình có thể gặp các vấn đề nghiêm trọng.\nRace Condition Race Condition xảy ra khi:\nNhiều thread cùng truy cập và thay đổi dữ liệu chung Kết quả phụ thuộc vào thứ tự thực thi không xác định Điều này có thể dẫn đến:\nDữ liệu sai lệch Kết quả không nhất quán Lỗi khó phát hiện Đồng bộ hóa (Synchronization) Để tránh race condition, Java cung cấp cơ chế đồng bộ hóa:\nĐảm bảo chỉ một thread được truy cập tài nguyên tại một thời điểm Giữ cho dữ liệu luôn nhất quán Đồng bộ hóa là nền tảng để xây dựng các ứng dụng an toàn và ổn định khi chạy đa tuyến.\nCác vấn đề thường gặp trong xử lý đồng thời Một số vấn đề phổ biến:\nRace condition: tranh chấp dữ liệu Deadlock: các thread chờ nhau vô hạn Livelock: các thread liên tục phản ứng nhưng không tiến triển Starvation: thread không bao giờ được cấp tài nguyên Những vấn đề này khiến lập trình đa tuyến trở nên phức tạp và khó debug.\nLập lịch Thread trong Java Java sử dụng cơ chế lập lịch theo độ ưu tiên:\nMỗi thread có độ ưu tiên từ MIN_PRIORITY đến MAX_PRIORITY JVM chọn thread runnable có độ ưu tiên cao hơn để chạy Thread có thể nhường CPU cho thread khác bằng cách gọi yield() Việc hiểu cơ chế lập lịch giúp lập trình viên thiết kế thread hợp lý hơn.\nÝ nghĩa của lập trình đa tuyến và xử lý đồng thời Nắm vững kiến thức bài này giúp bạn:\nXây dựng server xử lý nhiều client Viết ứng dụng mạng hiệu năng cao Tránh lỗi tranh chấp dữ liệu Chuẩn bị cho các chủ đề nâng cao như: Server đa tuyến Pooling Threads Multicast UDP Java RMI Hệ thống phân tán Kết luận Qua bài học này, bạn đã:\nHiểu khái niệm thread và multithreading Phân biệt process và thread Biết vai trò của đa tuyến trong lập trình mạng Hiểu các vấn đề xử lý đồng thời và race condition Chuẩn bị nền tảng cho các bài học nâng cao tiếp theo ","wordCount":"808","inLanguage":"vi","datePublished":"2025-12-21T00:00:00Z","dateModified":"2025-12-21T00:00:00Z","author":{"@type":"Person","name":"Nhật Duy"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/blog/bai-viet-7/"},"publisher":{"@type":"Organization","name":"Nhật Duy Blog","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Nhật Duy Blog (Alt + H)">Nhật Duy Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/ title=Home><span>Home</span></a></li><li><a href=http://localhost:1313/blog/ title=Blog><span>Blog</span></a></li><li><a href=http://localhost:1313/categories/ title="Chuyên mục"><span>Chuyên mục</span></a></li><li><a href=http://localhost:1313/tags/ title=Thẻ><span>Thẻ</span></a></li><li><a href=http://localhost:1313/about/ title="Giới thiệu"><span>Giới thiệu</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Trang chủ</a>&nbsp;»&nbsp;<a href=http://localhost:1313/blog/>Blogs</a></div><h1 class="post-title entry-hint-parent">Bài 7: Lập trình đa tuyến và xử lý đồng thời trong Java</h1><div class=post-meta><span title='2025-12-21 00:00:00 +0000 UTC'>21 tháng 12, 2025</span>&nbsp;·&nbsp;<span>4 phút</span>&nbsp;·&nbsp;<span>808 từ</span>&nbsp;·&nbsp;<span>Nhật Duy</span></div></header><div class=post-content><p>Trong các ứng dụng mạng thực tế, đặc biệt là <strong>Server</strong>, chương trình thường phải xử lý <strong>nhiều yêu cầu cùng lúc</strong>.<br>Nếu chỉ sử dụng một luồng thực thi, server sẽ bị <strong>tắc nghẽn</strong>, các client phải chờ đợi và hiệu năng giảm nghiêm trọng.</p><p>Vì vậy, <strong>lập trình đa tuyến (Multithreading)</strong> và <strong>xử lý đồng thời (Concurrency)</strong> là kỹ thuật bắt buộc trong lập trình mạng.</p><hr><h2 id=tuyến-thread-là-gì>Tuyến (Thread) là gì?<a hidden class=anchor aria-hidden=true href=#tuyến-thread-là-gì>#</a></h2><p><strong>Thread</strong> là một <strong>dòng điều khiển tuần tự</strong> bên trong một chương trình.</p><ul><li>Một chương trình (process) có thể chứa <strong>nhiều thread</strong></li><li>Các thread có thể <strong>chạy đồng thời</strong></li><li>Mỗi thread thực hiện một nhiệm vụ riêng</li></ul><p>Thread <strong>không phải</strong> là một chương trình độc lập,<br>nó luôn <strong>thuộc về một process</strong>.</p><hr><h2 id=process-và-thread>Process và Thread<a hidden class=anchor aria-hidden=true href=#process-và-thread>#</a></h2><ul><li><p><strong>Process</strong>:</p><ul><li>Có không gian bộ nhớ riêng</li><li>Chạy độc lập với process khác</li><li>Tạo và chuyển đổi tốn nhiều tài nguyên</li></ul></li><li><p><strong>Thread</strong>:</p><ul><li>Chia sẻ bộ nhớ với các thread khác trong cùng process</li><li>Tạo nhanh hơn process</li><li>Chuyển đổi nhanh hơn</li></ul></li></ul><p>Nhờ thread, chương trình có thể <strong>thực hiện nhiều công việc cùng lúc</strong> trong cùng một ứng dụng.</p><hr><h2 id=vì-sao-cần-lập-trình-đa-tuyến>Vì sao cần lập trình đa tuyến?<a hidden class=anchor aria-hidden=true href=#vì-sao-cần-lập-trình-đa-tuyến>#</a></h2><p>Lập trình đa tuyến giúp:</p><ul><li><strong>Tăng hiệu suất và khả năng đáp ứng</strong></li><li><strong>Tận dụng thời gian chờ đợi</strong> (I/O, mạng, tải file)</li><li><strong>Chia nhỏ tác vụ</strong> và xử lý đồng thời</li><li><strong>Cải thiện trải nghiệm người dùng</strong></li></ul><p>Trong lập trình mạng, đa tuyến cho phép server <strong>phục vụ nhiều client cùng lúc</strong>.</p><hr><h2 id=thực-thi-thread-trong-java>Thực thi Thread trong Java<a hidden class=anchor aria-hidden=true href=#thực-thi-thread-trong-java>#</a></h2><p>Trong Java, một thread bắt đầu chạy khi gọi phương thức <code>start()</code>.</p><ul><li>Khi thread chạy, JVM thực thi mã trong phương thức <code>run()</code></li><li>Khi <code>run()</code> kết thúc, thread cũng kết thúc</li><li>Một thread <strong>không thể start lại</strong>, muốn chạy lại phải tạo thread mới</li></ul><p>Thread cần có <strong>điều kiện dừng rõ ràng</strong> để tránh chạy vô hạn.</p><hr><h2 id=ứng-dụng-đa-tuyến-trong-lập-trình-mạng>Ứng dụng đa tuyến trong lập trình mạng<a hidden class=anchor aria-hidden=true href=#ứng-dụng-đa-tuyến-trong-lập-trình-mạng>#</a></h2><h3 id=ứng-dụng-chat-đa-tuyến>Ứng dụng Chat đa tuyến<a hidden class=anchor aria-hidden=true href=#ứng-dụng-chat-đa-tuyến>#</a></h3><p>Một ví dụ tiêu biểu của đa tuyến trong mạng là <strong>ứng dụng chat nhiều client – một server</strong>.</p><p>Đặc điểm:</p><ul><li>Server chấp nhận nhiều client kết nối cùng lúc</li><li>Mỗi client được xử lý bởi <strong>một thread riêng</strong></li><li>Tin nhắn từ một client được gửi tới tất cả client khác</li><li>Server ghi lại nội dung chat vào file log</li></ul><p>Thông qua ví dụ này, sinh viên hiểu rõ:</p><ul><li>Cách server xử lý nhiều kết nối đồng thời</li><li>Cách phối hợp giữa socket và thread</li><li>Vai trò của đa tuyến trong ứng dụng mạng</li></ul><hr><h2 id=xử-lý-đồng-thời-concurrency>Xử lý đồng thời (Concurrency)<a hidden class=anchor aria-hidden=true href=#xử-lý-đồng-thời-concurrency>#</a></h2><p><strong>Xử lý đồng thời</strong> xảy ra khi nhiều thread:</p><ul><li>Chạy cùng lúc</li><li>Truy cập <strong>tài nguyên chung</strong> (biến, file, bộ nhớ)</li></ul><p>Nếu không kiểm soát tốt, chương trình có thể gặp các vấn đề nghiêm trọng.</p><hr><h2 id=race-condition>Race Condition<a hidden class=anchor aria-hidden=true href=#race-condition>#</a></h2><p><strong>Race Condition</strong> xảy ra khi:</p><ul><li>Nhiều thread cùng truy cập và thay đổi dữ liệu chung</li><li>Kết quả phụ thuộc vào <strong>thứ tự thực thi không xác định</strong></li></ul><p>Điều này có thể dẫn đến:</p><ul><li>Dữ liệu sai lệch</li><li>Kết quả không nhất quán</li><li>Lỗi khó phát hiện</li></ul><hr><h2 id=đồng-bộ-hóa-synchronization>Đồng bộ hóa (Synchronization)<a hidden class=anchor aria-hidden=true href=#đồng-bộ-hóa-synchronization>#</a></h2><p>Để tránh race condition, Java cung cấp cơ chế <strong>đồng bộ hóa</strong>:</p><ul><li>Đảm bảo <strong>chỉ một thread</strong> được truy cập tài nguyên tại một thời điểm</li><li>Giữ cho dữ liệu luôn nhất quán</li></ul><p>Đồng bộ hóa là nền tảng để xây dựng các ứng dụng <strong>an toàn và ổn định</strong> khi chạy đa tuyến.</p><hr><h2 id=các-vấn-đề-thường-gặp-trong-xử-lý-đồng-thời>Các vấn đề thường gặp trong xử lý đồng thời<a hidden class=anchor aria-hidden=true href=#các-vấn-đề-thường-gặp-trong-xử-lý-đồng-thời>#</a></h2><p>Một số vấn đề phổ biến:</p><ul><li><strong>Race condition</strong>: tranh chấp dữ liệu</li><li><strong>Deadlock</strong>: các thread chờ nhau vô hạn</li><li><strong>Livelock</strong>: các thread liên tục phản ứng nhưng không tiến triển</li><li><strong>Starvation</strong>: thread không bao giờ được cấp tài nguyên</li></ul><p>Những vấn đề này khiến lập trình đa tuyến trở nên <strong>phức tạp và khó debug</strong>.</p><hr><h2 id=lập-lịch-thread-trong-java>Lập lịch Thread trong Java<a hidden class=anchor aria-hidden=true href=#lập-lịch-thread-trong-java>#</a></h2><p>Java sử dụng cơ chế <strong>lập lịch theo độ ưu tiên</strong>:</p><ul><li>Mỗi thread có độ ưu tiên từ <code>MIN_PRIORITY</code> đến <code>MAX_PRIORITY</code></li><li>JVM chọn thread runnable có độ ưu tiên cao hơn để chạy</li><li>Thread có thể nhường CPU cho thread khác bằng cách gọi <code>yield()</code></li></ul><p>Việc hiểu cơ chế lập lịch giúp lập trình viên <strong>thiết kế thread hợp lý hơn</strong>.</p><hr><h2 id=ý-nghĩa-của-lập-trình-đa-tuyến-và-xử-lý-đồng-thời>Ý nghĩa của lập trình đa tuyến và xử lý đồng thời<a hidden class=anchor aria-hidden=true href=#ý-nghĩa-của-lập-trình-đa-tuyến-và-xử-lý-đồng-thời>#</a></h2><p>Nắm vững kiến thức bài này giúp bạn:</p><ul><li>Xây dựng server xử lý nhiều client</li><li>Viết ứng dụng mạng hiệu năng cao</li><li>Tránh lỗi tranh chấp dữ liệu</li><li>Chuẩn bị cho các chủ đề nâng cao như:<ul><li>Server đa tuyến</li><li>Pooling Threads</li><li>Multicast UDP</li><li>Java RMI</li><li>Hệ thống phân tán</li></ul></li></ul><hr><h2 id=kết-luận>Kết luận<a hidden class=anchor aria-hidden=true href=#kết-luận>#</a></h2><p>Qua bài học này, bạn đã:</p><ul><li>Hiểu khái niệm thread và multithreading</li><li>Phân biệt process và thread</li><li>Biết vai trò của đa tuyến trong lập trình mạng</li><li>Hiểu các vấn đề xử lý đồng thời và race condition</li><li>Chuẩn bị nền tảng cho các bài học nâng cao tiếp theo</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/javascript/>JavaScript</a></li><li><a href=http://localhost:1313/tags/json/>JSON</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/blog/bai-viet-6/><span class=title>« Trang trước</span><br><span>Bài 6: Lập trình Socket UDP trong Java</span>
</a><a class=next href=http://localhost:1313/blog/bai-viet-8/><span class=title>Trang tiếp theo »</span><br><span>Bài 8: Multicast UDP và Java RMI</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>Nhật Duy Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Sao chép";function s(){t.innerHTML="Đã sao chép!",setTimeout(()=>{t.innerHTML="Sao chép"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>